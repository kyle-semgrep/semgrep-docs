"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[79501],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(96540);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}},31340:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"writing-rules/experiments/aliengrep","title":"Aliengrep","description":"Aliengrep is a variant of the generic mode that is more configurable than spacegrep.","source":"@site/docs/writing-rules/experiments/aliengrep.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/aliengrep","permalink":"/semgrep-docs/writing-rules/experiments/aliengrep","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/writing-rules/experiments/aliengrep.md","tags":[],"version":"current","lastUpdatedAt":1752254305000,"frontMatter":{"slug":"aliengrep","append_help_link":true,"description":"Aliengrep is a variant of the generic mode that is more configurable than spacegrep.","title":"Aliengrep","hide_title":true},"sidebar":"rulewritingSidebar","previous":{"title":"Pattern syntax (Experimental)","permalink":"/semgrep-docs/writing-rules/experiments/pattern-syntax"},"next":{"title":"Displaying propagated value of metavariables","permalink":"/semgrep-docs/writing-rules/experiments/display-propagated-metavariable"}}');var a=i(74848),t=i(28453);const r={slug:"aliengrep",append_help_link:!0,description:"Aliengrep is a variant of the generic mode that is more configurable than spacegrep.",title:"Aliengrep",hide_title:!0},l="Aliengrep",c={},d=[{value:"Minimal example",id:"minimal-example",level:2},{value:"Pattern syntax",id:"pattern-syntax",level:2},{value:"Whitespace",id:"whitespace",level:3},{value:"Metavariables",id:"metavariables",level:3},{value:"Ellipsis (<code>...</code>)",id:"ellipsis-",level:3},{value:"Ellipsis metavariable (capturing ellipsis)",id:"ellipsis-metavariable-capturing-ellipsis",level:3},{value:"Single-line mode",id:"single-line-mode",level:3},{value:"Long ellipsis (<code>....</code>)",id:"long-ellipsis-",level:3},{value:"Additional word characters captured by metavariables",id:"additional-word-characters-captured-by-metavariables",level:3},{value:"Custom brackets",id:"custom-brackets",level:3},{value:"Case-insensitive matching",id:"case-insensitive-matching",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"aliengrep",children:"Aliengrep"})}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["This is an experimental matching mode for Semgrep Community Edition (CE). Many of the features described in this document are subject to change. Your feedback is important and helps us, the Semgrep team, to make desirable adjustments. You can file an issue in our ",(0,a.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/issues",children:"Semgrep CE GitHub repository"})," or ask us anything in ",(0,a.jsx)("a",{href:"https://go.semgrep.dev/slack",children:"Semgrep Community Slack group"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["Aliengrep is an alternative to the ",(0,a.jsx)(n.a,{href:"/writing-rules/generic-pattern-matching",children:"generic pattern-matching engine"})," for analyzing files written in any language. The pattern syntax resembles the usual Semgrep pattern syntax. This document provides a reference to the syntactic features that Aliengrep supports."]}),"\n",(0,a.jsx)(n.h2,{id:"minimal-example",children:"Minimal example"}),"\n",(0,a.jsxs)(n.p,{children:["Specify that a rule uses the Aliengrep engine by setting ",(0,a.jsx)(n.code,{children:"options.generic_engine: aliengrep"}),". See the Semgrep rule example below:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: example\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n  message: "found the word \'hello\'"\n  pattern: "hello"\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["We are considering a dedicated field ",(0,a.jsx)(n.code,{children:"analyzer: aliengrep"})," instead of ",(0,a.jsx)(n.code,{children:"options.generic_engine: aliengrep"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"pattern-syntax",children:"Pattern syntax"}),"\n",(0,a.jsx)(n.p,{children:"The following sections provide descriptions and examples of operators that Aliengrep uses in YAML rule files."}),"\n",(0,a.jsx)(n.h3,{id:"whitespace",children:"Whitespace"}),"\n",(0,a.jsxs)(n.p,{children:["The whitespace between lexical elements is ignored. By default, whitespace includes spaces, tabs, and newlines. The single-line mode restricts whitespace to only spaces and tabs (see ",(0,a.jsx)(n.a,{href:"#single-line-mode",children:"Single-line mode"})," section below)."]}),"\n",(0,a.jsx)(n.p,{children:"Lexical elements in target input are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"words (configurable)"}),"\n",(0,a.jsx)(n.li,{children:"brace pairs (configurable)"}),"\n",(0,a.jsx)(n.li,{children:"single non-word characters"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"metavariables",children:"Metavariables"}),"\n",(0,a.jsxs)(n.p,{children:["A metavariable captures a single word in the target input. By default, the set of word characters is ",(0,a.jsx)(n.code,{children:"[A-Za-z_0-9]"}),". The pattern ",(0,a.jsx)(n.code,{children:"$THING"})," matches a whole word such as ",(0,a.jsx)(n.code,{children:"hello"})," or ",(0,a.jsx)(n.code,{children:"world"})," if the target input is ",(0,a.jsx)(n.code,{children:"hello, world."}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: example\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n  message: "found a word"\n  pattern: "$THING"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Repeating a metavariable (back-reference) requires a match of the same sequence that was matched by the first occurrence of the metavariable. For example, the pattern ",(0,a.jsx)(n.code,{children:"$A ... $A"})," matches ",(0,a.jsx)(n.code,{children:"a x y a"}),", assigning ",(0,a.jsx)(n.code,{children:"a"})," to the metavariable ",(0,a.jsx)(n.code,{children:"A"}),". It does not match ",(0,a.jsx)(n.code,{children:"a x b"}),"."]}),"\n",(0,a.jsxs)(n.h3,{id:"ellipsis-",children:["Ellipsis (",(0,a.jsx)(n.code,{children:"..."}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["In Semgrep rule syntax, an ellipsis is a specific pattern written as three dots ",(0,a.jsx)(n.code,{children:"..."}),". Ellipsis matches a sequence of any lexical elements. Matching ellipses is lazy or shortest-match-first. For example, the pattern ",(0,a.jsx)(n.code,{children:"a ... b"})," matches ",(0,a.jsx)(n.code,{children:"a x b"})," rather than ",(0,a.jsx)(n.code,{children:"a x b b"})," if the target input is ",(0,a.jsx)(n.code,{children:"a x b b c"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Ellipses at the beginning or at the end of a pattern are anchored. For example, ellipses must match the beginning or the end of the target input, respectively. For example, ",(0,a.jsx)(n.code,{children:"..."})," alone matches the whole input and ",(0,a.jsx)(n.code,{children:"a ..."})," matches the whole input starting from the first occurrence of the word ",(0,a.jsx)(n.code,{children:"a"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"ellipsis-metavariable-capturing-ellipsis",children:"Ellipsis metavariable (capturing ellipsis)"}),"\n",(0,a.jsxs)(n.p,{children:["An ellipsis metavariable ",(0,a.jsx)(n.code,{children:"$...X"})," matches the same contents as an ordinary ellipsis ",(0,a.jsx)(n.code,{children:"..."})," but additionally captures the contents and assigns them to the metavariable ",(0,a.jsx)(n.code,{children:"X"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Repeating a metavariable ellipsis such as in ",(0,a.jsx)(n.code,{children:"$...A, $...A"})," requires the same contents to be matched by each repetition, including the same whitespace. This is an unfortunate limitation of the implementation. For example, ",(0,a.jsx)(n.code,{children:"$...A, $...A"})," matches ",(0,a.jsx)(n.code,{children:"1 2, 1 2"})," and ",(0,a.jsx)(n.code,{children:"1   2, 1   2"})," but it doesn't match ",(0,a.jsx)(n.code,{children:"1 2, 1   2"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"single-line-mode",children:"Single-line mode"}),"\n",(0,a.jsxs)(n.p,{children:["Se the single-line mode with ",(0,a.jsx)(n.code,{children:"options.generic_multiline: false"})," in rule files:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: single-line-example\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_multiline: false\n  message: "found a password field"\n  pattern: "password: ..."\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now instead of matching everything until the end of the target input file, the pattern ",(0,a.jsx)(n.code,{children:"password: ..."})," stops the match at the end of the line. In single-line mode, a regular ellipsis ",(0,a.jsx)(n.code,{children:"..."})," or its named variant ",(0,a.jsx)(n.code,{children:"$...X"})," cannot span multiple lines."]}),"\n",(0,a.jsx)(n.p,{children:"Another feature of the single-line mode is that newlines in rule patterns must match literally. For example, the following YAML rule contains a two-line pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: single-line-example2\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_multiline: false\n  message: "found a password field"\n  pattern: "a\\nb"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The pattern ",(0,a.jsx)(n.code,{children:'"a\\nb"'})," in the YAML rule file matches the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"x a\nb x\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The pattern does not match if there is another number of newlines between ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),". The single-line mode does not match the following target input:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"x a b x\n"})}),"\n",(0,a.jsx)(n.p,{children:"It does however match in the default multiline mode of Aliengrep."}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["YAML syntax makes it easy to introduce significant newline characters in patterns without realizing it. When in doubt and for better clarity, use the quoted string syntax ",(0,a.jsx)(n.code,{children:'"a\\nb"'})," as we did in the preceding example. This ensures no trailing newline is added accidentally when using the single-line mode."]})}),"\n",(0,a.jsxs)(n.h3,{id:"long-ellipsis-",children:["Long ellipsis (",(0,a.jsx)(n.code,{children:"...."}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["A long ellipsis (written as four dots, ",(0,a.jsx)(n.code,{children:"...."}),") and its capturing variant ",(0,a.jsx)(n.code,{children:"$....X"})," matches a sequence of any lexical elements even in single-line mode. It's useful for skipping any number of lines in single-line mode."]}),"\n",(0,a.jsxs)(n.p,{children:["In multiline mode, a regular ellipsis (three dots ",(0,a.jsx)(n.code,{children:"..."}),") has the same behavior as a long ellipsis (four dots ",(0,a.jsx)(n.code,{children:"...."}),")."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["We wonder if the visual difference between ",(0,a.jsx)(n.code,{children:"..."})," and ",(0,a.jsx)(n.code,{children:"...."})," is too subtle. Let us know if you have ideas for a better syntax than four dots ",(0,a.jsx)(n.code,{children:"...."}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"additional-word-characters-captured-by-metavariables",children:"Additional word characters captured by metavariables"}),"\n",(0,a.jsxs)(n.p,{children:["In the generic modes, a metavariable captures a word. The default pattern followed by a word is ",(0,a.jsx)(n.code,{children:"[A-Za-z_0-9]+"})," (a sequence of one or more alphanumeric characters or underscores). The set of characters that comprise a word can be configured as an option in the Semgrep rule as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: custom-word-chars\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_extra_word_characters: ["+", "/", "="]\n  message: "found something"\n  pattern: "data = $DATA;"\n'})}),"\n",(0,a.jsx)(n.p,{children:"The preceding example allows matching Base64-encoded data such as in the following target input:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"data = bGlnaHQgd29yaw==;\n"})}),"\n",(0,a.jsx)(n.p,{children:"There's currently no option to remove word characters from the default\nset."}),"\n",(0,a.jsx)(n.h3,{id:"custom-brackets",children:"Custom brackets"}),"\n",(0,a.jsxs)(n.p,{children:["The Aliengrep engine performs brace matching as expected in English text. The default brace pairs are parentheses (",(0,a.jsx)(n.code,{children:"()"}),"), square brackets (",(0,a.jsx)(n.code,{children:"[]"}),"), and curly braces (",(0,a.jsx)(n.code,{children:"{}"}),"). In single-line mode, ASCII single quotes and double quotes are also treated like brace pairs by default. The following rule demonstrates the addition of ",(0,a.jsx)(n.code,{children:"<>"})," as an extra pair of braces by specifying ",(0,a.jsx)(n.code,{children:"options.generic_extra_braces"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: edgy-brackets\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_extra_braces: [["<", ">"]]\n  message: "found something"\n  pattern: "x ... x"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This pattern matches the ",(0,a.jsx)(n.code,{children:"x <x> x"})," in the following target input:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"a x <x> x a\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Without declaring ",(0,a.jsx)(n.code,{children:"<>"})," as braces, the rule would match only ",(0,a.jsx)(n.code,{children:"x <x"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The set of brace pairs can be completely replaced by using the field ",(0,a.jsx)(n.code,{children:"options.generic_braces"})," as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: edgy-brackets-only\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_braces: [["<", ">"]]\n  message: "found something"\n  pattern: "x ... x"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"case-insensitive-matching",children:"Case-insensitive matching"}),"\n",(0,a.jsxs)(n.p,{children:["Some languages are case-insensitive according to Unicode rules (UTF-8 encoding). To deal with this, Aliengrep offers an option for case-insensitive matching ",(0,a.jsx)(n.code,{children:"options.generic_caseless: true"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: caseless\n  severity: WARNING\n  languages: [generic]\n  options:\n    generic_engine: aliengrep\n    generic_multiline: false\n    generic_caseless: true\n  message: "found something"\n  pattern: "Content-Type: $...CT"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This rule matches ",(0,a.jsx)(n.code,{children:"Content-Type: text/html"})," but also ",(0,a.jsx)(n.code,{children:"content-type: text/html"})," or ",(0,a.jsx)(n.code,{children:"CONTENT-TyPe: text/HTML"})," among all the possible variants."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsxs)(n.p,{children:["Back-referencing a metavariable requires an exact repeat of the text captured by the metavariable, even in caseless mode. For example, ",(0,a.jsx)(n.code,{children:"$X $X"})," matches ",(0,a.jsx)(n.code,{children:"ab ab"})," and ",(0,a.jsx)(n.code,{children:"AB AB"})," but not ",(0,a.jsx)(n.code,{children:"ab AB"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);