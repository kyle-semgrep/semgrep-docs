"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[81275],{12011:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"semgrep-code/java","title":"Semantic detection in Java","description":"Proprietary Semgrep features for the Java language that can increase true positives and reduce false positives.","source":"@site/docs/semgrep-code/java.md","sourceDirName":"semgrep-code","slug":"/semgrep-code/java","permalink":"/semgrep-docs/semgrep-code/java","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/semgrep-code/java.md","tags":[{"inline":true,"label":"Semgrep Code","permalink":"/semgrep-docs/tags/semgrep-code"},{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1753214405000,"frontMatter":{"slug":"java","append_help_link":true,"title":"Semantic detection in Java","hide_title":true,"description":"Proprietary Semgrep features for the Java language that can increase true positives and reduce false positives.","tags":["Semgrep Code","Rule writing"]},"sidebar":"scanSidebar","previous":{"title":"Language-specific features","permalink":"/semgrep-docs/category/language-specific-features"},"next":{"title":"Glossaries","permalink":"/semgrep-docs/category/glossaries"}}');var i=t(74848),a=t(28453);const r={slug:"java",append_help_link:!0,title:"Semantic detection in Java",hide_title:!0,description:"Proprietary Semgrep features for the Java language that can increase true positives and reduce false positives.",tags:["Semgrep Code","Rule writing"]},l="Semantic detection in Java",o={},d=[{value:"Language features that prevent injection through Boolean and integer types",id:"language-features-that-prevent-injection-through-boolean-and-integer-types",level:2},{value:"Example: <code>int-bool-untainted</code>",id:"example-int-bool-untainted",level:3},{value:"Semgrep understands the Java standard library and APIs",id:"semgrep-understands-the-java-standard-library-and-apis",level:2},{value:"Example: <code>sqli-demo-bool_doesnt_taint</code>",id:"example-sqli-demo-bool_doesnt_taint",level:3},{value:"Semgrep targets code in a parent class and its subclasses",id:"semgrep-targets-code-in-a-parent-class-and-its-subclasses",level:2},{value:"Example: <code>detect-pattern-in-subclass</code>",id:"example-detect-pattern-in-subclass",level:3},{value:"Semgrep supports field and index sensitivity",id:"semgrep-supports-field-and-index-sensitivity",level:2},{value:"Example: <code>unsafe-sql-concatenation-in-method-taint-field-sensitivity</code>",id:"example-unsafe-sql-concatenation-in-method-taint-field-sensitivity",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"semantic-detection-in-java",children:"Semantic detection in Java"})}),"\n",(0,i.jsx)(n.p,{children:"This document explains how Semgrep detects true positives and reduces false positives in Java."}),"\n",(0,i.jsx)(n.p,{children:"Additionally, it provides several simple rule examples to illustrate the concepts and how you can make use of these Semgrep features when writing your own rules."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The code examples shown here are best viewed in ",(0,i.jsx)(n.strong,{children:"a separate Semgrep Playground tab"})," so that you can see the ",(0,i.jsx)("span",{style:{backgroundColor:"#b968ff"},children:(0,i.jsx)("i",{class:"fa-regular fa-star"})})," purple star outline. This star marks the lines that contain false positives and are correctly identified and removed by Semgrep."]})}),"\n",(0,i.jsx)(n.h2,{id:"language-features-that-prevent-injection-through-boolean-and-integer-types",children:"Language features that prevent injection through Boolean and integer types"}),"\n",(0,i.jsx)(n.p,{children:"Strong typing in Java, combined with its compile-time and runtime checks, reduces the likelihood that an integer or Boolean input will be exploited to perform injection-style attacks. Semgrep Pro can reduce false positives by leveraging these checks."}),"\n",(0,i.jsx)(n.p,{children:"Semgrep Community Edition (CE) matches based on patterns, which can result in false positives (FPs), but only proprietary Semgrep can detect Boolean and integer values and mark these as untainted, or safe, eliminating FPs."}),"\n",(0,i.jsxs)(n.h3,{id:"example-int-bool-untainted",children:["Example: ",(0,i.jsx)(n.code,{children:"int-bool-untainted"})]}),"\n",(0,i.jsxs)(n.p,{children:["The following demo rule and code sample detects tainted data in ",(0,i.jsx)(n.code,{children:"sink()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:"# Semgrep rule\nrules:\n  - id: int-bool-untainted\n    languages:\n      - java\n    severity: WARNING\n    options:\n      interfile: true\n      taint_assume_safe_booleans: true\n      taint_assume_safe_numbers: true\n    mode: taint\n    message: Test\n    pattern-sources:\n      - patterns:\n          - pattern-inside: |\n              class $C {\n                $T $M(..., $A, ...) {\n                  ...\n                }\n              }\n          - focus-metavariable: $A\n    pattern-sinks:\n      - pattern: sink(...)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:"class Foo {\n  String x;\n  List<Integer> ids;\n\n  public List<Integer> getIds() {\n    return ids;\n  }\n}\n\nclass Bar {\n  String y;\n  Set<Boolean> flags;\n\n  public Set<Boolean> getFlags() {\n    return flags;\n  }\n}\n\nclass Test {\n  public void test1(Foo foo) {\n      //ruleid: int-bool-untainted\n      //highlight-next-line\n      sink(foo.x);\n      //OK: int-bool-untainted\n\u2606     sink(foo.getIds().get(0));\n  }\n  public void test2(Bar bar) {\n      //ruleid: int-bool-untainted\n      //highlight-next-line\n      sink(bar.y);\n      //OK: int-bool-untainted\n\u2606     sink(bar.getFlags().get(0));\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure"}),". ",(0,i.jsx)(n.code,{children:"int-bool-untainted"}),". ",(0,i.jsxs)(n.a,{href:"https://semgrep.dev/playground/s/r6rKR",children:[(0,i.jsx)("i",{class:"fas fa-external-link fa-xs"})," Open in interactive Playground"]}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This example has two true positives: ",(0,i.jsx)(n.strong,{children:"line 22"})," and ",(0,i.jsx)(n.strong,{children:"line 28"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep Pro is able to detect that ",(0,i.jsx)(n.strong,{children:"line 24 and 30 are false positives"}),". Semgrep CE can't catch that distinction.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Line 24 is a false positive because the data in the sink is an element of an integer list."}),"\n",(0,i.jsx)(n.li,{children:"Line 30 is a false positive because the data in the sink is an element in a set of Boolean values."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The Semgrep rule uses the fields ",(0,i.jsx)(n.code,{children:"taint_assume_safe_booleans"})," and ",(0,i.jsx)(n.code,{children:"taint_assume_safe_numbers"})," to tell the engine that these types are safe and not tainted."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"semgrep-understands-the-java-standard-library-and-apis",children:"Semgrep understands the Java standard library and APIs"}),"\n",(0,i.jsx)(n.p,{children:"Java provides a wide array of standard classes and methods across its various libraries. These facilitate programming by offering ready-to-use methods for common tasks. Many of these take string inputs, and return integer or Boolean values. Thus, these statements returning integer or Boolean values are not considered tainted. Semgrep is able to make that distinction, preventing this type of false positive."}),"\n",(0,i.jsxs)(n.h3,{id:"example-sqli-demo-bool_doesnt_taint",children:["Example: ",(0,i.jsx)(n.code,{children:"sqli-demo-bool_doesnt_taint"})]}),"\n",(0,i.jsxs)(n.p,{children:["This demo rule detects SQL injection through a ",(0,i.jsx)(n.code,{children:"UserInputGenerator"})," class. The class's unsanitized user input is passed to ",(0,i.jsx)(n.code,{children:"SQLQueryRunner"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:"# Semgrep rule\nrules:\n  - id: sqli-demo-bool_doesnt_taint\n    message: Found SQLi\n    languages:\n      - java\n    severity: WARNING\n    mode: taint\n    options:\n      taint_assume_safe_booleans: true\n      taint_assume_safe_numbers: true\n      interfile: true\n    pattern-sources:\n      - pattern: |\n          (UserInputGenerator $X).getUserInput(...)\n    pattern-sinks:\n      - pattern: |\n          (SQLQueryRunner $X).run(...)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:'public class Test {\n  // Run with `javac Test.java && java Test`\n  public static void main(String[] args) {\n    SQLQueryRunner runner = new SQLQueryRunner();\n    String input = new UserInputGenerator().getUserInput();\n\n    // safe\n    runner.run("SELECT * from table");\n\n    //ruleid:sqli-demo-bool_dont_taint\n    //highlight-next-line\n    runner.run("SELECT * from " + input);\n\n    //ok:sqli-demo-bool_dont_taint\n\u2606   runner.run("SELECT * from table" + input.endsWith("something"));\n\n    //ok:sqli-demo-bool_dont_taint\n\u2606   runner.run("SELECT * from table" + input.indexOf(\'u\'));\n\n    //ruleid:sqli-demo-bool_dont_taint\n    //highlight-next-line\n    runner.run("SELECT * from " + input.substring(0));\n  }\n}\n\nclass UserInputGenerator {\n  public String getUserInput() {\n    return "fake user input";\n  }\n}\n\nclass SQLQueryRunner {\n  public void run(String query) {\n    System.out.println("Would have run query:");\n    System.out.println(query);\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure"}),". ",(0,i.jsx)(n.code,{children:"sqli-demo-bool_doesnt_taint"}),". ",(0,i.jsxs)(n.a,{href:"https://semgrep.dev/playground/s/Kx1AY",children:[(0,i.jsx)("i",{class:"fas fa-external-link fa-xs"})," Open in interactive Playground"]}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This example has two true positives: ",(0,i.jsx)(n.strong,{children:"line 11"})," and ",(0,i.jsx)(n.strong,{children:"line 20"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep Pro is able to detect that ",(0,i.jsx)(n.strong,{children:"line 14 and 17 are false positives"}),". Semgrep CE can't catch that distinction.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Lines 14 and 17 are false positives because ",(0,i.jsx)(n.code,{children:'input.endsWith("something")'})," and ",(0,i.jsx)(n.code,{children:"input.indexOf('u')"})," return a Boolean and integer respectively. Semgrep Pro is able to understand ",(0,i.jsx)(n.code,{children:"endsWith"})," and ",(0,i.jsx)(n.code,{children:"indexOf"})," Java methods."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The Semgrep rule uses the fields ",(0,i.jsx)(n.code,{children:"taint_assume_safe_booleans"})," and ",(0,i.jsx)(n.code,{children:"taint_assume_safe_numbers"})," to tell the engine that these types are safe and not tainted."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"semgrep-targets-code-in-a-parent-class-and-its-subclasses",children:"Semgrep targets code in a parent class and its subclasses"}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep supports class inheritance in Java. You can use Semgrep to search across all subclasses. This specificity means that rules can better target your codebase, increasing true positive rates. This is achieved through the ",(0,i.jsx)(n.code,{children:"metavariable-type"})," field, which can accept the name of any user-defined class."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-type"})," field is available in Semgrep CE. However, classes in Java are frequently defined across files (interfile), which is beyond the scope of Semgrep CE's analysis. Use Semgrep Pro to perform cross-file analysis to ensure that Semgrep can detect all class and subclass definitions."]}),"\n",(0,i.jsxs)(n.h3,{id:"example-detect-pattern-in-subclass",children:["Example: ",(0,i.jsx)(n.code,{children:"detect-pattern-in-subclass"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:"# Semgrep rule\nrules:\n  - id: detect-pattern-in-subclass\n    languages:\n      - java\n    message: Test\n    options:\n      interfile: true\n    patterns:\n      - pattern: $CLASS.x\n      - metavariable-type:\n          metavariable: $CLASS\n          type: Foo\n    severity: WARNING\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:"class Foo { String x; }\n\nclass Bar extends Foo {}\n\nclass Baz { String x; }\n\nclass Test {\n    void test() {\n        Bar bar = new Bar();\n        //ruleid:detect-pattern-in-subclass\n        //highlight-next-line\n        return bar.x;\n    }\n}\n\nclass Test2 {\n    void test() {\n        Baz baz = new Baz();\n\u2606       return baz.x;\n    }\n}\n\nclass Test3 {\n    void test() {\n        Foo foo = new Foo();\n        //ruleid:detect-pattern-in-subclass\n        //highlight-next-line\n        return foo.x;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure"}),". ",(0,i.jsx)(n.code,{children:"detect-pattern-in-subclass"}),". ",(0,i.jsxs)(n.a,{href:"https://semgrep.dev/playground/s/nJjjG",children:[(0,i.jsx)("i",{class:"fas fa-external-link fa-xs"})," Open in  interactive Playground"]}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This demo rule detects patterns in instances of the user-defined parent class ",(0,i.jsx)(n.code,{children:"Foo"})," and its subclasses."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This example has two true positives: ",(0,i.jsx)(n.strong,{children:"line 10"})," and ",(0,i.jsx)(n.strong,{children:"line 24"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"patterns"})," array initially defines a ",(0,i.jsx)(n.code,{children:"pattern: $CLASS.x"}),".","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Line 17"}),", ",(0,i.jsx)(n.code,{children:"baz.x"})," fulfills this pattern."]}),"\n",(0,i.jsxs)(n.li,{children:["However, the ",(0,i.jsx)(n.code,{children:"metavariable-type"})," specifies a ",(0,i.jsx)(n.code,{children:"type"})," of ",(0,i.jsx)(n.code,{children:"Foo"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["This specification narrows the match to ",(0,i.jsx)(n.strong,{children:"line 10"})," because ",(0,i.jsx)(n.code,{children:"Bar"})," is a subclass of ",(0,i.jsx)(n.code,{children:"Foo"}),", and ",(0,i.jsx)(n.strong,{children:"line 25"}),", which is an instance of the ",(0,i.jsx)(n.code,{children:"Foo"})," object itself."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"semgrep-supports-field-and-index-sensitivity",children:"Semgrep supports field and index sensitivity"}),"\n",(0,i.jsxs)(n.p,{children:["Field sensitivity means that Semgrep can track taint for each field of an object independently. Given an object ",(0,i.jsx)(n.code,{children:"C"})," with properties ",(0,i.jsx)(n.code,{children:"C.x"})," and ",(0,i.jsx)(n.code,{children:"C.y"}),", if ",(0,i.jsx)(n.code,{children:"C.x"})," is tainted, then Semgrep does ",(0,i.jsx)(n.strong,{children:"not"})," automatically mark ",(0,i.jsx)(n.code,{children:"C.y"})," as tainted."]}),"\n",(0,i.jsx)(n.p,{children:"Similarly, index sensitivity means that Semgrep can track taint for each element of an array independently."}),"\n",(0,i.jsxs)(n.h3,{id:"example-unsafe-sql-concatenation-in-method-taint-field-sensitivity",children:["Example: ",(0,i.jsx)(n.code,{children:"unsafe-sql-concatenation-in-method-taint-field-sensitivity"})]}),"\n",(0,i.jsxs)(n.p,{children:["This demo rule detects that ",(0,i.jsx)(n.code,{children:"C.x"})," is tainted by way of the ",(0,i.jsx)(n.code,{children:"injection"})," variable. It is able to differentiate ",(0,i.jsx)(n.code,{children:"C.y"})," as untainted."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:"# Semgrep rule\nrules:\n  - id: unsafe-sql-concatenation-in-method-taint-field-sensitivity\n    languages:\n      - java\n    severity: WARNING\n    metadata:\n      interfile: true\n    mode: taint\n    message: Test\n    options:\n      taint_assume_safe_booleans: true\n      taint_assume_safe_numbers: true\n      interfile: true\n    pattern-sources:\n      - patterns:\n          - pattern: |\n              $X(..., $SRC, ...) { ... }\n          - focus-metavariable: $SRC\n    pattern-sinks:\n      - patterns:\n          - pattern-either:\n              - pattern: com.netsuite.database.SqlLogger.execute(..., $SINK)\n              - pattern: com.netsuite.database.Util.execute(..., $SINK)\n    pattern-sanitizers:\n      - pattern: com.netsuite.database.Util.generateSubSqlForBinding(...)\n      - pattern: com.netsuite.database.Util.generateSubSql(...)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Java",metastring:"showLineNumbers",children:'import com.netsuite.database.SqlLogger;\nimport com.netsuite.database.Util;\nimport com.netsuite.database.SqlBuilder;\n\nimport java.sql.SQLException;\n\nclass C {\n  String x;\n  String y;\n\n  C(String x, String y) {\n    this.x = x;\n    this y = y;\n  }\n}\n\nclass Test {\n    private void LoggerTruePositives(String injection) {\n        String stm = "This should not be a String. It is just to simplify the testing process";\n\n        C c = new C(injection, "safe");\n\n        //ruleid:unsafe-sql-concatenation-in-method-taint-field-sensitivity\n        //highlight-next-line\n        String tp1_1 = SqlLogger.execute(stm,"SELECT c1, c2 from tablename where c1 = " + c.getX());\n\n        //ok:unsafe-sql-concatenation-in-method-taint-field-sensitivity\n\u2606       String tp1_2 = SqlLogger.execute(stm,"SELECT c1, c2 from tablename where c1 = " + c.getY());\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure"}),". ",(0,i.jsx)(n.code,{children:"unsafe-sql-concatenation-in-method-taint-field-sensitivity"}),". ",(0,i.jsxs)(n.a,{href:"https://semgrep.dev/playground/s/OrAwe",children:[(0,i.jsx)("i",{class:"fas fa-external-link fa-xs"})," Open in interactive Playground"]}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This example has one true positive on ",(0,i.jsx)(n.strong,{children:"line 24"})," and one true negative on ",(0,i.jsx)(n.strong,{children:"line 27"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Line 17"})," of the rule tells Semgrep to match for the following pattern:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"pattern: |\n  $X(..., $SRC, ...) { ... }\n  focus-metavariable: $SRC\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This matches ",(0,i.jsx)(n.code,{children:"private void LoggerTruePositives(String injection)"}),", specifically the ",(0,i.jsx)(n.code,{children:"injection"})," variable in the sample code."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The value of the injection variable is passed to ",(0,i.jsx)(n.code,{children:"C.x"}),", thus, ",(0,i.jsx)(n.code,{children:"C.x"})," is tainted, but ",(0,i.jsx)(n.code,{children:"C.y"})," is not."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);