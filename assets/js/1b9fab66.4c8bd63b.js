"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[31930],{10064:(e,n,s)=>{s.d(n,{Ay:()=>c,RM:()=>a});var t=s(74848),i=s(28453);const a=[];function r(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The following command runs an optimized set of rules for your project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"semgrep --config p/default\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},19610:(e,n,s)=>{s.d(n,{Ay:()=>c,RM:()=>a});var t=s(74848),i=s(28453);const a=[];function r(e){const n={p:"p",...(0,i.R)(),...e.components};return(0,t.jsx)(n.p,{children:"This is a command injection prevention cheat sheet by Semgrep, Inc. It contains code patterns of potential ways to run an OS command in an application. Instead of scrutinizing code for exploitable vulnerabilities, the recommendations in this cheat sheet pave a safe road for developers that mitigate the possibility of command injection in your code. By following these recommendations, you can be reasonably sure your code is free of command injection."})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},21250:(e,n,s)=>{s.d(n,{A:()=>i});s(96540);var t=s(74848);function i(e){let{ruleId:n}=e;const s=new URL("https://semgrep.dev/r");return s.searchParams.set("q",n),(0,t.jsx)("a",{href:s,target:"_blank",children:n})}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},86604:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>d,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"cheat-sheets/javascript-command-injection","title":"Command injection prevention for JavaScript","description":"JavaScript code injection prevention cheat sheet.","source":"@site/docs/cheat-sheets/javascript-command-injection.mdx","sourceDirName":"cheat-sheets","slug":"/cheat-sheets/javascript-command-injection","permalink":"/docs/cheat-sheets/javascript-command-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/cheat-sheets/javascript-command-injection.mdx","tags":[],"version":"current","lastUpdatedAt":1752253235000,"frontMatter":{"slug":"javascript-command-injection","description":"JavaScript code injection prevention cheat sheet."},"sidebar":"cheatsheetSidebar","previous":{"title":"Command injection prevention for Java","permalink":"/docs/cheat-sheets/java-command-injection"},"next":{"title":"Command injection prevention for Python","permalink":"/docs/cheat-sheets/python-command-injection"}}');var i=s(74848),a=s(28453),r=s(21250),c=s(19610),o=s(10064);const l={slug:"javascript-command-injection",description:"JavaScript code injection prevention cheat sheet."},d="Command injection prevention for JavaScript",p={},u=[...c.RM,{value:"Check your project using Semgrep",id:"check-your-project-using-semgrep",level:3},...o.RM,{value:"1. Running an OS command",id:"1-running-an-os-command",level:2},{value:"1.A. Spawning a shell with exec function",id:"1a-spawning-a-shell-with-exec-function",level:3},{value:"References",id:"references",level:4},{value:"Mitigation",id:"mitigation",level:4},{value:"Semgrep rule",id:"semgrep-rule",level:4},{value:"1.B. Spawning a process with spawn function",id:"1b-spawning-a-process-with-spawn-function",level:3},{value:"References",id:"references-1",level:4},{value:"Mitigation",id:"mitigation-1",level:4},{value:"Semgrep rule",id:"semgrep-rule-1",level:4}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"command-injection-prevention-for-javascript",children:"Command injection prevention for JavaScript"})}),"\n",(0,i.jsx)(c.Ay,{}),"\n",(0,i.jsx)(n.h3,{id:"check-your-project-using-semgrep",children:"Check your project using Semgrep"}),"\n",(0,i.jsx)(o.Ay,{}),"\n",(0,i.jsx)(n.h2,{id:"1-running-an-os-command",children:"1. Running an OS command"}),"\n",(0,i.jsx)(n.h3,{id:"1a-spawning-a-shell-with-exec-function",children:"1.A. Spawning a shell with exec function"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"exec()"})," function executes shell commands. It spawns a shell and then executes the command within the spawned shell, buffering any generated output. Never pass unsanitized user input to this function. Any input containing shell metacharacters can be used to trigger the execution of arbitrary commands."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const {exec} = require('child_process')\n\nconst userInput = \"$(dangerous command)\" // Value supplied by user input\n\n// Vunerable\nexec(`cat *.js ${userInput}`, (error, stdout, stderr) => {\n  console.log(stdout)\n})\n"})}),"\n",(0,i.jsx)(n.h4,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.a,{href:"https://nodejs.org/dist/latest-v14.x/docs/api/child_process.html",children:[(0,i.jsx)(n.code,{children:"child_process"})," module documentation"]})}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mitigation",children:"Mitigation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always try to use internal JavaScript APIs (if they exist) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be manipulated by a malicious actor."}),"\n",(0,i.jsx)(n.li,{children:"Don\u2019t pass user-controlled input or use an allowlist for inputs."}),"\n",(0,i.jsx)(n.li,{children:"If it is not possible, use an array with a sequence of program arguments instead of a single string."}),"\n",(0,i.jsx)(n.li,{children:"Avoid non-literal values for the command string. Strip everything except alphanumeric characters from an input provided for the command string and arguments."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"semgrep-rule",children:"Semgrep rule"}),"\n",(0,i.jsx)(r.A,{ruleId:"javascript.lang.security.detect-child-process.detect-child-process"}),"\n",(0,i.jsx)(n.h3,{id:"1b-spawning-a-process-with-spawn-function",children:"1.B. Spawning a process with spawn function"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"spawn()"})," and ",(0,i.jsx)(n.code,{children:"spawnSync()"})," functions spawn a new process using the command with a list of arguments. This allows spawning any programs or running shell processes with arbitrary arguments, which can result in a command injection vulnerability."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const {spawn} = require('child_process')\n\n// Not vulnerable\nconst userInput = '' // value supplied by user input\nspawn('cat', ['*.js', userInput])\n\n// Vulnerable\nconst userInput = 'pwn-command' // value supplied by user input\nspawn(userInput, ['-a', '-b'])\n\n// Vulnerable\nconst userInput = 'echo 1 | cat /etc/passwd' // value supplied by user input\nspawn(\"sh\", [\"-c\", userInput])\n"})}),"\n",(0,i.jsx)(n.h4,{id:"references-1",children:"References"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.a,{href:"https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html",children:[(0,i.jsx)(n.code,{children:"child_process"})," module documentation"]})}),"\n",(0,i.jsx)(n.h4,{id:"mitigation-1",children:"Mitigation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always try to use internal JavaScript APIs (if they exist) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be manipulated by a malicious actor."}),"\n",(0,i.jsx)(n.li,{children:"Don\u2019t pass user-controlled input or use an allowlist for inputs."}),"\n",(0,i.jsxs)(n.li,{children:["Do not include command arguments in a command string, use parameterization instead. For example:",(0,i.jsx)("br",{}),"\nUse:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'spawn("/path/to/myCommand", ["myArg1", inputValue])\n'})}),"\n","Instead of:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'spawn("bash", ["-c", "myCommand myArg1 " + inputValue])\n'})}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Define a list of allowed arguments."}),"\n",(0,i.jsx)(n.li,{children:"Avoid non-literal values for the command string. Strip everything except alphanumeric characters from an input provided for the command string and arguments."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"semgrep-rule-1",children:"Semgrep rule"}),"\n",(0,i.jsx)(r.A,{ruleId:"javascript.lang.security.detect-child-process.detect-child-process"})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);