"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[12878],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(96540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},95093:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"writing-rules/experiments/metavariable-type","title":"Match captured metavariables with specific types","description":"With this experimental field, Semgrep matches captured metavariables with specific types","source":"@site/docs/writing-rules/experiments/metavariable-type.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/metavariable-type","permalink":"/semgrep-docs/writing-rules/experiments/metavariable-type","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/experiments/metavariable-type.md","tags":[],"version":"current","lastUpdatedAt":1752262761000,"frontMatter":{"slug":"metavariable-type","append_help_link":true,"description":"With this experimental field, Semgrep matches captured metavariables with specific types"},"sidebar":"rulewritingSidebar","previous":{"title":"Symbolic propagation","permalink":"/semgrep-docs/writing-rules/experiments/symbolic-propagation"},"next":{"title":"Deprecated experiments","permalink":"/semgrep-docs/writing-rules/experiments/deprecated-experiments"}}');var r=n(74848),a=n(28453);const s={slug:"metavariable-type",append_help_link:!0,description:"With this experimental field, Semgrep matches captured metavariables with specific types"},l="Match captured metavariables with specific types",o={},p=[{value:"Supported languages",id:"supported-languages",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"match-captured-metavariables-with-specific-types",children:"Match captured metavariables with specific types"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"metavariable-type"})," operator is used to compare metavariables against their types. It utilizes the ",(0,r.jsx)(t.code,{children:"type"})," key to specify the string representation of the type expression in the target language. For example, you can use ",(0,r.jsx)(t.code,{children:"String"})," for Java's String type and ",(0,r.jsx)(t.code,{children:"string"})," for Go's string type. Optionally, the ",(0,r.jsx)(t.code,{children:"language"})," key can be used to manually indicate the target language of the type expression."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"metavariable-type"})," provides several advantages over typed metavariables. Firstly, it removes the requirement for users to memorize special syntax for defining typed metavariables in various target languages. Moreover, ",(0,r.jsx)(t.code,{children:"metavariable-type"})," enables users to extract type expressions from the pattern expression and include them in other conditional filters for metavariables. This improves the readability of rules and promotes better organization of the code."]}),"\n",(0,r.jsx)(t.p,{children:"For instance, the following rule that identifies potentially unsafe usage of the referential equality operator when comparing String objects in Java:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"rules:\n  - id: no-string-eqeq\n    severity: WARNING\n    message: Avoid using the referential equality operator when comparing String objects\n    languages:\n      - java\n    patterns:\n      - pattern-not: null == (String $Y)\n      - pattern: $X == (String $Y)\n"})}),"\n",(0,r.jsx)(t.p,{children:"can be modified to the following rule:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"rules:\n  - id: no-string-eqeq\n    severity: WARNING\n    message: Avoid using the referential equality operator when comparing String objects\n    languages:\n      - java\n    patterns:\n      - pattern-not: null == $Y\n      - pattern: $X == $Y\n      - metavariable-type:\n          metavariable: $Y\n          type: String\n"})}),"\n",(0,r.jsx)(t.h2,{id:"supported-languages",children:"Supported languages"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"metavariable-type"})," operator can be used for the following languages:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"C"}),"\n",(0,r.jsx)(t.li,{children:"C#"}),"\n",(0,r.jsx)(t.li,{children:"C++"}),"\n",(0,r.jsx)(t.li,{children:"Go"}),"\n",(0,r.jsx)(t.li,{children:"Java"}),"\n",(0,r.jsx)(t.li,{children:"Julia"}),"\n",(0,r.jsx)(t.li,{children:"Kotlin"}),"\n",(0,r.jsx)(t.li,{children:"Move On Aptos"}),"\n",(0,r.jsx)(t.li,{children:"Move On Sui"}),"\n",(0,r.jsx)(t.li,{children:"PHP"}),"\n",(0,r.jsx)(t.li,{children:"Python"}),"\n",(0,r.jsx)(t.li,{children:"Rust"}),"\n",(0,r.jsx)(t.li,{children:"Scala"}),"\n",(0,r.jsx)(t.li,{children:"TypeScript"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);