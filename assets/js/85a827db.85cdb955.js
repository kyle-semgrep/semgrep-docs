"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[77398],{3418:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/release-notes-march2023-cli-output-old-394de6eb67ce50da90340e6a1cb9ee50.png"},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>d});var i=s(96540);const a={},r=i.createContext(a);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},50451:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/release-notes-march2023-cli-output-new-7c36d723713940843c69e5cca9045402.png"},67346:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/release-notes-semgrep-code-findings-pro-rule-gem-cf8a3b2a7f4d601a5f0fc9c545d32315.png"},89595:e=>{e.exports=JSON.parse('{"permalink":"/docs/release-notes/march-2023","source":"@site/release-notes/march-2023.md","title":"March 2023","description":"Release notes include the changes, fixes, and additions in specific versions of Semgrep.","date":"2023-03-30T10:00:00.000Z","tags":[{"inline":true,"label":"Release notes","permalink":"/docs/release-notes/tags/release-notes"}],"readingTime":6.42,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"march-2023","append_help_link":true,"hide_title":true,"description":"Release notes include the changes, fixes, and additions in specific versions of Semgrep.","toc_max_heading_level":3,"tags":["Release notes"],"hide_table_of_contents":false,"date":"2023-03-30T10:00","title":"March 2023"},"unlisted":false,"prevItem":{"title":"April 2023","permalink":"/docs/release-notes/april-2023"},"nextItem":{"title":"February 2023","permalink":"/docs/release-notes/february-2023"}}')},93202:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});var i=s(89595),a=s(74848),r=s(28453);const t={slug:"march-2023",append_help_link:!0,hide_title:!0,description:"Release notes include the changes, fixes, and additions in specific versions of Semgrep.",toc_max_heading_level:3,tags:["Release notes"],hide_table_of_contents:!1,date:"2023-03-30T10:00",title:"March 2023"},d="March 2023",l={authorsImageUrls:[]},o=[{value:"Semgrep OSS Engine",id:"semgrep-oss-engine",level:2},{value:"Added",id:"added",level:3},{value:"Changed",id:"changed",level:3},{value:"Semgrep Code",id:"semgrep-code",level:2},{value:"Added",id:"added-1",level:3},{value:"Semgrep Pro Engine",id:"semgrep-pro-engine",level:2},{value:"Added",id:"added-2",level:3},{value:"Changed",id:"changed-1",level:3},{value:"Semgrep Cloud Platform",id:"semgrep-cloud-platform",level:2},{value:"Added",id:"added-3",level:3},{value:"Semgrep Supply Chain",id:"semgrep-supply-chain",level:2},{value:"Added",id:"added-4",level:3},{value:"Changed",id:"changed-2",level:3},{value:"Documentation",id:"documentation",level:2},{value:"Added",id:"added-5",level:3},{value:"Changed",id:"changed-3",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"The following updates were made to Semgrep in March 2023."}),"\n",(0,a.jsx)(n.h2,{id:"semgrep-oss-engine",children:"Semgrep OSS Engine"}),"\n",(0,a.jsx)(n.p,{children:"This section of release notes include upgrades of Semgrep OSS Engine for versions ranging between 1.14.0 and 1.16.0."}),"\n",(0,a.jsx)(n.h3,{id:"added",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Kotlin: Semgrep OSS Engine now supports typed metavariables in Kotlin. For example, to find all instances of a string type, you can now use the following rule pattern:\n",(0,a.jsx)(n.code,{children:"($X : String)"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Scala: Semgrep can now parse programs that contain quoted expressions, context parameter clauses that use the ",(0,a.jsx)(n.code,{children:"using"})," function, and soft modifiers like ",(0,a.jsx)(n.code,{children:"inline"})," and ",(0,a.jsx)(n.code,{children:"open"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Semgrep can now parse and analyze Scala code that contains matches on types, such as:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"type t = K match {\n  case Int => String\n}\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["metavariable-comparison: Added support for bitwise operators ",(0,a.jsx)(n.code,{children:"~"}),", ",(0,a.jsx)(n.code,{children:"&"}),", ",(0,a.jsx)(n.code,{children:"|"}),", and ",(0,a.jsx)(n.code,{children:"^"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["taint-mode: The latest update to ",(0,a.jsx)(n.code,{children:"pattern-propagators"})," in Semgrep OSS Engine introduces two optional fields ",(0,a.jsx)(n.code,{children:"requires"})," and ",(0,a.jsx)(n.code,{children:"label"}),", that work identically to their counterparts in ",(0,a.jsx)(n.code,{children:"pattern-sources"})," and  ",(0,a.jsx)(n.code,{children:"pattern-sinks"}),". These fields are part of the experimental taint labels feature for taint analysis."]}),"\n",(0,a.jsx)(n.p,{children:"For instance, we can define:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"pattern-propagators:\n  - pattern: |\n      $TO.foo($FROM)\n    from: $FROM\n    to: $TO\n    requires: A\n    replace-labels: [A, C]\n    label: B\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This propagator only propagates if the source ",(0,a.jsx)(n.code,{children:"$FROM"})," has taint label ",(0,a.jsx)(n.code,{children:"A"}),". Additionally, any taints from ",(0,a.jsx)(n.code,{children:"$TO"})," with labels ",(0,a.jsx)(n.code,{children:"A"})," or ",(0,a.jsx)(n.code,{children:"C"})," are converted to have label ",(0,a.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If you don't specify a ",(0,a.jsx)(n.code,{children:"label"}),", the target ",(0,a.jsx)(n.code,{children:"$TO"})," is tainted with the same label as the taint on ",(0,a.jsx)(n.code,{children:"$FROM"}),". If you don't specify a ",(0,a.jsx)(n.code,{children:"requires"})," field, the propagator does not require the source to have a specific taint label."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that the ",(0,a.jsx)(n.code,{children:"replace-labels"})," field only restricts the label being propagated if you also specify the ",(0,a.jsx)(n.code,{children:"label"})," output."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"changed",children:"Changed"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Semgrep\u2019s CLI output has been revamped to better organize scan information and provide more context about scans and findings. Previously, CLI output was minimal without much formatting. With this release, Semgrep CLI now provides headers, tables, scan summaries, and updated, granular data about individual findings and the project it is scanning."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"release-notes-march2023-cli-output-old.png",src:s(3418).A+"",width:"3430",height:"946"}),"\n",(0,a.jsx)(n.em,{children:"Figure 1. Old Semgrep CLI output."})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"release-notes-march2023-cli-output-new.png",src:s(50451).A+"",width:"2452",height:"1832"}),"\n",(0,a.jsx)(n.em,{children:"Figure 2. New Semgrep CLI output."})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The latest update to",(0,a.jsx)(n.code,{children:"semgrep/semgrep"})," Docker images removes the custom entry point that was previously used to invoke Semgrep. As a result, you must now explicitly call ",(0,a.jsx)(n.code,{children:"semgrep"})," when running the image. This change was already made approximately a year ago. In this update, the backward compatibility layer and a deprecation notice have been removed."]}),"\n",(0,a.jsxs)(n.p,{children:["Previously, you could scan your code using the ",(0,a.jsx)(n.code,{children:"semgrep/semgrep"})," image by running the following command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker run -v $(pwd):/src semgrep/semgrep scan ...\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, this command no longer works. Instead, you must use the following command to achieve the same result:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker run -v $(pwd):/src semgrep/semgrep semgrep scan ...\n"})}),"\n",(0,a.jsx)(n.p,{children:"By removing the custom entry point, this update provides greater flexibility and consistency in how Semgrep is invoked within Docker containers."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["taint-mode: Previously, Semgrep OSS Engine taint analysis sometimes flagged sinks that did not propagate taint. For example, the ",(0,a.jsx)(n.code,{children:"sink(ok if tainted else ok)"})," was flagged. To address this, we've made taint analysis more precise. Now, sinks like ",(0,a.jsx)(n.code,{children:"sink(...)"})," where you declare that any argument of a given function is a sink. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"pattern-sinks:\n  - patterns:\n      - pattern: sink($X, ...)\n      - focus-metavariable: $X\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As a result, ",(0,a.jsx)(n.code,{children:"sink(ok1 if tainted else ok2)"}),", ",(0,a.jsx)(n.code,{children:"sink(not_a_propagator(tainted))"}),", and\n",(0,a.jsx)(n.code,{children:"sink(some_array[tainted])"}),", are not be reported as findings."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"-gitlab-sast"})," and ",(0,a.jsx)(n.code,{children:"-gitlab-secrets"})," output formats have been upgraded. The output is now valid with the GitLab v15 schema, while staying valid with the GitLab v14 schema as well. Code findings now include the confidence of the rule."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"semgrep-code",children:"Semgrep Code"}),"\n",(0,a.jsx)(n.h3,{id:"added-1",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pro Engine beta"})," toggle is enabled by default in the ",(0,a.jsx)(n.a,{href:"https://semgrep.dev/orgs/-/editor/",children:"Semgrep Editor"})," and ",(0,a.jsx)(n.a,{href:"https://semgrep.dev/playground",children:"Semgrep Playground"}),". Rules can still run with the Semgrep OSS Engine if\xa0",(0,a.jsx)(n.code,{children:"interfile: true"})," is not specified in the rule."]}),"\n",(0,a.jsxs)(n.li,{children:["Findings from Pro rules or Semgrep Pro Engine are now labeled with a gem icon to let you know where the finding has come from.\n",(0,a.jsx)(n.img,{alt:"semgrep-code-findings-pro-rule-gem.png",src:s(67346).A+"",width:"1098",height:"302"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"semgrep-pro-engine",children:"Semgrep Pro Engine"}),"\n",(0,a.jsx)(n.h3,{id:"added-2",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Previously, when installing Semgrep Pro Engine, Semgrep CLI downloaded the most recently released version of Semgrep Pro Engine. As a consequence, this version of Semgrep Pro Engine might not have been the most compatible version with Semgrep OSS Engine. With this update, the most compatible version of Semgrep Pro Engine with Semgrep OSS Engine is downloaded during the installation."}),"\n",(0,a.jsx)(n.p,{children:"This behavior is only supported for Semgrep version 1.12.1 and later. Previous versions still download the most recently released version, as before."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["taint-mode: Semgrep Pro Engine\u2019s taint analysis capabilities for Java now include support for basic field sensitivity through getters and setters. If you call ",(0,a.jsx)(n.code,{children:"obj.setX(tainted)"}),", Semgrep can now identify that a subsequent call to ",(0,a.jsx)(n.code,{children:"obj.getX()"})," will carry the same taint as ",(0,a.jsx)(n.code,{children:"tainted"}),". Moreover, Semgrep can differentiate between different fields accessed by the getters and setters, such as ",(0,a.jsx)(n.code,{children:"obj.getX()"})," and ",(0,a.jsx)(n.code,{children:"obj.getY()"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["It's important to note that Semgrep Pro Engine doesn't examine the definitions of the getter and setter methods, and it doesn't know whether other methods like ",(0,a.jsx)(n.code,{children:"obj.clearX()"})," clear the taint that ",(0,a.jsx)(n.code,{children:"obj.setX(tainted)"})," adds. Nonetheless, this new feature enables Semgrep to detect vulnerabilities more accurately in tainted data flow in Java code."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"changed-1",children:"Changed"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"CI scans that use Semgrep Pro Engine now run intrafile and cross-function (interprocedural) taint analysis by default in differential scans (such as PR or MR scans). Note that cross-file (interfile) analysis is not run in differential scans for performance reasons."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"semgrep-cloud-platform",children:"Semgrep Cloud Platform"}),"\n",(0,a.jsx)(n.h3,{id:"added-3",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["For organizations with role-based access control (RBAC) enabled, members are now able to ",(0,a.jsx)(n.a,{href:"/deployment/teams#member-scoped-access-tokens",children:"log in through the CLI"})," and send findings data from their local machine to the Semgrep Cloud Platform."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"semgrep-supply-chain",children:"Semgrep Supply Chain"}),"\n",(0,a.jsx)(n.h3,{id:"added-4",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["You can now receive Semgrep Supply Chain notifications in your Slack channel. Be notified of ",(0,a.jsx)(n.strong,{children:"reachable vulnerabilities"})," as soon as a scan finishes. Sign in to Semgrep Cloud Platform and click Settings > Integrations > Add integration > Slack and follow the instructions to start setting up your Slack notifications."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"changed-2",children:"Changed"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Previously, Semgrep Supply Chain used ",(0,a.jsx)(n.code,{children:"go.sum"})," files to read Go dependencies. Semgrep Supply Chain now uses ",(0,a.jsx)(n.code,{children:"go.mod"})," files."]}),"\n",(0,a.jsxs)(n.li,{children:["Supply Chain findings now include the exposure type. Exposure types can be any of the following values:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Reachable \u2014 this type of exposure means that the finding has detected a vulnerable dependency ",(0,a.jsx)(n.strong,{children:"and"})," the vulnerable code is used in your codebase. Additionally, the ",(0,a.jsx)(n.strong,{children:"inclusion"})," of certain severely vulnerable packages such as ",(0,a.jsx)(n.code,{children:"log4j"})," is also categorized as a reachable exposure even without the vulnerable code\u2019s usage within your codebase."]}),"\n",(0,a.jsx)(n.li,{children:"Unreachable \u2014 this type of exposure means that the finding has detected a vulnerable dependency but the vulnerable code is not used in your codebase."}),"\n",(0,a.jsx)(n.li,{children:"Undetermined \u2014 Reachability analysis has not been performed on this finding, therefore its exposure is undetermined."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Historical rules (also known as parity rules) are now enabled by default for new personal and organizational accounts. Existing organizations can reach out to ",(0,a.jsx)(n.a,{href:"mailto:support@semgrep.com",children:"support@semgrep.com"})," to enable parity rules by default."]}),"\n",(0,a.jsxs)(n.li,{children:["Semgrep Supply Chain scans now understand ",(0,a.jsx)(n.code,{children:"maven_dep_tree.txt"})," files that are made of multiple smaller ",(0,a.jsx)(n.code,{children:"maven_dep_tree.txt"})," files concatenated with",(0,a.jsx)(n.code,{children:"cat"}),". To make use of this functionality, create a script or command using the ",(0,a.jsx)(n.code,{children:"cat"})," command as a step in your CI pipeline."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"documentation",children:"Documentation"}),"\n",(0,a.jsx)(n.h3,{id:"added-5",children:"Added"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Created a new section on ",(0,a.jsx)(n.a,{href:"/deployment/teams#member-scoped-access-tokens",children:"Member scoped access tokens"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"changed-3",children:"Changed"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Updated ",(0,a.jsx)(n.a,{href:"/semgrep-appsec-platform/tags",children:"Tagging projects"})," document."]}),"\n",(0,a.jsxs)(n.li,{children:["Expanded, clarified, and improved licensing information in ",(0,a.jsx)(n.a,{href:"/faq/overview#how-are-semgrep-and-its-rules-licensed",children:"FAQs"}),". See sections such as ",(0,a.jsx)(n.a,{href:"/faq/overview#im-a-security-professional-do-i-have-to-pay-for-semgrep",children:"I\u2019m a security professional. Do I have to pay for Semgrep?"})," or ",(0,a.jsx)(n.a,{href:"/faq/overview#can-i-ship-my-own-code-analysis-software-that-uses-semgrep-ce",children:"Can I ship my own code analysis software that uses Semgrep?"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Updated ",(0,a.jsx)(n.a,{href:"/writing-rules/private-rules",children:"Private rules"})," documentation. Added section about ",(0,a.jsx)(n.a,{href:"/writing-rules/private-rules/#creating-private-rules",children:"Creating private rules"})," and ",(0,a.jsx)(n.a,{href:"/writing-rules/private-rules/#deleting-private-rules",children:"Deleting private rules"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);