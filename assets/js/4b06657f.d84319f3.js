"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[78063],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var a=n(96540);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},69455:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"kb/rules/match-absence","title":"Match the absence of something in a file","description":"You can approximate this behavior by matching an entire file, but excluding the desired content from the match.","source":"@site/docs/kb/rules/match-absence.md","sourceDirName":"kb/rules","slug":"/kb/rules/match-absence","permalink":"/docs/kb/rules/match-absence","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/kb/rules/match-absence.md","tags":[{"inline":true,"label":"Rules","permalink":"/docs/tags/rules"},{"inline":true,"label":"Semgrep Registry","permalink":"/docs/tags/semgrep-registry"},{"inline":true,"label":"Semgrep Code","permalink":"/docs/tags/semgrep-code"}],"version":"current","lastUpdatedAt":1752253235000,"frontMatter":{"description":"You can approximate this behavior by matching an entire file, but excluding the desired content from the match.","tags":["Rules","Semgrep Registry","Semgrep Code"]},"sidebar":"kbSidebar","previous":{"title":"How to exclude certain file types for a particular rule","permalink":"/docs/kb/rules/exclude_rule_for_certain_filetypes"},"next":{"title":"Match comments with Semgrep","permalink":"/docs/kb/rules/match-comments"}}');var r=n(74848),s=n(28453);const i={description:"You can approximate this behavior by matching an entire file, but excluding the desired content from the match.",tags:["Rules","Semgrep Registry","Semgrep Code"]},c="Match the absence of something in a file",o={},l=[];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"match-the-absence-of-something-in-a-file",children:"Match the absence of something in a file"})}),"\n",(0,r.jsxs)(t.p,{children:["Currently, Semgrep does not have a clear way to match the absence of a pattern, rather than the presence of one. However, you can approximate this behavior by matching an entire file with ",(0,r.jsx)(t.code,{children:"pattern-regex"}),", and excluding a file that contains the desired content with ",(0,r.jsx)(t.code,{children:"pattern-not-regex"})," or other negative patterns."]}),"\n",(0,r.jsx)(t.p,{children:"Here is a simple example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yml",children:"rules:\n  - id: a\n    patterns:\n      - pattern-regex: |\n          (?s)(.*)\n      - pattern-not-regex: .*YOUR PATTERN TO BLOCK\n    message: match\n    languages:\n      - generic\n    severity: ERROR\n"})}),"\n",(0,r.jsx)(t.admonition,{title:"Example",type:"note",children:(0,r.jsxs)(t.p,{children:["Try this pattern in the ",(0,r.jsx)(t.a,{href:"https://semgrep.dev/playground/s/vop8",children:"Semgrep Playground"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["The regular expression pattern ",(0,r.jsx)(t.code,{children:"(?s)(.*)"})," uses the ",(0,r.jsx)(t.code,{children:"s"}),' flag to put the match in "single-line" mode, so that the dot character matches a newline. This allows ',(0,r.jsx)(t.code,{children:"(.*)"})," to match multiple lines, and therefore match an entire file."]}),"\n",(0,r.jsxs)(t.p,{children:["If the file contains ",(0,r.jsx)(t.code,{children:"YOUR PATTERN TO BLOCK"}),", then the match is negated and the file does not appear as a finding. If the file does not contain ",(0,r.jsx)(t.code,{children:"YOUR PATTERN TO BLOCK"}),", the file is flagged as a finding. With this rule, the finding spans the whole file, starting at line 1."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);