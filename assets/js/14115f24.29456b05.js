"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[72857],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},63189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"writing-rules/experiments/symbolic-propagation","title":"Symbolic propagation","description":"Symbolic propagation allows Semgrep to perform matching modulo variable assignments.","source":"@site/docs/writing-rules/experiments/symbolic-propagation.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/symbolic-propagation","permalink":"/semgrep-docs/writing-rules/experiments/symbolic-propagation","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/writing-rules/experiments/symbolic-propagation.md","tags":[],"version":"current","lastUpdatedAt":1752254305000,"frontMatter":{"slug":"symbolic-propagation","append_help_link":true,"description":"Symbolic propagation allows Semgrep to perform matching modulo variable assignments."},"sidebar":"rulewritingSidebar","previous":{"title":"r2c-internal-project-depends-on","permalink":"/semgrep-docs/writing-rules/experiments/r2c-internal-project-depends-on"},"next":{"title":"Match captured metavariables with specific types","permalink":"/semgrep-docs/writing-rules/experiments/metavariable-type"}}');var o=n(74848),a=n(28453);const s={slug:"symbolic-propagation",append_help_link:!0,description:"Symbolic propagation allows Semgrep to perform matching modulo variable assignments."},r="Symbolic propagation",d={},c=[{value:"Limitations of symbolic propagation",id:"limitations-of-symbolic-propagation",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"symbolic-propagation",children:"Symbolic propagation"})}),"\n",(0,o.jsx)(t.p,{children:"Symbolic propagation allows Semgrep to perform matching modulo variable assignments. Consider the following Python code:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"import pandas\n\ndef test1():\n    # ruleid: test\n    pandas.DataFrame(x).index.set_value(a, b, c)\n\ndef test2():\n    df = pandas.DataFrame(x)\n    ix = df.index\n    # ruleid: test\n    ix.set_value(a, b, c)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["If we tried to match the pattern ",(0,o.jsx)(t.code,{children:"pandas.DataFrame(...).index.set_value(...)"})," against the above code, Semgrep would normally match ",(0,o.jsx)(t.code,{children:"test1"})," but not ",(0,o.jsx)(t.code,{children:"test2"}),". It does not match ",(0,o.jsx)(t.code,{children:"test2"})," because there are intermediate assignments, and Semgrep does not know that ",(0,o.jsx)(t.code,{children:"ix"})," is equals to ",(0,o.jsx)(t.code,{children:"df.index"})," or that ",(0,o.jsx)(t.code,{children:"df"})," is equals to ",(0,o.jsx)(t.code,{children:"pandas.DataFrame(x)"}),". If we wanted Semgrep to match such code, we had to be explicit about it."]}),"\n",(0,o.jsxs)(t.p,{children:["Symbolic propagation is a generalization of ",(0,o.jsx)(t.a,{href:"/writing-rules/data-flow/constant-propagation",children:"constant propagation"})," that addresses this limitation. It enables Semgrep to perform matching modulo variable assignments. Thus, Semgrep is then able to match both ",(0,o.jsx)(t.code,{children:"test1"})," and ",(0,o.jsx)(t.code,{children:"test2"})," with the same simple pattern. This feature needs to be enabled explicitly via rule ",(0,o.jsx)(t.code,{children:"options:"})," by setting ",(0,o.jsx)(t.code,{children:"symbolic_propagation: true"}),"."]}),"\n",(0,o.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=JeBP",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,o.jsx)(t.h2,{id:"limitations-of-symbolic-propagation",children:"Limitations of symbolic propagation"}),"\n",(0,o.jsxs)(t.p,{children:["Currently, symbolic propagation does not cross branching boundaries, such as ",(0,o.jsx)(t.code,{children:"if"})," clauses or loops. Consider the following Python code, adapted from the example shown above:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"import pandas\n\ndef test1():\n    # ruleid: test\n    pandas.DataFrame(x).index.set_value(a, b, c)\n\ndef test2():\n    if (x < 5):\n        df = pandas.DataFrame(x)\n        pass\n    ix = df.index\n    # ruleid: test\n    ix.set_value(a, b, c)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this case, even if ",(0,o.jsx)(t.code,{children:"symbolic_propagation: true"})," is used, Semgrep does not match ",(0,o.jsx)(t.code,{children:"test2"}),", because the assignment of ",(0,o.jsx)(t.code,{children:"df"})," to ",(0,o.jsx)(t.code,{children:"pandas.DataFrame(x)"})," is not propagated over the conditional to the final two lines."]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);