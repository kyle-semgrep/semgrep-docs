"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[37353],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},59505:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"writing-rules/data-flow/taint-mode","title":"Taint analysis","description":"Taint mode allows you to write simple rules that catch complex injection bugs thanks to taint analysis.","source":"@site/docs/writing-rules/data-flow/taint-mode.md","sourceDirName":"writing-rules/data-flow","slug":"/writing-rules/data-flow/taint-mode","permalink":"/semgrep-docs/writing-rules/data-flow/taint-mode","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/data-flow/taint-mode.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752504841000,"frontMatter":{"slug":"taint-mode","append_help_link":true,"tags":["Rule writing"],"description":"Taint mode allows you to write simple rules that catch complex injection bugs thanks to taint analysis."},"sidebar":"rulewritingSidebar","previous":{"title":"Constant propagation","permalink":"/semgrep-docs/writing-rules/data-flow/constant-propagation"},"next":{"title":"Data-flow status","permalink":"/semgrep-docs/writing-rules/data-flow/status"}}');var i=n(74848),r=n(28453);const a={slug:"taint-mode",append_help_link:!0,tags:["Rule writing"],description:"Taint mode allows you to write simple rules that catch complex injection bugs thanks to taint analysis."},o="Taint analysis",d={},l=[{value:"Getting started",id:"getting-started",level:2},{value:"Sources",id:"sources",level:2},{value:"Exact sources",id:"exact-sources",level:3},{value:"Sources by side-effect",id:"sources-by-side-effect",level:3},{value:"Function arguments as sources",id:"function-arguments-as-sources",level:3},{value:"Control sources (Pro) \ud83e\uddea",id:"control-sources-pro-",level:3},{value:"Sanitizers",id:"sanitizers",level:2},{value:"Exact sanitizers",id:"exact-sanitizers",level:3},{value:"Sanitizers by side-effect",id:"sanitizers-by-side-effect",level:3},{value:"Sinks",id:"sinks",level:2},{value:"Non-exact sinks",id:"non-exact-sinks",level:3},{value:"Function arguments as sinks",id:"function-arguments-as-sinks",level:3},{value:"At-exit sinks (Pro) \ud83e\uddea",id:"at-exit-sinks-pro-",level:3},{value:"Propagators (Pro)",id:"propagators-pro",level:2},{value:"Understanding custom propagators",id:"understanding-custom-propagators",level:3},{value:"Propagation without side-effect",id:"propagation-without-side-effect",level:3},{value:"Findings",id:"findings",level:2},{value:"Deduplication of findings",id:"deduplication-of-findings",level:3},{value:"Report findings on the sources (Pro)",id:"report-findings-on-the-sources-pro",level:3},{value:"Minimizing false positives",id:"minimizing-false-positives",level:2},{value:"Restrict taint by type (Pro)",id:"restrict-taint-by-type-pro",level:3},{value:"Assume tainted indexes are safe",id:"assume-tainted-indexes-are-safe",level:3},{value:"Assume function calls are safe",id:"assume-function-calls-are-safe",level:3},{value:"Propagate only through assignments \ud83e\uddea",id:"propagate-only-through-assignments-",level:3},{value:"Metavariables, rule message, and unification",id:"metavariables-rule-message-and-unification",level:2},{value:"Inter-procedural analysis (Pro)",id:"inter-procedural-analysis-pro",level:2},{value:"Taint mode sensitivity",id:"taint-mode-sensitivity",level:2},{value:"Field sensitivity",id:"field-sensitivity",level:3},{value:"Index sensitivity (Pro)",id:"index-sensitivity-pro",level:3},{value:"Taint labels (Pro) \ud83e\uddea",id:"taint-labels-pro-",level:2},{value:"Multiple <code>requires</code> expressions in taint labels",id:"multiple-requires-expressions-in-taint-labels",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"taint-analysis",children:"Taint analysis"})}),"\n",(0,i.jsxs)(t.p,{children:["Semgrep supports ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Taint_checking",children:"taint analysis"})," (or taint tracking) through taint rules (specified by adding ",(0,i.jsx)(t.code,{children:"mode: taint"})," to your rule). Taint analysis is a data-flow analysis that tracks the flow of untrusted, or ",(0,i.jsx)(t.strong,{children:"tainted"})," data throughout the body of a function or method. Tainted data originate from tainted ",(0,i.jsx)(t.strong,{children:"sources"}),". If tainted data is not transformed or checked accordingly (",(0,i.jsx)(t.strong,{children:"sanitized"}),"), taint analysis reports a finding whenever tainted data reach a vulnerable function, called a ",(0,i.jsx)(t.strong,{children:"sink"}),". Tainted data flow from sources to sinks through ",(0,i.jsx)(t.strong,{children:"propagators"}),", such as assignments, or function calls."]}),"\n",(0,i.jsx)(t.p,{children:"The following video provides a quick overview of taint mode:"}),"\n",(0,i.jsx)("iframe",{class:"yt_embed",width:"100%",height:"432px",src:"https://www.youtube.com/embed/6MxMhFPkZlU",frameborder:"0",allowfullscreen:!0}),"\n",(0,i.jsx)(t.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,i.jsxs)(t.p,{children:["Taint tracking rules must specify ",(0,i.jsx)(t.code,{children:"mode: taint"}),", which enables the following operators:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pattern-sources"})," (required)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pattern-propagators"})," (optional)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pattern-sanitizers"})," (optional)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pattern-sinks"})," (required)"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["These operators (which act as ",(0,i.jsx)(t.code,{children:"pattern-either"})," operators) take a list of patterns that specify what is considered a source, a propagator, a sanitizer, or a sink. Note that you can use ",(0,i.jsx)(t.strong,{children:"any"})," pattern operator and you have the same expressive power as in a ",(0,i.jsx)(t.code,{children:"mode: search"})," rule."]}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=xG6g",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["Here Semgrep tracks the data returned by ",(0,i.jsx)(t.code,{children:"get_user_input()"}),", which is the source of taint. Think of Semgrep running the pattern ",(0,i.jsx)(t.code,{children:"get_user_input(...)"})," on your code, finding all places where ",(0,i.jsx)(t.code,{children:"get_user_input"})," gets called, and labeling them as tainted. That is exactly what is happening under the hood!"]}),"\n",(0,i.jsxs)(t.p,{children:["The rule specifies the sanitizer ",(0,i.jsx)(t.code,{children:"sanitize_input(...)"}),", so any expression that matches that pattern is considered sanitized. In particular, the expression ",(0,i.jsx)(t.code,{children:"sanitize_input(data)"})," is labeled as sanitized. Even if ",(0,i.jsx)(t.code,{children:"data"})," is tainted, as it occurs inside a piece of sanitized code, it does not produce any findings."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the rule specifies that anything matching either ",(0,i.jsx)(t.code,{children:"html_output(...)"})," or ",(0,i.jsx)(t.code,{children:"eval(...)"})," should be regarded as a sink. There are two calls ",(0,i.jsx)(t.code,{children:"html_output(data)"})," that are both labeled as sinks. The first one in ",(0,i.jsx)(t.code,{children:"route1"})," is not reported because ",(0,i.jsx)(t.code,{children:"data"})," is sanitized before reaching the sink, whereas the second one in ",(0,i.jsx)(t.code,{children:"route2"})," is reported because the ",(0,i.jsx)(t.code,{children:"data"})," that reaches the sink is still tainted."]}),"\n",(0,i.jsxs)(t.p,{children:["You can find more examples of taint rules in the ",(0,i.jsx)(t.a,{href:"https://semgrep.dev/r?owasp=injection%2Cxss",children:"Semgrep Registry"}),", for instance: ",(0,i.jsx)(t.a,{href:"https://semgrep.dev/editor?registry=javascript.express.security.express-sandbox-injection.express-sandbox-code-injection",children:"express-sandbox-code-injection"}),"."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/writing-rules/pattern-syntax#metavariables",children:"Metavariables"})," used in ",(0,i.jsx)(t.code,{children:"pattern-sources"})," are considered ",(0,i.jsx)(t.em,{children:"different"})," from those used in ",(0,i.jsx)(t.code,{children:"pattern-sinks"}),", even if they have the same name! See ",(0,i.jsx)(t.a,{href:"#metavariables-rule-message-and-unification",children:"Metavariables, rule message, and unification"})," for further details."]})}),"\n",(0,i.jsx)(t.h2,{id:"sources",children:"Sources"}),"\n",(0,i.jsxs)(t.p,{children:["A taint source is specified by a pattern. Like in a search-mode rule, you can start this pattern with one of the following keys: ",(0,i.jsx)(t.code,{children:"pattern"}),", ",(0,i.jsx)(t.code,{children:"patterns"}),", ",(0,i.jsx)(t.code,{children:"pattern-either"}),", ",(0,i.jsx)(t.code,{children:"pattern-regex"}),". Note that ",(0,i.jsx)(t.strong,{children:"any"})," subexpression that is matched by this pattern will be regarded as a source of taint."]}),"\n",(0,i.jsx)(t.p,{children:"In addition, taint sources accept the following options:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"exact"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#exact-sources",children:(0,i.jsx)(t.em,{children:"Exact sources"})}),"."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"by-side-effect"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"only"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#sources-by-side-effect",children:(0,i.jsx)(t.em,{children:"Sources by side-effect"})}),"."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.code,{children:"control"})," (Pro) \ud83e\uddea"]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#control-sources-pro-",children:(0,i.jsx)(t.em,{children:"Control sources"})}),"."]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- pattern: source(...)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"exact-sources",children:"Exact sources"}),"\n",(0,i.jsxs)(t.p,{children:["Given the source specification below, and a piece of code such as ",(0,i.jsx)(t.code,{children:"source(sink(x))"}),", the call ",(0,i.jsx)(t.code,{children:"sink(x)"})," is reported as a tainted sink."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- pattern: source(...)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The reason is that the pattern ",(0,i.jsx)(t.code,{children:"source(...)"})," matches all of ",(0,i.jsx)(t.code,{children:"source(sink(x))"}),", and that makes Semgrep consider every subexpression in that piece of code as being a source. In particular, ",(0,i.jsx)(t.code,{children:"x"})," is a source, and it is being passed into ",(0,i.jsx)(t.code,{children:"sink"}),"!"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=eqYN8",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"This is the default for historical reasons, but it may change in the future."}),"\n",(0,i.jsxs)(t.p,{children:['It is possible to instruct Semgrep to only consider as taint sources the "exact" matches of a source pattern by setting ',(0,i.jsx)(t.code,{children:"exact: true"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- pattern: source(...)\n  exact: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:['Once the source is "exact," Semgrep will no longer consider subexpressions as taint sources, and ',(0,i.jsx)(t.code,{children:"sink(x)"})," inside ",(0,i.jsx)(t.code,{children:"source(sink(x))"})," will not be reported as a tainted sink (unless ",(0,i.jsx)(t.code,{children:"x"})," is tainted in some other way)."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=Zq5ow",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"For many rules this distinction is not very meaningful because it does not always make sense that a sink occurs inside the arguments of a source function."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["If one of your rules relies on non-exact matching of sources, we advice you to make it explicit with ",(0,i.jsx)(t.code,{children:"exact: false"}),", even if it is the current default, so that your rule does not break if the default changes."]})}),"\n",(0,i.jsx)(t.h3,{id:"sources-by-side-effect",children:"Sources by side-effect"}),"\n",(0,i.jsxs)(t.p,{children:["Consider the following hypothetical Python code, where ",(0,i.jsx)(t.code,{children:"make_tainted"})," is a function that makes its argument tainted by side-effect:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"make_tainted(my_set)\nsink(my_set)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This kind of source can be specified by setting ",(0,i.jsx)(t.code,{children:"by-side-effect: true"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n  - patterns:\n      - pattern: make_tainted($X)\n      - focus-metavariable: $X\n    by-side-effect: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:["When this option is enabled, and the source specification matches a variable (or in general, an ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue",children:"l-value"}),") exactly, then Semgrep assumes that the variable (or l-value) becomes tainted by side-effect at the precise places where the source specification produces a match."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=5r400",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["The matched occurrences themselves are considered tainted; that is, the occurrence of ",(0,i.jsx)(t.code,{children:"x"})," in ",(0,i.jsx)(t.code,{children:"make_tainted(x)"})," is itself tainted too. If you do not want this to be the case, then set ",(0,i.jsx)(t.code,{children:"by-side-effect: only"})," instead."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["You must use ",(0,i.jsx)(t.code,{children:"focus-metavariable: $X"})," to focus the match on the l-value that you want to taint, otherwise ",(0,i.jsx)(t.code,{children:"by-side-effect"})," does not work."]})}),"\n",(0,i.jsxs)(t.p,{children:["If the source does not set ",(0,i.jsx)(t.code,{children:"by-side-effect"}),", then only the very occurrence of ",(0,i.jsx)(t.code,{children:"x"})," in ",(0,i.jsx)(t.code,{children:"make_tainted(x)"})," will be tainted, but not the occurrence of ",(0,i.jsx)(t.code,{children:"x"})," in ",(0,i.jsx)(t.code,{children:"sink(x)"}),". The source specification matches only the first occurrence and, without ",(0,i.jsx)(t.code,{children:"by-side-effect: true"}),", Semgrep does not know that ",(0,i.jsx)(t.code,{children:"make_tainted"})," is updating the variable ",(0,i.jsx)(t.code,{children:"x"})," by side-effect. Thus, a taint rule using such a specification does not produce any finding."]}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["You could be tempted to write a source specification as the following example (and this was the official workaround before ",(0,i.jsx)(t.code,{children:"by-side-effect"}),"):"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- patterns:\n  - pattern-inside: |\n      make_tainted($X)\n      ...\n  - pattern: $X\n"})}),(0,i.jsxs)(t.p,{children:["This tells Semgrep that ",(0,i.jsx)(t.strong,{children:"every"})," occurrence of ",(0,i.jsx)(t.code,{children:"$X"})," after ",(0,i.jsx)(t.code,{children:"make_tainted($X)"})," must be considered a source."]}),(0,i.jsxs)(t.p,{children:["This approach has two main limitations. First, it overrides any sanitization that can be performed on the code matched by ",(0,i.jsx)(t.code,{children:"$X"}),". In the example code below, the call ",(0,i.jsx)(t.code,{children:"sink(x)"})," is reported as tainted despite ",(0,i.jsx)(t.code,{children:"x"})," having been sanitized!"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"make_tainted(x)\nx = sanitize(x)\nsink(x) # false positive\n"})}),(0,i.jsxs)(t.p,{children:["Note also that ",(0,i.jsxs)(t.a,{href:"/writing-rules/pattern-syntax/#ellipses-and-statement-blocks",children:[(0,i.jsx)(t.code,{children:"..."})," ellipses operator"]})," has limitations. For example, in the code below Semgrep does not match any finding if such source specification is in use:"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"if cond:\n    make_tainted(x)\nsink(x) # false negative\n"})}),(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"by-side-effect"})," option was added precisely ",(0,i.jsx)(t.a,{href:"https://semgrep.dev/playground/s/JDv4y",children:"to address those limitations"}),". However, that kind of workaround can still be useful in other situations!"]})]}),"\n",(0,i.jsx)(t.h3,{id:"function-arguments-as-sources",children:"Function arguments as sources"}),"\n",(0,i.jsx)(t.p,{children:"To specify that an argument of a function must be considered a taint source, simply write a pattern that matches that argument:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n  - patterns:\n    - pattern-inside: |\n        def foo($X, ...):\n          ...\n    - focus-metavariable: $X\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that the use of ",(0,i.jsx)(t.code,{children:"focus-metavariable: $X"})," is very important, and using ",(0,i.jsx)(t.code,{children:"pattern: $X"})," is ",(0,i.jsx)(t.strong,{children:"not"})," equivalent. With ",(0,i.jsx)(t.code,{children:"focus-metavariable: $X"}),', Semgrep matches the formal parameter exactly. Click "Open in Playground" below and use "Inspect Rule" to visualize what the source is matching.']}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=L1vJ6",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["The following example does the same with this other taint rule that uses ",(0,i.jsx)(t.code,{children:"pattern: $X"}),". The ",(0,i.jsx)(t.code,{children:"pattern: $X"})," does not match the formal parameter itself, but matches all its uses inside the function definition. Even if ",(0,i.jsx)(t.code,{children:"x"})," is sanitized via ",(0,i.jsx)(t.code,{children:"x = sanitize(x)"}),", the occurrence of ",(0,i.jsx)(t.code,{children:"x"})," inside ",(0,i.jsx)(t.code,{children:"sink(x)"})," is a taint source itself (due to ",(0,i.jsx)(t.code,{children:"pattern: $X"}),") and so ",(0,i.jsx)(t.code,{children:"sink(x)"})," is tainted!"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=Qr3Y4",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"control-sources-pro-",children:"Control sources (Pro) \ud83e\uddea"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Control taint sources is a Semgrep Pro feature."})}),"\n",(0,i.jsxs)(t.p,{children:["Typically taint analysis tracks the flow of tainted ",(0,i.jsx)(t.em,{children:"data"}),", but taint sources can also track the flow of tainted ",(0,i.jsx)(t.em,{children:"control"})," by setting ",(0,i.jsx)(t.code,{children:"control: true"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- pattern: source(...)\n  control: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is useful for checking ",(0,i.jsx)(t.em,{children:"reachability"}),", that is to check if from a given code location the control-flow can reach another code location, regardless of whether there is any flow of data between them. In the following example we check whether ",(0,i.jsx)(t.code,{children:"foo()"})," could be followed by ",(0,i.jsx)(t.code,{children:"bar()"}),":"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=yyjrx",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"By using a control source, you can define a context from which Semgrep detects if a call to some other code, such as a sink, can be reached."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Use ",(0,i.jsx)(t.a,{href:"#taint-labels-pro-",children:"taint labels"})," to combine both data and control sources in the same rule."]})}),"\n",(0,i.jsx)(t.h2,{id:"sanitizers",children:"Sanitizers"}),"\n",(0,i.jsxs)(t.p,{children:["A taint sanitizer is specified by a pattern. Like in a search-mode rule, you can start this pattern with one of the following keys: ",(0,i.jsx)(t.code,{children:"pattern"}),", ",(0,i.jsx)(t.code,{children:"patterns"}),", ",(0,i.jsx)(t.code,{children:"pattern-either"}),", ",(0,i.jsx)(t.code,{children:"pattern-regex"}),". Note that ",(0,i.jsx)(t.strong,{children:"any"})," subexpression that is matched by this pattern will be regarded as sanitized."]}),"\n",(0,i.jsx)(t.p,{children:"In addition, taint sanitizers accept the following options:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"exact"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#exact-sanitizers",children:(0,i.jsx)(t.em,{children:"Exact sanitizers"})}),"."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"by-side-effect"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"only"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#sanitizers-by-side-effect",children:(0,i.jsx)(t.em,{children:"Sanitizers by side-effect"})}),"."]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sanitizers:\n- pattern: sanitize(...)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"exact-sanitizers",children:"Exact sanitizers"}),"\n",(0,i.jsxs)(t.p,{children:["Given the sanitizer specification below, and a piece of code such as ",(0,i.jsx)(t.code,{children:'sanitize(sink("taint"))'}),", the call ",(0,i.jsx)(t.code,{children:'sink("taint")'})," is ",(0,i.jsx)(t.strong,{children:"not"})," reported."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sanitizers:\n- pattern: sanitize(...)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The reason is that the pattern ",(0,i.jsx)(t.code,{children:"sanitize(...)"})," matches all of ",(0,i.jsx)(t.code,{children:'sanitize(sink("taint"))'}),", and that makes Semgrep consider every subexpression in that piece of code as being sanitized. In particular, ",(0,i.jsx)(t.code,{children:'"taint"'})," is considered to be sanitized!"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=v83Rb",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"This is the default for historical reasons, but it may change in the future."}),"\n",(0,i.jsxs)(t.p,{children:['It is possible to instruct Semgrep to only consider as sanitized the "exact" matches of a sanitizer pattern by setting ',(0,i.jsx)(t.code,{children:"exact: true"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sanitizers:\n- pattern: sanitize(...)\n  exact: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:['Once the source is "exact," Semgrep will no longer consider subexpressions as sanitized, and ',(0,i.jsx)(t.code,{children:'sink("taint")'})," inside ",(0,i.jsx)(t.code,{children:'sanitize(sink("taint"))'})," will be reported as a tainted sink."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=Zqz8o",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"For many rules this distinction is not very meaningful because it does not always make sense that a sink occurs inside the arguments of a sanitizer function."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["If one of your rules relies on non-exact matching of sanitizers, We at Semgrep advise you to make it explicit with ",(0,i.jsx)(t.code,{children:"exact: false"}),", even if it is the current default, so that your rule does not break if the default changes."]})}),"\n",(0,i.jsx)(t.h3,{id:"sanitizers-by-side-effect",children:"Sanitizers by side-effect"}),"\n",(0,i.jsxs)(t.p,{children:["Consider the following hypothetical Python code, where it is guaranteed that after ",(0,i.jsx)(t.code,{children:"check_if_safe(x)"}),", the value of ",(0,i.jsx)(t.code,{children:"x"})," must be a safe one."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"x = source()\ncheck_if_safe(x)\nsink(x)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This kind of sanitizer can be specified by setting ",(0,i.jsx)(t.code,{children:"by-side-effect: true"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sanitizers:\n  - patterns:\n      - pattern: check_if_safe($X)\n      - focus-metavariable: $X\n    by-side-effect: true\n"})}),"\n",(0,i.jsx)(t.p,{children:"When this option is enabled, and the sanitizer specification matches a variable (or in general, an l-value) exactly, then Semgrep assumes that the variable (or l-value) is sanitized by side-effect at the precise places where the sanitizer specification produces a match."}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=4bvGz",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["It is important to use ",(0,i.jsx)(t.code,{children:"focus-metavariable: $X"})," to focus the match on the l-value that we want to sanitize, otherwise ",(0,i.jsx)(t.code,{children:"by-side-effect"})," does not work as expected."]})}),"\n",(0,i.jsxs)(t.p,{children:["If the sanitizer does not set ",(0,i.jsx)(t.code,{children:"by-side-efect"}),", then only the very occurrence of ",(0,i.jsx)(t.code,{children:"x"})," in ",(0,i.jsx)(t.code,{children:"check_if_safe(x)"})," will be sanitized, but not the occurrence of ",(0,i.jsx)(t.code,{children:"x"})," in ",(0,i.jsx)(t.code,{children:"sink(x)"}),". The sanitizer specification matches only the first occurrence and, without ",(0,i.jsx)(t.code,{children:"by-side-effect: true"}),", Semgrep does not know that ",(0,i.jsx)(t.code,{children:"check_if_safe"})," is updating/sanitizing the variable ",(0,i.jsx)(t.code,{children:"x"})," by side-effect. Thus, a taint rule using such specification does produce a finding for ",(0,i.jsx)(t.code,{children:"sink(x)"})," in the example above."]}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["You can be tempted to write a sanitizer specification as the one below (and this was the official workaround before ",(0,i.jsx)(t.code,{children:"by-side-effect"}),"):"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sanitizers:\n- patterns:\n  - pattern-inside: |\n      check_if_safe($X)\n      ...\n  - pattern: $X\n"})}),(0,i.jsxs)(t.p,{children:["This tells Semgrep that ",(0,i.jsx)(t.strong,{children:"every"})," occurrence of ",(0,i.jsx)(t.code,{children:"$X"})," after ",(0,i.jsx)(t.code,{children:"check_if_safe($X)"})," must be considered sanitized."]}),(0,i.jsxs)(t.p,{children:["This approach has two main limitations. First, it overrides any further tainting that can be performed on the code matched by ",(0,i.jsx)(t.code,{children:"$X"}),".  In the example code below, the call ",(0,i.jsx)(t.code,{children:"sink(x)"})," is  ",(0,i.jsx)(t.strong,{children:"not"})," reported as tainted despite ",(0,i.jsx)(t.code,{children:"x"})," having been tainted!"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"check_if_safe(x)\nx = source()\nsink(x) # false negative\n"})}),(0,i.jsxs)(t.p,{children:["Note also that ",(0,i.jsxs)(t.a,{href:"/writing-rules/pattern-syntax/#ellipses-and-statement-blocks",children:[(0,i.jsx)(t.code,{children:"..."})," ellipses operator"]})," has limitations. For example, in the code below Semgrep still matches despite ",(0,i.jsx)(t.code,{children:"x"})," having been sanitized in both branches:"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"if cond:\n    check_if_safe(x)\nelse\n    check_if_safe(x)\nsink(x) # false positive\n"})}),(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"by-side-effect"})," option was added precisely ",(0,i.jsx)(t.a,{href:"https://semgrep.dev/playground/s/PeB3W",children:"to address those limitations"}),". However, that kind of workaround can still be useful in other situations!"]})]}),"\n",(0,i.jsx)(t.h2,{id:"sinks",children:"Sinks"}),"\n",(0,i.jsxs)(t.p,{children:["A taint sink is specified by a pattern. Like in a search-mode rule, you can start this pattern with one of the following keys: ",(0,i.jsx)(t.code,{children:"pattern"}),", ",(0,i.jsx)(t.code,{children:"patterns"}),", ",(0,i.jsx)(t.code,{children:"pattern-either"}),", ",(0,i.jsx)(t.code,{children:"pattern-regex"}),". Unlike sources and sanitizers, by default Semgrep does not consider the subexpressions of the matched expressions as sinks."]}),"\n",(0,i.jsx)(t.p,{children:"In addition, taint sinks accept the following options:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"exact"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"true"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#non-exact-sinks",children:(0,i.jsx)(t.em,{children:"Non-exact sinks"})}),"."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.code,{children:"at-exit"})," (Pro) \ud83e\uddea"]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#at-exit-sinks-pro-",children:(0,i.jsx)(t.em,{children:"At-exit sinks"})}),"."]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sinks:\n- pattern: sink(...)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"non-exact-sinks",children:"Non-exact sinks"}),"\n",(0,i.jsxs)(t.p,{children:["Given the sink specification below, a piece of code such as ",(0,i.jsx)(t.code,{children:'sink("foo" if tainted else "bar")'})," will ",(0,i.jsx)(t.strong,{children:"not"})," be reported as a tainted sink."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sources:\n- pattern: sink(...)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is because Semgrep considers that the sink is the argument of the ",(0,i.jsx)(t.code,{children:"sink"})," function, and the actual argument being passed is ",(0,i.jsx)(t.code,{children:'"foo" if tainted else "bar"'})," that evaluates to either ",(0,i.jsx)(t.code,{children:'"foo"'})," or ",(0,i.jsx)(t.code,{children:'"bar"'}),", and neither of them are tainted."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=KxJ17",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["It is possible to instruct Semgrep to consider as a taint sink any of the subexpressions matching the sink pattern, by setting ",(0,i.jsx)(t.code,{children:"exact: false"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-sinks:\n- pattern: sink(...)\n  exact: false\n"})}),"\n",(0,i.jsxs)(t.p,{children:['Once the sink is "non-exact" Semgrep will consider subexpressions as taint sinks, and ',(0,i.jsx)(t.code,{children:"tainted"})," inside ",(0,i.jsx)(t.code,{children:'sink("foo" if tainted else "bar")'})," will then be reported as a tainted sink."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=qNwez",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"function-arguments-as-sinks",children:"Function arguments as sinks"}),"\n",(0,i.jsxs)(t.p,{children:["We can specify that only one (or a subset) of the arguments of a function is the actual sink by using ",(0,i.jsx)(t.code,{children:"focus-metavariable"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"pattern-sinks:\n  - patterns:\n    - pattern: sink($SINK, ...)\n    - focus-metavariable: $SINK\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This rule causes Semgrep to only annotate the first parameter passed to ",(0,i.jsx)(t.code,{children:"sink"})," as the sink, rather than the function ",(0,i.jsx)(t.code,{children:"sink"})," itself. If taint goes into any other parameter of ",(0,i.jsx)(t.code,{children:"sink"}),", then that is not considered a problem."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=v83Nl",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"Anything that you can match with Semgrep can be made into a sink, like the index in an array access:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"pattern-sinks:\n  - patterns:\n    - pattern-inside: $ARRAY[$SINK]\n    - focus-metavariable: $SINK\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["If you specify a sink such as ",(0,i.jsx)(t.code,{children:"sink(...)"})," then any tainted data passed to ",(0,i.jsx)(t.code,{children:"sink"}),", through any of its arguments, results in a finding."]}),(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=OrAAe",border:"0",frameBorder:"0",width:"100%",height:"432"})]}),"\n",(0,i.jsx)(t.h3,{id:"at-exit-sinks-pro-",children:"At-exit sinks (Pro) \ud83e\uddea"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"At-exit taint sinks is a Semgrep Pro feature."})}),"\n",(0,i.jsxs)(t.p,{children:["At-exit sinks are meant to facilitate writing leak-detection rules using taint mode. By setting ",(0,i.jsx)(t.code,{children:"at-exit: true"}),' you can restrict a sink specification to only match at "exit" statements, that is statements after which the control-flow will exit the function being analyzed.']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"pattern-sinks:\n- pattern-either:\n  - pattern: return ...\n  - pattern: $F(...)\n  at-exit: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The above sink pattern matches either ",(0,i.jsx)(t.code,{children:"return"}),' statements (which are always "exit" statements), or function calls occurring as "exit" statements.']}),"\n",(0,i.jsxs)(t.p,{children:["Unlike regular sinks, at-exit sinks trigger a finding if any tainted l-value reaches the location of the sink. For example, the at-exit sink specification above will trigger a finding at a ",(0,i.jsx)(t.code,{children:"return 0"})," statement if some tainted l-value reaches the ",(0,i.jsx)(t.code,{children:"return"}),", even if ",(0,i.jsx)(t.code,{children:"return 0"})," itself is not tainted. The location itself is the sink rather than the code that is at that location."]}),"\n",(0,i.jsx)(t.p,{children:"You can use this, for example, to check that file descriptors are being closed within the same function where they were opened."}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=OrAzB",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"print(content)"})," statement is reported because the control flow exits the function at that point, and the file has not been closed."]}),"\n",(0,i.jsx)(t.h2,{id:"propagators-pro",children:"Propagators (Pro)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Custom taint propagators is a Semgrep Pro feature."})}),"\n",(0,i.jsx)(t.p,{children:"By default, tainted data automatically propagates through assignments, operators, and function calls (from inputs to output). However, there are other ways in which taint can propagate, which can require language or library-specific knowledge that Semgrep does not have built-in."}),"\n",(0,i.jsxs)(t.p,{children:["A taint propagator requires a pattern to be specified. Like in a search-mode rule, you can start this pattern with one of the following keys: ",(0,i.jsx)(t.code,{children:"pattern"}),", ",(0,i.jsx)(t.code,{children:"patterns"}),", ",(0,i.jsx)(t.code,{children:"pattern-either"}),", ",(0,i.jsx)(t.code,{children:"pattern-regex"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A propagator also needs to specify the origin (",(0,i.jsx)(t.code,{children:"from"}),") and the destination (",(0,i.jsx)(t.code,{children:"to"}),") of the taint to be propagated."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"from"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"metavariable"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Source of propagation."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"to"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"metavariable"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Destination of propagation."})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"In addition, taint propagators accept the following options:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"by-side-effect"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"true"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["See ",(0,i.jsx)(t.a,{href:"#propagation-without-side-effect",children:(0,i.jsx)(t.em,{children:"Propagation without side-effect"})}),"."]})]})})]}),"\n",(0,i.jsxs)(t.p,{children:["For example, given the following propagator, if taint goes into the second argument of ",(0,i.jsx)(t.code,{children:"strcpy"}),", its first argument will get the same taint:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-propagators:\n- pattern: strcpy($DST, $SRC)\n  from: $SRC\n  to: $DST\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["Taint propagators only work intra-procedurally, that is, within a function or method. You cannot use taint propagators to propagate taint across different functions/methods. Use ",(0,i.jsx)(t.a,{href:"#inter-procedural-analysis-pro",children:"inter-procedural analysis"}),"."]})}),"\n",(0,i.jsx)(t.h3,{id:"understanding-custom-propagators",children:"Understanding custom propagators"}),"\n",(0,i.jsxs)(t.p,{children:["Consider the following Python code where an unsafe ",(0,i.jsx)(t.code,{children:"user_input"})," is stored into a ",(0,i.jsx)(t.code,{children:"set"})," data structure. A random element from ",(0,i.jsx)(t.code,{children:"set"})," is then passed into a ",(0,i.jsx)(t.code,{children:"sink"})," function. This random element can be ",(0,i.jsx)(t.code,{children:"user_input"})," itself, leading to an injection vulnerability!"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"def test(s):\n    x = user_input\n    s = set([])\n    s.add(x)\n    #ruleid: test\n    sink(s.pop())\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The following rule cannot find the above-described issue. The reason is that Semgrep is not aware that executing ",(0,i.jsx)(t.code,{children:"s.add(x)"})," makes ",(0,i.jsx)(t.code,{children:"x"})," one of the elements in the set data structure ",(0,i.jsx)(t.code,{children:"s"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"mode: taint\npattern-sources:\n- pattern: user_input\npattern-sinks:\n- pattern: sink(...)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The use of ",(0,i.jsx)(t.strong,{children:"taint propagators"})," enables Semgrep to propagate taint in this and other scenarios.\nTaint propagators are specified under the ",(0,i.jsx)(t.code,{children:"pattern-propagators"})," key:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-propagators:\n- pattern: $S.add($E)\n  from: $E\n  to: $S\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the example above, Semgrep finds the pattern ",(0,i.jsx)(t.code,{children:"$S.add($E)"}),", and it checks whether the code matched by ",(0,i.jsx)(t.code,{children:"$E"})," is tainted. If it is tainted, Semgrep propagates that same taint to the code matched by ",(0,i.jsx)(t.code,{children:"$S"}),". Thus, adding tainted data to a set marks the set itself as tainted."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=dGRE",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.code,{children:"s"})," becomes tainted ",(0,i.jsx)(t.em,{children:"by side-effect"})," after ",(0,i.jsx)(t.code,{children:"s.add(x)"}),", this is due to ",(0,i.jsx)(t.code,{children:"by-side-effect: true"})," being the default for propagators, and because ",(0,i.jsx)(t.code,{children:"s"})," is an l-value."]}),"\n",(0,i.jsx)(t.p,{children:"In general, a taint propagator must specify:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["A pattern containing ",(0,i.jsx)(t.strong,{children:"two"})," metavariables. These two metavariables specify where taint is propagated ",(0,i.jsx)(t.strong,{children:"from"})," and ",(0,i.jsx)(t.strong,{children:"to"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"to"})," and ",(0,i.jsx)(t.code,{children:"from"})," metavariables. These metavariables should match an ",(0,i.jsx)(t.strong,{children:"expression"}),".","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"from"})," metavariable specifies the entry point of the taint."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"to"})," metavariable specifies where the tainted data is propagated to, typically an object or data structure. If option ",(0,i.jsx)(t.code,{children:"by-side-effect"})," is enabled (as it is by default) and the ",(0,i.jsx)(t.code,{children:"to"})," metavariable matches an l-value, the propagation is side-effectful."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In the example above, pattern ",(0,i.jsx)(t.code,{children:"$S.add($E)"})," includes two metavariables ",(0,i.jsx)(t.code,{children:"$S"})," and ",(0,i.jsx)(t.code,{children:"$E"}),". Given ",(0,i.jsx)(t.code,{children:"from: $E"})," and ",(0,i.jsx)(t.code,{children:"to: $S"}),", and with ",(0,i.jsx)(t.code,{children:"$E"})," matching ",(0,i.jsx)(t.code,{children:"x"})," and ",(0,i.jsx)(t.code,{children:"$S"})," matching ",(0,i.jsx)(t.code,{children:"s"}),", when ",(0,i.jsx)(t.code,{children:"x"})," is tainted then ",(0,i.jsx)(t.code,{children:"s"})," becomes tainted (by side-effect) with the same taint as ",(0,i.jsx)(t.code,{children:"x"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Another situation where taint propagators can be useful is to specify in Java that, when iterating a collection that is tainted, the individual elements must also be considered tainted:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-propagators:\n- pattern: $C.forEach(($X) -> ...)\n  from: $C\n  to: $X\n"})}),"\n",(0,i.jsx)(t.h3,{id:"propagation-without-side-effect",children:"Propagation without side-effect"}),"\n",(0,i.jsxs)(t.p,{children:["Taint propagators can be used in very imaginative ways, and in some cases you may not want taint to propagate by side-effect. This can be achieved by disabling ",(0,i.jsx)(t.code,{children:"by-side-effect"}),", which is enabled by default."]}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"pattern-propagators:\n  - patterns:\n    - pattern: |\n        if something($FROM):\n          ...\n          $TO()\n          ...\n    from: $FROM\n    to: $TO\n    by-side-effect: false\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The propagator above specifies that inside an ",(0,i.jsx)(t.code,{children:"if"})," block, where the condition is ",(0,i.jsx)(t.code,{children:"something($FROM)"}),", we want to propagate taint from ",(0,i.jsx)(t.code,{children:"$FROM"})," to any function that is being called without arguments, ",(0,i.jsx)(t.code,{children:"$TO()"}),"."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=4bv6x",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["Because the rule disables ",(0,i.jsx)(t.code,{children:"by-side-effect"}),", the ",(0,i.jsx)(t.code,{children:"sink"})," occurrence that is inside the ",(0,i.jsx)(t.code,{children:"if"})," block is tainted, but this does not affect the ",(0,i.jsx)(t.code,{children:"sink"})," occurrence outside the ",(0,i.jsx)(t.code,{children:"if"})," block."]}),"\n",(0,i.jsx)(t.h2,{id:"findings",children:"Findings"}),"\n",(0,i.jsx)(t.p,{children:"Taint findings are accompanied by a taint trace that explains how the taint flows from source to sink."}),"\n",(0,i.jsx)(t.h3,{id:"deduplication-of-findings",children:"Deduplication of findings"}),"\n",(0,i.jsxs)(t.p,{children:['Semgrep tracks all the possible ways that taint can reach a sink, but at present it only reports one taint trace among the possible ones. Click "Open in Playground" in the example below, run the example to get one finding, and then ask the Playground to visualize the dataflow of the finding. Even though ',(0,i.jsx)(t.code,{children:"sink"})," can be tainted via ",(0,i.jsx)(t.code,{children:"x"})," or via ",(0,i.jsx)(t.code,{children:"y"}),", the trace will only show you one of these possibilities. If you replace ",(0,i.jsx)(t.code,{children:"x = user_input"})," with ",(0,i.jsx)(t.code,{children:'x = "safe"'}),", then Semgrep will then report the taint trace via ",(0,i.jsx)(t.code,{children:"y"}),"."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=WAYzL",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"report-findings-on-the-sources-pro",children:"Report findings on the sources (Pro)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Reporting findings on the source of taint is a Semgrep Pro feature."})}),"\n",(0,i.jsxs)(t.p,{children:["By default Semgrep reports taint findings at the location of the sink being matched. You must look at the taint trace to identify where the taint is coming from. It is also possible to make Semgrep report the findings at the location of the taint sources, by setting the ",(0,i.jsx)(t.a,{href:"/writing-rules/rule-syntax/#options",children:"rule-level option"})," ",(0,i.jsx)(t.code,{children:"taint_focus_on"})," to ",(0,i.jsx)(t.code,{children:"source"}),". Then"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"options:\n  taint_focus_on: source\n"})}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=JDPGP",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"#deduplication-of-findings",children:"deduplication of findings"})," still applies in this case. While Semgrep will now report all the taint sources, if a taint source can reach multiple sinks, the taint trace will only inform you about one of them."]}),"\n",(0,i.jsx)(t.h2,{id:"minimizing-false-positives",children:"Minimizing false positives"}),"\n",(0,i.jsxs)(t.p,{children:["The following ",(0,i.jsx)(t.a,{href:"/writing-rules/rule-syntax/#options",children:"rule options"})," can be used to minimize false positives:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Rule option"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"taint_assume_safe_booleans"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Boolean data is never considered tainted (works better with type annotations)."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"taint_assume_safe_numbers"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Numbers (integers, floats) are never considered tainted (works better with type annotations)."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"taint_assume_safe_indexes"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["An index expression ",(0,i.jsx)(t.code,{children:"I"})," tainted does not make an access expression ",(0,i.jsx)(t.code,{children:"E[I]"})," tainted (it is only tainted if ",(0,i.jsx)(t.code,{children:"E"})," is tainted)."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"taint_assume_safe_functions"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["A function call like ",(0,i.jsx)(t.code,{children:"F(E)"})," is not considered tainted even if ",(0,i.jsx)(t.code,{children:"E"})," is tainted. (When using Pro's ",(0,i.jsx)(t.a,{href:"#inter-procedural-analysis-pro",children:"inter-procedural taint analysis"}),", this only applies to functions for which Semgrep cannot find a definition.)"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.code,{children:"taint_only_propagate_through_assignments"})," \ud83e\uddea"]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Disables all implicit taint propagation except for assignments."})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"restrict-taint-by-type-pro",children:"Restrict taint by type (Pro)"}),"\n",(0,i.jsxs)(t.p,{children:["By enabling ",(0,i.jsx)(t.code,{children:"taint_assume_safe_booleans"})," Semgrep automatically sanitizes Boolean expressions when it can infer that the expression resolves to Boolean."]}),"\n",(0,i.jsx)(t.p,{children:"For example, comparing a tainted string against a constant string will not be considered a tainted expression:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=6JvzK",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["Similarly, enabling ",(0,i.jsx)(t.code,{children:"taint_assume_safe_numbers"})," Semgrep will automatically sanitize numeric expressions when it can infer that the expression is numeric."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=oqjgX",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.p,{children:"You could define explicit sanitizers that clean the taint from Boolean or numeric expressions, but these options are more convenient and also more efficient."}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["Semgrep Pro's ability to infer types for expressions varies depending on the language. For example, in Python type annotations are not always present, and the ",(0,i.jsx)(t.code,{children:"+"})," operator can also be used to concatenate strings. Semgrep also ignores the types of functions and classes coming from third-party libraries."]}),(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=zdjnn",border:"0",frameBorder:"0",width:"100%",height:"432"})]}),"\n",(0,i.jsx)(t.h3,{id:"assume-tainted-indexes-are-safe",children:"Assume tainted indexes are safe"}),"\n",(0,i.jsxs)(t.p,{children:["By default, Semgrep assumes that accessing an array-like object with a tainted index (that is, ",(0,i.jsx)(t.code,{children:"obj[tainted]"}),") is itself a tainted ",(0,i.jsx)(t.strong,{children:"expression"}),", even if the ",(0,i.jsx)(t.strong,{children:"object"})," itself is not tainted. Setting ",(0,i.jsx)(t.code,{children:"taint_assume_safe_indexes: true"})," makes Semgrep assume that these expressions are safe."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=X56pj",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"assume-function-calls-are-safe",children:"Assume function calls are safe"}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["We refer to a function call as ",(0,i.jsx)(t.em,{children:"opaque"}),' when Semgrep does not have access to its definition, to examine it and determine its "taint behavior" (for example, whether the function call propagates or not any taint that comes through its inputs). In Semgrep Community Edition (CE), where taint analysis is intra-procedural, all function calls are opaque. In Semgrep Pro, with ',(0,i.jsx)(t.a,{href:"#inter-procedural-analysis-pro",children:"inter-procedural taint analysis"}),", an opaque function could be one coming from a third-party library."]})}),"\n",(0,i.jsxs)(t.p,{children:["By default Semgrep considers that an ",(0,i.jsx)(t.em,{children:"opaque"})," function call propagates any taint passed through any of its arguments to its output."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, in the code below, ",(0,i.jsx)(t.code,{children:"some_safe_function"})," receives tainted data as input, so Semgrep assumes that it also returns tainted data as output. As a result, a finding is produced."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"var x = some_safe_function(tainted);\nsink(x); // undesired finding here\n"})}),"\n",(0,i.jsx)(t.p,{children:"This can generate false positives, and for certain rules on certain codebases it can produce a high amount of noise."}),"\n",(0,i.jsxs)(t.p,{children:["Setting ",(0,i.jsx)(t.code,{children:"taint_assume_safe_functions: true"})," makes Semgrep assume that opaque function calls are safe and do not propagate any taint. If it is desired that specific functions do propagate taint, then that can be achieved via custom propagators:"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=gBD0",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"propagate-only-through-assignments-",children:"Propagate only through assignments \ud83e\uddea"}),"\n",(0,i.jsxs)(t.p,{children:["Setting ",(0,i.jsx)(t.code,{children:"taint_only_propagate_through_assignments: true"})," makes Semgrep to only propagate taint through trivial assignments of the form ",(0,i.jsx)(t.code,{children:"<l-value> = <tainted-expression>"}),". It requires the user to be explicit about any other kind of taint propagation that is to be performed."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, neither ",(0,i.jsx)(t.code,{children:"unsafe_function(tainted)"})," nor ",(0,i.jsx)(t.code,{children:'tainted_string + "foo"'})," will be considered tainted expressions:"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=bwekv",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h2,{id:"metavariables-rule-message-and-unification",children:"Metavariables, rule message, and unification"}),"\n",(0,i.jsxs)(t.p,{children:["The patterns specified by ",(0,i.jsx)(t.code,{children:"pattern-sources"})," and ",(0,i.jsx)(t.code,{children:"pattern-sinks"})," (and ",(0,i.jsx)(t.code,{children:"pattern-sanitizers"}),") are all independent of each other. If a metavariable used in ",(0,i.jsx)(t.code,{children:"pattern-sources"})," has the same name as a metavariable used in ",(0,i.jsx)(t.code,{children:"pattern-sinks"}),", these are still different metavariables."]}),"\n",(0,i.jsxs)(t.p,{children:["In the message of a taint-mode rule, you can refer to any metavariable bound by ",(0,i.jsx)(t.code,{children:"pattern-sinks"}),", as well as to any metavariable bound by ",(0,i.jsx)(t.code,{children:"pattern-sources"})," that does not conflict with a metavariable bound by ",(0,i.jsx)(t.code,{children:"pattern-sinks"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Semgrep can also treat metavariables with the same name as the ",(0,i.jsx)(t.em,{children:"same"})," metavariable, simply set ",(0,i.jsx)(t.code,{children:"taint_unify_mvars: true"})," using rule ",(0,i.jsx)(t.code,{children:"options"}),". Unification enforces that whatever a metavariable binds to in each of these operators is, syntactically speaking, the ",(0,i.jsx)(t.strong,{children:"same"})," piece of code. For example, if a metavariable binds to a code variable ",(0,i.jsx)(t.code,{children:"x"})," in the source match, it must bind to the same code variable ",(0,i.jsx)(t.code,{children:"x"})," in the sink match. In general, unless you know what you are doing, avoid metavariable unification between sources and sinks."]}),"\n",(0,i.jsx)(t.p,{children:"The following example demonstrates the use of source and sink metavariable unification:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=G652",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h2,{id:"inter-procedural-analysis-pro",children:"Inter-procedural analysis (Pro)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Inter-procedural taint analysis is a Semgrep Pro feature."})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/semgrep-pro-vs-oss/",children:"Semgrep"})," can perform inter-procedural taint analysis, that is, to track taint across multiple functions."]}),"\n",(0,i.jsxs)(t.p,{children:["In the example below, ",(0,i.jsx)(t.code,{children:"user_input"})," is passed to ",(0,i.jsx)(t.code,{children:"foo"})," as input and, from there, flows to the sink at line 3, through a call chain involving three functions. Semgrep is able to track this and report the sink as tainted. Semgrep also provides an inter-procedural taint trace that explains how exactly ",(0,i.jsx)(t.code,{children:"user_input"})," reaches the ",(0,i.jsx)(t.code,{children:"sink(z)"}),' statement (click "Open in Playground" then click "dataflow" in the "Matches" panel).']}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=PeBXv",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.p,{children:["Using the CLI option ",(0,i.jsx)(t.code,{children:"--pro-intrafile"}),", Semgrep will perform inter-procedural (across functions) ",(0,i.jsx)(t.em,{children:"intra"}),"-file (within one file) analysis. That is, it will track taint across functions, but it will not cross file boundaries. This is supported for essentially every language, and performance is very close to that of intra-procedural taint analysis."]}),"\n",(0,i.jsxs)(t.p,{children:["Using the CLI option ",(0,i.jsx)(t.code,{children:"--pro"}),", Semgrep will perform inter-procedural (across functions) as well as ",(0,i.jsx)(t.em,{children:"inter"}),"-file (across files) analysis. Inter-file analysis is only supported for ",(0,i.jsx)(t.a,{href:"/supported-languages#language-maturity-summary",children:"a subset of languages"}),". For a rule to run interfile it also needs to set ",(0,i.jsx)(t.code,{children:"interfile: true"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"options:\n  interfile: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Memory requirements for inter-file analysis:"}),"\nWhile interfile analysis is more powerful, it also demands more memory resources. The Semgrep team advises a minimum of 4 GB of memory per core, but ",(0,i.jsx)(t.strong,{children:"recommend 8 GB per core or more"}),". The amount of memory needed depends on the codebase and on the number of interfile rules being run."]}),"\n",(0,i.jsx)(t.h2,{id:"taint-mode-sensitivity",children:"Taint mode sensitivity"}),"\n",(0,i.jsx)(t.h3,{id:"field-sensitivity",children:"Field sensitivity"}),"\n",(0,i.jsx)(t.p,{children:"The taint engine provides basic field sensitivity support. It can:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Track that ",(0,i.jsx)(t.code,{children:"x.a.b"})," is tainted, but ",(0,i.jsx)(t.code,{children:"x"})," or ",(0,i.jsx)(t.code,{children:"x.a"})," is  ",(0,i.jsx)(t.strong,{children:"not"})," tainted. If ",(0,i.jsx)(t.code,{children:"x.a.b"})," is tainted, any extension of ",(0,i.jsx)(t.code,{children:"x.a.b"})," (such as ",(0,i.jsx)(t.code,{children:"x.a.b.c"}),") is considered tainted by default."]}),"\n",(0,i.jsxs)(t.li,{children:["Track that ",(0,i.jsx)(t.code,{children:"x.a"})," is tainted, but remember that ",(0,i.jsx)(t.code,{children:"x.a.b"})," has been sanitized. Thus the engine records that ",(0,i.jsx)(t.code,{children:"x.a.b"})," is ",(0,i.jsx)(t.strong,{children:"not"})," tainted, but ",(0,i.jsx)(t.code,{children:"x.a"})," or ",(0,i.jsx)(t.code,{children:"x.a.c"})," are still tainted."]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["The taint engine does track taint ",(0,i.jsx)(t.strong,{children:"per variable"})," and not ",(0,i.jsx)(t.strong,{children:"per object in memory"}),". The taint engine does not track aliasing at present."]})}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=5rvkj",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h3,{id:"index-sensitivity-pro",children:"Index sensitivity (Pro)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Index sensitivity is a Semgrep Pro feature."})}),"\n",(0,i.jsx)(t.p,{children:"Semgrep Pro has basic index sensitivity support:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Only for accesses using the built-in ",(0,i.jsx)(t.code,{children:"a[E]"})," syntax."]}),"\n",(0,i.jsxs)(t.li,{children:["Works for ",(0,i.jsx)(t.em,{children:"statically constant"})," indexes that may be either integers (e.g. ",(0,i.jsx)(t.code,{children:"a[42]"}),") or strings (e.g. ",(0,i.jsx)(t.code,{children:'a["foo"]'}),")."]}),"\n",(0,i.jsxs)(t.li,{children:["If an arbitrary index ",(0,i.jsx)(t.code,{children:"a[i]"})," is sanitized, then every index becomes clean of taint."]}),"\n"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=GdoK6",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(t.h2,{id:"taint-labels-pro-",children:"Taint labels (Pro) \ud83e\uddea"}),"\n",(0,i.jsx)(t.p,{children:"Taint labels increase the expressiveness of taint analysis by allowing you to specify and track different kinds of tainted data in one rule using labels. This functionality has various uses, for example, when data becomes dangerous in several steps that are hard to specify through single pair of source and sink."}),"\n",(0,i.jsx)("iframe",{class:"yt_embed",width:"100%",height:"432px",src:"https://www.youtube.com/embed/lAbJdzMUR4k",frameborder:"0",allowfullscreen:!0}),"\n",(0,i.jsx)(t.p,{children:"To include taint labels into a taint mode rule, follow these steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Attach a ",(0,i.jsx)(t.code,{children:"label"})," key to the taint source. For example, ",(0,i.jsx)(t.code,{children:"label: TAINTED"})," or ",(0,i.jsx)(t.code,{children:"label: INPUT"}),". See the example below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"  pattern-sources:\n    - pattern: user_input\n      label: INPUT\n"})}),"\n",(0,i.jsx)(t.p,{children:"Semgrep accepts any valid Python identifier as a label."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Restrict a taint source to a subset of labels using the ",(0,i.jsx)(t.code,{children:"requires"})," key. Extending the previous example, see the ",(0,i.jsx)(t.code,{children:"requires: INPUT"})," below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"    pattern-sources:\n      - pattern: user_input\n        label: INPUT\n      - pattern: evil(...)\n        requires: INPUT\n        label: EVIL\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Combine labels using the ",(0,i.jsx)(t.code,{children:"requires"})," key. To combine labels, use Python Boolean operators. For example: ",(0,i.jsx)(t.code,{children:"requires: LABEL1 and not LABEL2"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"requires"})," key to restrict a taint sink in the same way as source:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"    pattern-sinks:\n      - pattern: sink(...)\n        requires: EVIL\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Semgrep accepts valid Python identifiers as labels."}),"\n",(0,i.jsxs)(t.li,{children:["Restrict a source to a subset of labels using the ",(0,i.jsx)(t.code,{children:"requires"})," key. You can combine more labels in the ",(0,i.jsx)(t.code,{children:"requires"})," key using Python Boolean operators. For example: ",(0,i.jsx)(t.code,{children:"requires: LABEL1 and not LABEL2"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Restrict a sink also. The extra taint is only produced if the source itself is tainted and satisfies the ",(0,i.jsx)(t.code,{children:"requires"})," formula."]}),"\n"]})}),"\n",(0,i.jsxs)(t.p,{children:["In the example below, let's say that ",(0,i.jsx)(t.code,{children:"user_input"})," is dangerous but only when it passes through the ",(0,i.jsx)(t.code,{children:"evil"})," function. This can be specified with taint labels as follows:"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=PwKY",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(t.h3,{id:"multiple-requires-expressions-in-taint-labels",children:["Multiple ",(0,i.jsx)(t.code,{children:"requires"})," expressions in taint labels"]}),"\n",(0,i.jsxs)(t.p,{children:["You can assign an independent ",(0,i.jsx)(t.code,{children:"requires"})," expression to each metavariable matched by a sink. Given ",(0,i.jsx)(t.code,{children:"$OBJ.foo($ARG)"})," you can easily require that ",(0,i.jsx)(t.code,{children:"$OBJ"})," has some label ",(0,i.jsx)(t.code,{children:"XYZ"})," and ",(0,i.jsx)(t.code,{children:"$ARG"})," has some label TAINTED, and at the same time ",(0,i.jsx)(t.code,{children:"focus-metavariable: $ARG"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"pattern-sinks:\n  - patterns:\n      - pattern: $OBJ.foo($SINK, $ARG)\n      - focus-metavariable: $SINK\n    requires:\n      - $SINK: BAD\n      - $OBJ: AAA\n      - $ARG: BBB\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);