"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[71986],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},28620:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contributing/cst-to-ast-tips","title":"Tips for converting CST to AST","description":"Once you have copied the generated Boilerplate.ml for your language","source":"@site/docs/contributing/cst-to-ast-tips.md","sourceDirName":"contributing","slug":"/contributing/cst-to-ast-tips","permalink":"/semgrep-docs/contributing/cst-to-ast-tips","draft":false,"unlisted":false,"editUrl":"https://github.com/semgrep/semgrep-docs/edit/main/docs/contributing/cst-to-ast-tips.md","tags":[],"version":"current","lastUpdatedAt":1708124289000,"frontMatter":{}}');var r=t(74848),s=t(28453);const o={},a="Tips for converting CST to AST",l={},c=[{value:"Use editor/IDE with good OCaml support",id:"use-editoride-with-good-ocaml-support",level:2},{value:"Editing the boilerplate",id:"editing-the-boilerplate",level:2},{value:"Study examples",id:"study-examples",level:3},{value:"Learn OCaml basics",id:"learn-ocaml-basics",level:3},{value:"Preserve structure, assign useful names",id:"preserve-structure-assign-useful-names",level:3},{value:"Compile regularly",id:"compile-regularly",level:2},{value:"Keep the boilerplate structure intact",id:"keep-the-boilerplate-structure-intact",level:2},{value:"Add type annotations",id:"add-type-annotations",level:2},{value:"Consult the original <code>grammar.js</code>",id:"consult-the-original-grammarjs",level:2},{value:"Extend the generic AST with moderation",id:"extend-the-generic-ast-with-moderation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tips-for-converting-cst-to-ast",children:"Tips for converting CST to AST"})}),"\n",(0,r.jsxs)(n.p,{children:["Once you have copied the generated ",(0,r.jsx)(n.code,{children:"Boilerplate.ml"})," for your language\n",(0,r.jsx)(n.code,{children:"foo"})," into ",(0,r.jsx)(n.code,{children:"Parse_foo_tree_sitter.ml"}),", you can start editing it. The\ngoal is replace all the calls like ",(0,r.jsx)(n.code,{children:"todo env x"})," by the construction\nof a node of the AST. The destination AST can be a language-specific\nAST or directly the generic AST. If we're mapping to a\nlanguage-specific AST, this language-specific AST needs to be created\nfirst. The advantage of going through a language-specific AST is more\nvisibility into which constructs are valid for the language, compared\nto the generic AST which supports many more constructs."]}),"\n",(0,r.jsx)(n.p,{children:"Besides writing and updating the tree-sitter grammar, this step is\nwhere the most time will be spent to integrate a language in semgrep.\nThis is a collection of tips to make this tedious task somewhat easier."}),"\n",(0,r.jsx)(n.h2,{id:"use-editoride-with-good-ocaml-support",children:"Use editor/IDE with good OCaml support"}),"\n",(0,r.jsx)(n.p,{children:"Make sure to set up your editor with a proper ocaml mode, so that you\ncan see the inferred type of expressions and get the ability to jump\nto the definitions."}),"\n",(0,r.jsx)(n.p,{children:"Popular editors include emacs, vim, vscode. They all have their own\nOCaml extension or plugin which relies on merlin."}),"\n",(0,r.jsx)(n.h2,{id:"editing-the-boilerplate",children:"Editing the boilerplate"}),"\n",(0,r.jsx)(n.h3,{id:"study-examples",children:"Study examples"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Parse_foo_tree_sitter.ml"})," is copied from the generated file\n",(0,r.jsx)(n.a,{href:"https://github.com/semgrep/semgrep-go/blob/main/lib/Boilerplate.ml",children:(0,r.jsx)(n.code,{children:"Boilerplate.ml"})}),". The ",(0,r.jsx)(n.code,{children:"todo env x"})," calls are typically replaced by the\nconstruction of a node of the AST.\nSee how it's done for example in ",(0,r.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/blob/develop/languages/go/tree-sitter/Parse_go_tree_sitter.ml",children:(0,r.jsx)(n.code,{children:"Parse_go_tree_sitter.ml"})}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"learn-ocaml-basics",children:"Learn OCaml basics"}),"\n",(0,r.jsxs)(n.p,{children:["CST and AST type definitions make heavy use of algebraic data types to\naccommodate nodes of different kinds under the same type.\nThose are known as variants (e.g. ",(0,r.jsx)(n.code,{children:"Expr e"}),") and\npolymorphic variants in OCaml jargon (e.g. ",(0,r.jsx)(n.code,{children:" `Expr e"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Parametrized types in OCaml are like generics in languages like Java.\nThe OCaml type for a list of ints is denoted ",(0,r.jsx)(n.code,{children:"int list"}),", which would\nbe denoted ",(0,r.jsx)(n.code,{children:"List<Int>"})," in a Java-like language."]}),"\n",(0,r.jsxs)(n.p,{children:["Run ",(0,r.jsx)(n.code,{children:"utop"})," (",(0,r.jsx)(n.code,{children:"opam install utop"}),") and go over ",(0,r.jsx)(n.a,{href:"https://ocaml.org/learn//tutorials/data_types_and_matching.html",children:"this tutorial about OCaml\ntypes at ocaml.org"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"preserve-structure-assign-useful-names",children:"Preserve structure, assign useful names"}),"\n",(0,r.jsxs)(n.p,{children:["Consider this example of typical generated code in ",(0,r.jsx)(n.code,{children:"Boilerplate.ml"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"let rec anon_choice_type_id_42c0412 (env : env) (x : CST.anon_choice_type_id_42c0412) =\n  match x with\n  | `Id tok -> [ identifier env tok ] (* identifier *)\n  | `Nested_id x -> nested_identifier env x\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The name ",(0,r.jsx)(n.code,{children:"anon_choice_type_id_42c0412"})," was generated from an anonymous\nnode in the grammar and it's not meaningful. However, it's used in multiple\nspots, which is why it has its own function definition. It occurs for example\nhere:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"    | `Choice_id_opt_type_args (v1, v2) ->\n        let v1 = anon_choice_type_id_42c0412 env v1 in\n        let id = concat_nested_identifier v1 in\n        let _v2 =\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Instead, it works better to give it a meaningful name like ",(0,r.jsx)(n.code,{children:"id_or_nested_id"})," as\nfollows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"let rec id_or_nested_id (env : env) (x : CST.anon_choice_type_id_42c0412) =\n  match x with\n  | `Id tok -> [ identifier env tok ] (* identifier *)\n  | `Nested_id x -> nested_identifier env x\n"})}),"\n",(0,r.jsx)(n.p,{children:"and replace it at every point of use. Now, the snippet where it's used\nmakes more sense:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"    | `Choice_id_opt_type_args (v1, v2) ->\n        let v1 = id_or_nested_id env v1 in\n        let id = concat_nested_identifier v1 in\n        let _v2 =\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Another helpful transformation is to assign a name to every new\nvalue instead of ",(0,r.jsx)(n.code,{children:"v1"}),", ",(0,r.jsx)(n.code,{children:"v2"}),", etc. The above snippet becomes something like"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"    | `Choice_id_opt_type_args (v1, v2) ->\n        let ids = id_or_nested_id env v1 in\n        let id = concat_nested_identifier ids in\n        let type_args =\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that we're still keeping the original ",(0,r.jsx)(n.code,{children:"v1"})," and ",(0,r.jsx)(n.code,{children:"v2"}),", because it's\nnot very useful to find names for them."]}),"\n",(0,r.jsx)(n.p,{children:"Finally, it is very useful to specify the return type of the function\nso as to figure out type errors a lot more easily."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"let rec id_or_nested_id (env : env) (x : CST.anon_choice_type_id_42c0412) =\n"})}),"\n",(0,r.jsx)(n.p,{children:"becomes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"let rec id_or_nested_id (env : env) (x : CST.anon_choice_type_id_42c0412) : ident =\n"})}),"\n",(0,r.jsx)(n.p,{children:"Summary:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Replace generated function names by something meaningful."}),"\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"let v1 ="})," by a meaningful name."]}),"\n",(0,r.jsx)(n.li,{children:"Specify the return type of functions that map CST to AST."}),"\n",(0,r.jsx)(n.li,{children:"Preserve the general structure of the generated functions."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This all helps with updating the code when the grammar changes."}),"\n",(0,r.jsx)(n.h2,{id:"compile-regularly",children:"Compile regularly"}),"\n",(0,r.jsx)(n.p,{children:"Compile regularly so as to perform type checking. This is general\nadvice for OCaml development. If you're working on a single file, you\ndon't need to recompile the project, though. Merlin will take care of\nchecking types when you save the file."}),"\n",(0,r.jsx)(n.p,{children:"The initial template with all the todos should compile successfully,\nbut of course will fail at runtime. Type errors produced by the\ncompiler can be tricky to understand but it's good to learn how to\ninterpret them. Sometimes they're just too long, though."}),"\n",(0,r.jsx)(n.h2,{id:"keep-the-boilerplate-structure-intact",children:"Keep the boilerplate structure intact"}),"\n",(0,r.jsx)(n.p,{children:"Leave the original structure in place as much as possible. This is\nimportant for later when we want to update the grammar and need to\ncompare the new boilerplate with the old/edited one."}),"\n",(0,r.jsx)(n.h2,{id:"add-type-annotations",children:"Add type annotations"}),"\n",(0,r.jsx)(n.p,{children:"The generated boilerplate looks like this, i.e. the return type is left\nunspecified."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"and formal_parameter (env : env) (x : CST.formal_parameter) =\n  ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"The return type will be an AST node determined by the programmer.\nOCaml performs full type inference, so it's not technically required\nto specify a return type.\nHowever, given the peculiar nature of this exercise, we recommend specifying\nreturn types. It makes it easier to see expectations and get clear error\nmessages when the time comes to upgrade the grammar. A return type annotation\nlooks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ocaml",children:"and formal_parameter (env : env) (x : CST.formal_parameter) : AST.parameter =\n  ...\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"consult-the-original-grammarjs",children:["Consult the original ",(0,r.jsx)(n.code,{children:"grammar.js"})]}),"\n",(0,r.jsxs)(n.p,{children:["The original ",(0,r.jsx)(n.code,{children:"grammar.js"}),", or sometimes another javascript file,\ncontains the bulk of the original rules for the grammar. This is\nusually a better reference than the generated code."]}),"\n",(0,r.jsxs)(n.p,{children:["The generated boilerplate ",(0,r.jsx)(n.code,{children:"Boilerplate.ml"})," is similar to the type definitions\n",(0,r.jsx)(n.code,{children:"CST.ml"})," which is our interpretation of the original\n",(0,r.jsx)(n.code,{children:"grammar.js"}),". So, it is useful to consult ",(0,r.jsx)(n.code,{children:"CST.ml"})," as well."]}),"\n",(0,r.jsx)(n.p,{children:"What tends to work well is to keep 4 windows open:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Parse_foo_tree_sitter.ml"})," (2 windows)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"grammar.js"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"AST_generic.ml"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The last file ",(0,r.jsx)(n.code,{children:"AST_generic.ml"})," contains the type definitions of the\nAST we're mapping to."]}),"\n",(0,r.jsx)(n.h2,{id:"extend-the-generic-ast-with-moderation",children:"Extend the generic AST with moderation"}),"\n",(0,r.jsx)(n.p,{children:"Each programming language comes with a few features that other\nlanguages don't offer, but typically not that many. The generic AST is\ndesigned to accommodate all the constructs for all the programming\nlanguages. So, we sometimes have to extend the generic AST with new\nkinds of nodes. We try to do so sparingly, since we try to keep the\ngeneric AST as simple as possible and it's already very rich."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);