"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[3405],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var i=s(96540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}},39793:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>o,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"writing-rules/experiments/join-mode/recursive-joins","title":"Recursive joins","description":"Join mode is an extension of Semgrep that runs multiple rules at once and only returns results if certain conditions are met. This is an experimental mode that enables you to cross file boundaries, allowing you to write rules for whole codebases instead of individual files. More information is available in Join mode overview.","source":"@site/docs/writing-rules/experiments/join-mode/recursive-joins.md","sourceDirName":"writing-rules/experiments/join-mode","slug":"/writing-rules/experiments/join-mode/recursive-joins","permalink":"/semgrep-docs/writing-rules/experiments/join-mode/recursive-joins","draft":false,"unlisted":false,"editUrl":"https://github.com/semgrep/semgrep-docs/edit/main/docs/writing-rules/experiments/join-mode/recursive-joins.md","tags":[],"version":"current","lastUpdatedAt":1715624161000,"frontMatter":{},"sidebar":"rulewritingSidebar","previous":{"title":"Join mode overview","permalink":"/semgrep-docs/writing-rules/experiments/join-mode/overview"},"next":{"title":"Including multiple focus metavariables using set union semantics","permalink":"/semgrep-docs/writing-rules/experiments/multiple-focus-metavariables"}}');var t=s(74848),r=s(28453);const l={},d="Recursive joins",c={},a=[{value:"Understanding recursive join mode",id:"understanding-recursive-join-mode",level:2},{value:"Example rule",id:"example-rule",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Use cases",id:"use-cases",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"recursive-joins",children:"Recursive joins"})}),"\n",(0,t.jsxs)(n.p,{children:["Join mode is an extension of Semgrep that runs multiple rules at once and only returns results if certain conditions are met. This is an experimental mode that enables you to cross file boundaries, allowing you to write rules for whole codebases instead of individual files. More information is available in ",(0,t.jsx)(n.a,{href:"/writing-rules/experiments/join-mode/overview",children:"Join mode overview"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Recursive join mode has a recursive operator, ",(0,t.jsx)(n.code,{children:"--\x3e"}),", which executes a recursive query on the given condition. This recursive operator allows you to write a Semgrep rule that effectively crawls the codebase on a condition you specify, letting you build chains such as function call chains or class inheritance chains."]}),"\n",(0,t.jsx)(n.h2,{id:"understanding-recursive-join-mode",children:"Understanding recursive join mode"}),"\n",(0,t.jsx)(n.p,{children:"In the background, join rules turn captured metavariables into database table columns. For example, a rule with $FUNCTIONNAME, $FUNCTIONCALLED, and $PARAMETER is a table similar to the following:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"$FUNCTIONNAME"}),(0,t.jsx)(n.th,{children:"$FUNCTIONCALLED"}),(0,t.jsx)(n.th,{children:"$PARAMETER"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"getName"}),(0,t.jsx)(n.td,{children:"writeOutput"}),(0,t.jsx)(n.td,{children:"user"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"getName"}),(0,t.jsx)(n.td,{children:"lookupUser"}),(0,t.jsx)(n.td,{children:"uid"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"lookupUser"}),(0,t.jsx)(n.td,{children:"databaseQuery"}),(0,t.jsx)(n.td,{children:"uid"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The join conditions then join various tables together and return a result if any rows match the criteria."}),"\n",(0,t.jsxs)(n.p,{children:["Recursive join mode conditions use ",(0,t.jsx)(n.a,{href:"https://www.sqlite.org/lang_with.html#recursive_common_table_expressions",children:"recursive joins"})," to construct a table that recursively joins with itself. For example, you can use a Semgrep rule that gets all function calls and join them recursively to approximate a callgraph."]}),"\n",(0,t.jsx)(n.p,{children:"Consider the following Python script and rule."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def function_1():\n    print("hello")\n    function_2()\n\ndef function_2():\n    function_4()\n\ndef function_3():\n    function_5()\n\ndef function_4():\n    function_5()\n\ndef function_5():\n    print("goodbye")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: python-callgraph\n  message: python callgraph\n  languages: [python]\n  severity: INFO\n  pattern: |\n    def $CALLER(...):\n      ...\n      $CALLEE(...)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A join condition such as the following: ",(0,t.jsx)(n.code,{children:"python-callgraph.$CALLER --\x3e python-callgraph.$CALLEE"})," produces a table below. Notice how ",(0,t.jsx)(n.code,{children:"function_1"})," appears with ",(0,t.jsx)(n.code,{children:"function_4"})," and ",(0,t.jsx)(n.code,{children:"function_5"})," as callees, even though it is not directly called."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"$CALLER"}),(0,t.jsx)(n.th,{children:"$CALLEE"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_1"}),(0,t.jsx)(n.td,{children:"function_2"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_1"}),(0,t.jsx)(n.td,{children:"function_4"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_1"}),(0,t.jsx)(n.td,{children:"function_5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_1"}),(0,t.jsx)(n.td,{children:"print"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_2"}),(0,t.jsx)(n.td,{children:"function_4"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_2"}),(0,t.jsx)(n.td,{children:"function_5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_3"}),(0,t.jsx)(n.td,{children:"function_5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_4"}),(0,t.jsx)(n.td,{children:"function_5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"function_5"}),(0,t.jsx)(n.td,{children:"print"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"example-rule",children:"Example rule"}),"\n",(0,t.jsx)(n.p,{children:'It\'s important to think of a join mode rule as "asking questions about the whole project", rather than looking for a single pattern. For example, to find an SQL injection, you need to understand a few things about the project:'}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Is there any user input?"}),"\n",(0,t.jsx)(n.li,{children:"Do any functions manually build an SQL string using function input?"}),"\n",(0,t.jsx)(n.li,{children:"Can the user input reach the function that manually builds the SQL string?"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Now, you can write individual Semgrep rules that gather information about each of these questions. This example uses ",(0,t.jsx)(n.a,{href:"https://github.com/ScaleSec/vulnado",children:"Vulnado"})," for finding an SQL injection. Vulnado is a Spring application."]}),"\n",(0,t.jsx)(n.p,{children:"The first rule searches for user input into the Spring application. This rule also captures sinks that use a user-inputtable parameter as an argument."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: java-spring-user-input\n  message: user input\n  languages: [java]\n  severity: INFO\n  mode: taint\n  pattern-sources:\n  - pattern: |\n      @RequestMapping(...)\n      $RETURNTYPE $USERINPUTMETHOD(..., $TYPE $PARAMETER, ...) {\n        ...\n      }\n  pattern-sinks:\n  - patterns:\n    - pattern: $OBJ.$SINK(...)\n    - pattern: $PARAMETER\n"})}),"\n",(0,t.jsx)(n.p,{children:"A second rule looks for all methods in the application that build an SQL string with a method parameter."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: method-parameter-formatted-sql\n  message: method uses parameter for sql string\n  languages: [java]\n  severity: INFO\n  patterns:\n  - pattern-inside: |\n      $RETURNTYPE $METHODNAME(..., $TYPE $PARAMETER, ...) {\n        ...\n      }\n  - patterns:\n    - pattern-either:\n      - pattern: |\n          "$SQLSTATEMENT" + $PARAMETER\n      - pattern: |\n          String.format("$SQLSTATEMENT", ..., $PARAMETER, ...)\n    - metavariable-regex:\n        metavariable: $SQLSTATEMENT\n        regex: (?i)(select|delete|insert).*\n'})}),"\n",(0,t.jsx)(n.p,{children:"Finally, the third rule is used to construct a pseudo-callgraph:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: java-callgraph\n  languages: [java]\n  severity: INFO\n  message: $CALLER calls $OBJ.$CALLEE\n  patterns:\n  - pattern-inside: |\n      $TYPE $CALLER(...) {\n        ...\n      }\n  - pattern: $OBJ.$CALLEE(...)\n"})}),"\n",(0,t.jsx)(n.p,{children:"The join rule, is displayed as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: spring-sql-injection\n  message: SQLi\n  severity: ERROR\n  mode: join\n  join:\n    refs:\n    - rule: rule_parts/java-spring-user-input.yaml\n      as: user-input\n    - rule: rule_parts/method-parameter-formatted-sql.yaml\n      as: formatted-sql\n    - rule: rule_parts/java-callgraph.yaml\n      as: callgraph\n    on:\n    - 'callgraph.$CALLER --\x3e callgraph.$CALLEE'\n    - 'user-input.$SINK == callgraph.$CALLER'\n    - 'callgraph.$CALLEE == formatted-sql.$METHODNAME'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"on:"})," conditions, in order, read as follows:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Recursively generate a pseudo callgraph on $CALLER to $CALLEE."}),"\n",(0,t.jsx)(n.li,{children:"Match when a method with user input has a $SINK that is the $CALLER in the pseudo-callgraph."}),"\n",(0,t.jsx)(n.li,{children:"Match when the $CALLEE is the $METHODNAME of a method that uses a parameter to construct an SQL string."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Running this on Vulnado produces tables that look like this:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"$RETURNTYPE"}),(0,t.jsx)(n.th,{children:"$USERINPUTMETHOD"}),(0,t.jsx)(n.th,{children:"$TYPE"}),(0,t.jsx)(n.th,{children:"$PARAMETER"}),(0,t.jsx)(n.th,{children:"$OBJ"}),(0,t.jsx)(n.th,{children:"$SINK"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LoginResponse"}),(0,t.jsx)(n.td,{children:"login"}),(0,t.jsx)(n.td,{children:"LoginRequest"}),(0,t.jsx)(n.td,{children:"input"}),(0,t.jsx)(n.td,{children:"user"}),(0,t.jsx)(n.td,{children:"token"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LoginResponse"}),(0,t.jsx)(n.td,{children:"login"}),(0,t.jsx)(n.td,{children:"LoginRequest"}),(0,t.jsx)(n.td,{children:"input"}),(0,t.jsx)(n.td,{children:"User"}),(0,t.jsx)(n.td,{children:"getUser"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"$RETURNTYPE"}),(0,t.jsx)(n.th,{children:"$METHODNAME"}),(0,t.jsx)(n.th,{children:"$TYPE"}),(0,t.jsx)(n.th,{children:"$PARAMETER"}),(0,t.jsx)(n.th,{children:"$SQLSTATEMENT"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"User"}),(0,t.jsx)(n.td,{children:"fetch"}),(0,t.jsx)(n.td,{children:"String"}),(0,t.jsx)(n.td,{children:"un"}),(0,t.jsx)(n.td,{children:"select * from users where username = '"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"$CALLER"}),(0,t.jsx)(n.th,{children:"$CALLEE"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"login"}),(0,t.jsx)(n.td,{children:"getUser"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"login"}),(0,t.jsx)(n.td,{children:"fetch"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"getUser"}),(0,t.jsx)(n.td,{children:"fetch"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The join conditions select rows which meet the conditions."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Match when a method with user input has a $SINK that is the $CALLER in the pseudo-callgraph."}),"\n"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"..."}),(0,t.jsx)(n.th,{children:"user-input.$SINK"}),(0,t.jsx)(n.th,{children:"=="}),(0,t.jsx)(n.th,{children:"callgraph.$CALLER"}),(0,t.jsx)(n.th,{children:"..."})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"getUser"}),(0,t.jsx)(n.td,{children:"=="}),(0,t.jsx)(n.td,{children:"getUser"}),(0,t.jsx)(n.td,{children:"..."})]})})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Match when the $CALLEE is the $METHODNAME of a method that uses a parameter to construct an SQL string."}),"\n"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"..."}),(0,t.jsx)(n.th,{children:"callgraph.$CALLEE"}),(0,t.jsx)(n.th,{children:"=="}),(0,t.jsx)(n.th,{children:"formatted-sql.$METHODNAME"}),(0,t.jsx)(n.th,{children:"..."})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"..."}),(0,t.jsx)(n.td,{children:"fetch"}),(0,t.jsx)(n.td,{children:"=="}),(0,t.jsx)(n.td,{children:"fetch"}),(0,t.jsx)(n.td,{children:"..."})]})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-console",children:'(semgrep) \u279c  join_mode_demo semgrep -f vulnado-sqli.yaml vulnado\nRunning 1 rules...\nRunning 3 rules...\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588|3/3\nran 3 rules on 11 files: 158 findings\nvulnado/src/main/java/com/scalesec/vulnado/User.java\nrule:spring-sql-injection: SQLi\n55:      String query = "select * from users where username = \'" + un + "\' limit 1";\nran 0 rules on 0 files: 1 findings\n'})}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.p,{children:"Join mode only works on the metavariable contents, which means it's fundamentally operating with text strings and not code constructs. There will be some false positives if similarly-named metavariables are extracted."}),"\n",(0,t.jsx)(n.h2,{id:"use-cases",children:"Use cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Approximating callgraphs in a project"}),"\n",(0,t.jsx)(n.li,{children:"Approximating class inheritance"}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);