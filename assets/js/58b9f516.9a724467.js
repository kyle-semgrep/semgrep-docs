"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[50017],{26134:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>i});var a=t(74848),s=t(28453);const i=[];function r(e){const n={a:"a",admonition:"admonition",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In principle, the data-flow analysis engine (which provides taint tracking, constant propagation, and symbolic propagation) can run on any language ",(0,a.jsx)(n.a,{href:"/docs/supported-languages",children:"supported by Semgrep"}),". However, the level of support is lower than for the regular Semgrep matching engine."]}),"\n",(0,a.jsxs)(n.p,{children:["When Semgrep performs an analysis of the code, it creates an ",(0,a.jsx)(n.strong,{children:"abstract syntax tree"})," (AST) which is then translated into an analysis-friendly ",(0,a.jsx)(n.strong,{children:"intermediate language"})," (IL). Subsequently, Semgrep runs mostly language-agnostic analysis on IL. However, this translation is not fully complete."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsx)(n.p,{children:"There can be features of some languages that Semgrep does not analyze correctly while using data-flow analysis. Consequently, Semgrep does not fail even if it finds an unsupported construct. The analysis continues while the construct is ignored. This can result in Semgrep not matching some code that should be matched (false negatives) or matching a code that should not be matched (false positives)."})}),"\n",(0,a.jsxs)(n.p,{children:["Please, help us to improve and report any issues you encounter by creating an issue on Semgrep ",(0,a.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/issues/new/choose",children:"GitHub"})," page."]})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},67376:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"writing-rules/data-flow/data-flow-overview","title":"Data-flow analysis engine overview","description":"Semgrep can run data-flow analyses on your code, this is used for constant propagation and for taint tracking.","source":"@site/docs/writing-rules/data-flow/data-flow-overview.md","sourceDirName":"writing-rules/data-flow","slug":"/writing-rules/data-flow/data-flow-overview","permalink":"/docs/writing-rules/data-flow/data-flow-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/writing-rules/data-flow/data-flow-overview.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752253235000,"frontMatter":{"slug":"data-flow-overview","append_help_link":true,"description":"Semgrep can run data-flow analyses on your code, this is used for constant propagation and for taint tracking.","sidebar_label":"Engine overview","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Deprecated experiments","permalink":"/docs/writing-rules/experiments/deprecated-experiments"},"next":{"title":"Constant propagation","permalink":"/docs/writing-rules/data-flow/constant-propagation"}}');var s=t(74848),i=t(28453),r=t(26134);const o={slug:"data-flow-overview",append_help_link:!0,description:"Semgrep can run data-flow analyses on your code, this is used for constant propagation and for taint tracking.",sidebar_label:"Engine overview",tags:["Rule writing"]},l="Data-flow analysis engine overview",d={},c=[{value:"Design trade-offs",id:"design-trade-offs",level:2},{value:"Data-flow status",id:"data-flow-status",level:2},...r.RM];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"data-flow-analysis-engine-overview",children:"Data-flow analysis engine overview"})}),"\n",(0,s.jsx)(n.p,{children:"Semgrep provides an intra-procedural data-flow analysis engine that opens various Semgrep capabilities. Semgrep provides the following data-flow analyses:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/writing-rules/data-flow/constant-propagation",children:"Constant propagation"})," allows Semgrep to, for example, match ",(0,s.jsx)(n.code,{children:"return 42"})," against ",(0,s.jsx)(n.code,{children:"return x"})," when ",(0,s.jsx)(n.code,{children:"x"})," can be reduced to ",(0,s.jsx)(n.code,{children:"42"})," by constant folding. There is also a specific experimental feature of ",(0,s.jsx)(n.a,{href:"/writing-rules/data-flow/constant-propagation",children:"Constant propagation"}),", called ",(0,s.jsx)(n.a,{href:"/writing-rules/experiments/symbolic-propagation",children:"Symbolic propagation"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/writing-rules/data-flow/taint-mode/",children:"Taint tracking (known also as taint analysis)"})," enables you to write simple rules that catch complex ",(0,s.jsx)(n.a,{href:"https://owasp.org/www-community/Injection_Flaws",children:"injection bugs"}),", such as those that can result in ",(0,s.jsx)(n.a,{href:"https://owasp.org/www-community/attacks/xss/",children:"cross-site scripting (XSS)"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In principle, all data flow related features are available for any of Semgrep's ",(0,s.jsx)(n.a,{href:"/supported-languages",children:"supported languages"}),". Interfile (cross-file) analysis also supports data-flow analysis. For more details, see ",(0,s.jsxs)(n.a,{href:"/semgrep-code/semgrep-pro-engine-intro",children:[(0,s.jsx)("i",{class:"fa-regular fa-file-lines"})," Perform cross-file analysis"]})," documentation."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Ensure that you understand the ",(0,s.jsx)(n.a,{href:"#design-trade-offs",children:"design trade-offs"})," and limitations of the data-flow engine. For further details, see also the ",(0,s.jsx)(n.a,{href:"#data-flow-status",children:"data-flow status"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["Semgrep provides no user-friendly way of specifying a new data-flow analysis. Please ",(0,s.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/issues/new/choose",children:"let us know if you have suggestions"}),". If you can code in OCaml, your contribution is welcome. See ",(0,s.jsx)(n.a,{href:"/contributing/contributing",children:"Contributing"})," documentation for more details."]}),"\n",(0,s.jsx)(n.h2,{id:"design-trade-offs",children:"Design trade-offs"}),"\n",(0,s.jsx)(n.p,{children:"Semgrep strives for simplicity and delivers a lightweight, and fast static analysis. In addition to being intra-procedural, here are some other trade-offs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["No path sensitivity: All ",(0,s.jsx)(n.em,{children:"potential"})," execution paths are considered, despite that some may not be feasible."]}),"\n",(0,s.jsxs)(n.li,{children:["No pointer or shape analysis: ",(0,s.jsx)(n.em,{children:"Aliasing"})," that happens in non-trivial ways may not be detected, such as through arrays or pointers. Individual elements in arrays or other data structures are not tracked. The dataflow engine supports limited field sensitivity for taint tracking, but not yet for constant propagation."]}),"\n",(0,s.jsxs)(n.li,{children:["No soundness guarantees: Semgrep ignores the effects of ",(0,s.jsx)(n.code,{children:"eval"}),'-like functions on the program state. It doesn\u2019t make worst-case sound assumptions, but rather "reasonable" ones.']}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Expect both false positives and false negatives. You can remove false positives in different ways, for example, using ",(0,s.jsx)(n.a,{href:"/writing-rules/rule-syntax#pattern-not",children:"pattern-not"})," and ",(0,s.jsx)(n.a,{href:"/writing-rules/rule-syntax#pattern-not-inside",children:"pattern-not-inside"}),". We want to provide you with a way of eliminating false positives, so ",(0,s.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/issues/new/choose",children:"create an issue"})," if run into any problems. We are happy to trade false negatives for simplicity and fewer false positives, but you are welcome to open a feature request if Semgrep misses some difficult bug you want to catch."]}),"\n",(0,s.jsx)(n.h2,{id:"data-flow-status",children:"Data-flow status"}),"\n",(0,s.jsx)(r.Ay,{})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);