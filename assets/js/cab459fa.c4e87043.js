"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[42568],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},67772:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/join-mode-example-4973e0f47741f0d4c628eb668bc8f3ba.png"},71101:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"writing-rules/experiments/join-mode/overview","title":"Join mode overview","description":"Join mode runs several Semgrep rules at once and only returns results if certain conditions on the results are met.","source":"@site/docs/writing-rules/experiments/join-mode/overview.md","sourceDirName":"writing-rules/experiments/join-mode","slug":"/writing-rules/experiments/join-mode/overview","permalink":"/docs/writing-rules/experiments/join-mode/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/experiments/join-mode/overview.md","tags":[],"version":"current","lastUpdatedAt":1752252315000,"frontMatter":{"id":"overview","append_help_link":true,"description":"Join mode runs several Semgrep rules at once and only returns results if certain conditions on the results are met."},"sidebar":"rulewritingSidebar","previous":{"title":"Displaying propagated value of metavariables","permalink":"/docs/writing-rules/experiments/display-propagated-metavariable"},"next":{"title":"Recursive joins","permalink":"/docs/writing-rules/experiments/join-mode/recursive-joins"}}');var r=s(74848),t=s(28453);const l={id:"overview",append_help_link:!0,description:"Join mode runs several Semgrep rules at once and only returns results if certain conditions on the results are met."},o="Join mode overview",a={},d=[{value:"Example",id:"example",level:2},{value:"Syntax",id:"syntax",level:2},{value:"<code>join</code>",id:"join",level:3},{value:"Inline rule example",id:"inline-rule-example",level:4},{value:"<code>refs</code>",id:"refs",level:3},{value:"<code>rule</code>",id:"rule",level:3},{value:"<code>renames</code>",id:"renames",level:3},{value:"<code>as</code>",id:"as",level:3},{value:"<code>on</code>",id:"on",level:3},{value:"Limitations",id:"limitations",level:2},{value:"More ideas",id:"more-ideas",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"join-mode-overview",children:"Join mode overview"})}),"\n",(0,r.jsx)(n.p,{children:"Join mode runs several Semgrep rules at once and only returns results if certain conditions on the results are met. Join mode is an experimental mode that lets you cross file boundaries, allowing you to write rules for whole code bases instead of individual files. As the name implies, this was inspired by join clauses in SQL queries."}),"\n",(0,r.jsx)(n.p,{children:"Think of join mode like this: distinct Semgrep rules are used to gather information about a code base. Then, the conditions you define are used to select specific results from these rules, and the selected results are reported by Semgrep. You can join results on metavariable contents or on the result's file path."}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["You can also use cross-file (interfile) analysis. For more information, see ",(0,r.jsxs)(n.a,{href:"/semgrep-code/semgrep-pro-engine-intro",children:[(0,r.jsx)("i",{class:"fa-regular fa-file-lines"})," Perform cross-file analysis"]}),". Cross-file analysis is preferred over join mode where either of the two are feasible. Neither is currently available in Semgrep CE."]})}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:"Here\u2019s an example join mode rule that detects a cross-site scripting (XSS) vulnerability with high precision."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: flask-likely-xss\n  mode: join\n  join:\n    refs:\n      - rule: flask-user-input.yaml\n        as: user-input\n      - rule: unescaped-template-extension.yaml\n        as: unescaped-extensions\n      - rule: any-template-var.yaml\n        renames:\n        - from: '$...EXPR'\n          to: '$VAR'\n        as: template-vars\n    on:\n    - 'user-input.$VAR == unescaped-extensions.$VALUE'\n    - 'unescaped-extensions.$VAR == template-vars.$VAR'\n    - 'unescaped-extensions.$PATH > template-vars.path'\n  message: |\n    Detected a XSS vulnerability: '$VAR' is rendered\n    unsafely in '$PATH'.\n  severity: ERROR\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's explore how this works. First, some background on the vulnerability. Second, we'll walk through the join mode rule."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vulnerability background"})}),"\n",(0,r.jsxs)(n.p,{children:["In Flask, templates are only HTML-escaped if the ",(0,r.jsxs)(n.a,{href:"https://flask.palletsprojects.com/en/2.0.x/templating/#jinja-setup",children:["template file ends with the ",(0,r.jsx)(n.code,{children:".html"})," extension"]}),". Therefore, detecting these two conditions present in a Flask application is a high indicator of"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["User input directly enters a template without the ",(0,r.jsx)(n.code,{children:".html"})," extension"]}),"\n",(0,r.jsx)(n.li,{children:"The user input is directly rendered in the template"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Join mode rule explanation"})}),"\n",(0,r.jsx)(n.p,{children:"Now, let's turn these conditions into the join mode rule.  We need to find three code patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"User input"}),"\n",(0,r.jsxs)(n.li,{children:["Templates without the ",(0,r.jsx)(n.code,{children:".html"})," extension"]}),"\n",(0,r.jsx)(n.li,{children:"Variables rendered in a template"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We can write individual Semgrep rules for each of these code patterns."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: flask-user-input\n  languages: [python]\n  severity: INFO\n  message: $VAR\n  pattern: '$VAR = flask.request.$SOMETHING.get(...)'\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'rules:\n- id: unescaped-template-extension\n  message: |\n    Flask does not automatically escape Jinja templates unless they have\n    .html as an extension. This could lead to XSS attacks.\n  patterns:\n  - pattern: flask.render_template("$PATH", ..., $VAR=$VALUE, ...)\n  - metavariable-pattern:\n      metavariable: $PATH\n      language: generic\n      patterns:\n      - pattern-not-regex: .*\\.html$\n  languages: [python]\n  severity: WARNING\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: any-template-var\n  languages: [generic]\n  severity: INFO\n  message: '$...EXPR'\n  pattern: '{{ $...EXPR }}'\n"})}),"\n",(0,r.jsx)(n.p,{children:'Finally, we want to "join" the results from these together. Below are the join conditions, in plain language.'}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The variable ",(0,r.jsx)(n.code,{children:"$VAR"})," from ",(0,r.jsx)(n.code,{children:"flask-user-input"})," has the same content as the value ",(0,r.jsx)(n.code,{children:"$VALUE"})," from ",(0,r.jsx)(n.code,{children:"unescaped-template-extension"})]}),"\n",(0,r.jsxs)(n.li,{children:["The keyword argument ",(0,r.jsx)(n.code,{children:"$VAR"})," from ",(0,r.jsx)(n.code,{children:"unescaped-template-extension"})," has the same content as ",(0,r.jsx)(n.code,{children:"$...EXPR"})," from ",(0,r.jsx)(n.code,{children:"any-template-var"})]}),"\n",(0,r.jsxs)(n.li,{children:["The template file name ",(0,r.jsx)(n.code,{children:"$PATH"})," from ",(0,r.jsx)(n.code,{children:"unescaped-template-extension"})," is a substring of the file path of a result from ",(0,r.jsx)(n.code,{children:"any-template-var"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We can translate these roughly into the following condition statements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"- 'user-input.$VAR == unescaped-extensions.$VALUE'\n- 'unescaped-extensions.$VAR == template-vars.$VAR'\n- 'unescaped-extensions.$PATH > template-vars.path'\n"})}),"\n",(0,r.jsx)(n.p,{children:"Combining the three code pattern Semgrep rules and the three conditions gives us the join rule at the top of this section. This rule matches the code displayed below."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Screenshot of code the join rule matches",src:s(67772).A+"",width:"1904",height:"1596"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"> semgrep -f flask-likely-xss.yaml\nrunning 1 rules...\nrunning 3 rules...\nran 3 rules on 16 files: 14 findings\nmatching...\nmatching done.\n./templates/launch.htm.j2\nseverity:error rule:flask-likely-xss: Detected a XSS vulnerability: '$VAR' is rendered unsafely in '$PATH'.\n9:\t<li>person_name_full is <b>{{ person_name_full }}</b></li>\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Helpers"})}),"\n",(0,r.jsxs)(n.p,{children:["For convenience, when writing a join mode rule, you can use the ",(0,r.jsx)(n.code,{children:"renames"})," and ",(0,r.jsx)(n.code,{children:"as"})," keys."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"renames"})," key lets you rename metavariables from one rule to something else in your conditions. ",(0,r.jsxs)(n.strong,{children:["This is necessary for named expressions, e.g., ",(0,r.jsx)(n.code,{children:"$...EXPR"}),"."]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"as"})," key behaves similarly to ",(0,r.jsx)(n.code,{children:"AS"})," clauses in SQL. This lets you rename the result set for use in the conditions. If the ",(0,r.jsx)(n.code,{children:"as"})," key is not specified, the result set uses the ",(0,r.jsx)(n.strong,{children:"rule ID"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.h3,{id:"join",children:(0,r.jsx)(n.code,{children:"join"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"join"})," key is required when in join mode. This is just a top-level key that groups the join rule parts together."]}),"\n",(0,r.jsx)(n.h4,{id:"inline-rule-example",children:"Inline rule example"}),"\n",(0,r.jsx)(n.p,{children:"The following rule attempts to detect cross-site scripting in a Flask application by checking whether a template variable is rendered unsafely through Python code."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: flask-likely-xss\n  mode: join\n  join:\n    rules:\n      - id: user-input\n        pattern: |\n          $VAR = flask.request.$SOMETHING.get(...)\n        languages: [python]\n      - id: unescaped-extensions\n        languages: [python]\n        patterns:\n        - pattern: |\n            flask.render_template(\"$TEMPLATE\", ..., $KWARG=$VAR, ...)\n        - metavariable-pattern:\n            metavariable: $TEMPLATE\n            language: generic\n            patterns:\n            - pattern-not-regex: .*\\.html$\n      - id: template-vars\n        languages: [generic]\n        pattern: |\n          {{ $VAR }}\n    on:\n    - 'user-input.$VAR == unescaped-extensions.$VAR'\n    - 'unescaped-extensions.$KWARG == template-vars.$VAR'\n    - 'unescaped-extensions.$TEMPLATE < template-vars.path'\n  message: |\n    Detected a XSS vulnerability: '$VAR' is rendered\n    unsafely in '$TEMPLATE'.\n  severity: ERROR\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The required fields under the ",(0,r.jsx)(n.code,{children:"rules"})," key are the following:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"id"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"languages"})}),"\n",(0,r.jsxs)(n.li,{children:["A set of ",(0,r.jsx)(n.code,{children:"pattern"})," clauses."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The optional fields under the ",(0,r.jsx)(n.code,{children:"rules"})," key are the following:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"message"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"severity"})}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Refer to the metavariables captured by the rule in the ",(0,r.jsx)(n.code,{children:"on"})," conditions by the rule ",(0,r.jsx)(n.code,{children:"id"}),". For inline rules, aliases do ",(0,r.jsx)(n.strong,{children:"not"})," work."]})}),"\n",(0,r.jsx)(n.h3,{id:"refs",children:(0,r.jsx)(n.code,{children:"refs"})}),"\n",(0,r.jsxs)(n.p,{children:["Short for references, ",(0,r.jsx)(n.code,{children:"refs"})," is a list of external rules that make up your code patterns. Each entry in ",(0,r.jsx)(n.code,{children:"refs"})," is an object with the required key ",(0,r.jsx)(n.code,{children:"rule"})," and optional keys ",(0,r.jsx)(n.code,{children:"renames"})," and ",(0,r.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"rule",children:(0,r.jsx)(n.code,{children:"rule"})}),"\n",(0,r.jsxs)(n.p,{children:["Used with ",(0,r.jsx)(n.code,{children:"refs"}),", ",(0,r.jsx)(n.code,{children:"rule"})," points to an external rule location to use in this join rule. Even though Semgrep rule files can typically contain multiple rules under the ",(0,r.jsx)(n.code,{children:"rules"})," key, join mode ",(0,r.jsx)(n.strong,{children:"only uses the first rule in the provided file"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Anything that works with ",(0,r.jsx)(n.code,{children:"semgrep --config <here>"})," also works as the value for ",(0,r.jsx)(n.code,{children:"rule"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"renames",children:(0,r.jsx)(n.code,{children:"renames"})}),"\n",(0,r.jsxs)(n.p,{children:["An optional key for an object in ",(0,r.jsx)(n.code,{children:"refs"}),", ",(0,r.jsx)(n.code,{children:"renames"})," renames the metavariables from the associated ",(0,r.jsx)(n.code,{children:"rule"}),". The value of ",(0,r.jsx)(n.code,{children:"renames"})," is a list of objects whose keys are ",(0,r.jsx)(n.code,{children:"from"})," and ",(0,r.jsx)(n.code,{children:"to"}),". The ",(0,r.jsx)(n.code,{children:"from"})," key specifies the metavariable to rename, and the ",(0,r.jsx)(n.code,{children:"to"})," key specifies the new name of the metavariable."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Renaming is necessary for named expressions, e.g., ",(0,r.jsx)(n.code,{children:"$...EXPR"}),"."]})}),"\n",(0,r.jsx)(n.h3,{id:"as",children:(0,r.jsx)(n.code,{children:"as"})}),"\n",(0,r.jsxs)(n.p,{children:["An optional key for an object in ",(0,r.jsx)(n.code,{children:"refs"}),", ",(0,r.jsx)(n.code,{children:"as"})," lets you specify an alias for the results collected by this rule for use in the ",(0,r.jsx)(n.code,{children:"on"})," conditions. Without the ",(0,r.jsx)(n.code,{children:"as"})," key, the default name for the results collected by this rule is the rule ID of the rule in ",(0,r.jsx)(n.code,{children:"rule"}),". If you use ",(0,r.jsx)(n.code,{children:"as"}),", the results can be referenced using the alias specified by ",(0,r.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"on",children:(0,r.jsx)(n.code,{children:"on"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"on"})," key is required in join mode. This is where the join conditions are listed. The value of ",(0,r.jsx)(n.code,{children:"on"})," is a list of strings which have the format:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<result_set>.<property> <operator> <result_set>.<property>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"result_set"})," is the name of the result set produced by one of the ",(0,r.jsx)(n.code,{children:"refs"}),". See the ",(0,r.jsx)(n.code,{children:"as"})," key for more information."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"property"})," is either a metavariable, such as ",(0,r.jsx)(n.code,{children:"$VAR"}),", or the keyword ",(0,r.jsx)(n.code,{children:"path"}),", which returns the path of the finding."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"operator"})," is one of the following."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operator"}),(0,r.jsx)(n.th,{children:"Example"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"=="})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"secret-env-var.$VALUE == log-statement.$FORMATVAR"})}),(0,r.jsx)(n.td,{children:"Matches when the contents of both sides are exactly equal."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"!="})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"url-allowlist.$URL != get-request.$URL"})}),(0,r.jsx)(n.td,{children:"Matches when the contents of both sides are not equal."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"<"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"template-var.path < unsafe-template.$PATH"})}),(0,r.jsx)(n.td,{children:"Matches when the right-hand side is a substring of the left-hand side."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:">"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"unsafe-template.$PATH > template-var.path"})}),(0,r.jsx)(n.td,{children:"Matches when the left-hand side is a substring of the right-hand side."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(n.p,{children:["Join mode ",(0,r.jsx)(n.strong,{children:"is not taint mode"}),'! While it can look on the surface like join mode is "connecting" things together, it is actually just creating sets for each Semgrep rule and returning all the results that meet the conditions. This means some false positives will occur if unrelated metavariable contents happen to have the same value.']}),"\n",(0,r.jsxs)(n.p,{children:["To use join mode with ",(0,r.jsx)(n.code,{children:"refs"}),", you must define your individual Semgrep rules in independent locations. This can be anything that works with ",(0,r.jsx)(n.code,{children:"semgrep --config <here>"}),", such as a file, a URL, or a Semgrep registry pointer like ",(0,r.jsx)(n.code,{children:"r/java.lang.security.some.rule.id"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Join mode requires login, and does not work in the Semgrep Playground or Semgrep Editor, as it is an experimental feature."}),"\n",(0,r.jsxs)(n.p,{children:["Currently, join mode only reports the code location of the ",(0,r.jsx)(n.strong,{children:"last finding that matches the conditions"}),'. Join mode parses the conditions from top-to-bottom, left-to-right. This means that findings from the "bottom-right" condition become the reported code location.']}),"\n",(0,r.jsx)(n.h2,{id:"more-ideas",children:"More ideas"}),"\n",(0,r.jsx)(n.p,{children:"Join mode effectively lets you ask questions of entire code bases. Here are some examples of the kinds of questions you can use join mode to answer."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Do any of my dependencies use ",(0,r.jsx)(n.code,{children:"dangerouslySetInnerHTML"}),", and do I directly import that dependency?"]}),"\n",(0,r.jsx)(n.li,{children:"Does a key in this JSON file have a dangerous value, and do I load this JSON file and use the key in a dangerous function?"}),"\n",(0,r.jsx)(n.li,{children:"Is an unsafe variable rendered in an HTML template?"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);