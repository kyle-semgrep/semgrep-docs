"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[39843],{2651:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"semgrep-code/remove-duplicates","title":"Remove duplicate findings","description":"Learn how to remove duplicate findings and prevent them from being displayed in Semgrep AppSec Platform.","source":"@site/docs/semgrep-code/remove-duplicates.md","sourceDirName":"semgrep-code","slug":"/semgrep-code/remove-duplicates","permalink":"/semgrep-docs/semgrep-code/remove-duplicates","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/semgrep-code/remove-duplicates.md","tags":[{"inline":true,"label":"Semgrep Code","permalink":"/semgrep-docs/tags/semgrep-code"},{"inline":true,"label":"Semgrep AppSec Platform","permalink":"/semgrep-docs/tags/semgrep-app-sec-platform"}],"version":"current","lastUpdatedAt":1752262761000,"frontMatter":{"slug":"remove-duplicates","append_help_link":true,"title":"Remove duplicate findings","hide_title":true,"description":"Learn how to remove duplicate findings and prevent them from being displayed in Semgrep AppSec Platform.","tags":["Semgrep Code","Semgrep AppSec Platform"]},"sidebar":"scanSidebar","previous":{"title":"Cross-file analysis examples","permalink":"/semgrep-docs/semgrep-code/semgrep-pro-engine-examples"},"next":{"title":"Write custom rules","permalink":"/semgrep-docs/semgrep-code/editor"}}');var s=i(74848),d=i(28453);const r={slug:"remove-duplicates",append_help_link:!0,title:"Remove duplicate findings",hide_title:!0,description:"Learn how to remove duplicate findings and prevent them from being displayed in Semgrep AppSec Platform.",tags:["Semgrep Code","Semgrep AppSec Platform"]},a="Remove duplicate findings",o={},c=[{value:"How Semgrep distinguishes between new and duplicate findings",id:"how-semgrep-distinguishes-between-new-and-duplicate-findings",level:2},{value:"<code>match_based_id</code>",id:"match_based_id",level:3},{value:"<code>syntactic_id</code>",id:"syntactic_id",level:3},{value:"Update findings by rescanning the project",id:"update-findings-by-rescanning-the-project",level:2},{value:"Remove duplicate findings using Semgrep API",id:"remove-duplicate-findings-using-semgrep-api",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"remove-duplicate-findings",children:"Remove duplicate findings"})}),"\n",(0,s.jsx)(n.p,{children:"Semgrep scans are performed on both mainline (trunk) and non-mainline branches. The scope of the scan can differ depending on if Semgrep is called on a mainline or non-mainline branch."}),"\n",(0,s.jsxs)("dl",{children:[(0,s.jsx)("dt",{children:"Full scan"}),(0,s.jsxs)("dd",{children:["Scans the repository in its entirety. It is recommended to perform full scans on mainline branches, such as ",(0,s.jsx)("code",{children:"master"})," or ",(0,s.jsx)("code",{children:"main"}),". Full scans are typically performed on a scheduled basis or on merge to a default branch."]}),(0,s.jsx)("dt",{children:"Diff-aware scan"}),(0,s.jsx)("dd",{children:"Diff-aware scans are performed on non-mainline branches, such as in pull requests and merge requests. Diff-aware scans traverse the repository's files based on the commit where the branch diverged from the mainline branch."})]}),"\n",(0,s.jsx)(n.h2,{id:"how-semgrep-distinguishes-between-new-and-duplicate-findings",children:"How Semgrep distinguishes between new and duplicate findings"}),"\n",(0,s.jsxs)(n.p,{children:["Semgrep generates a finding whenever it scans a repository and one of its rules matches a piece of code. Since Semgrep usually scans a repository multiple times, it needs a way to track the same finding in a file over time. Semgrep does this using two types of fingerprints: ",(0,s.jsx)(n.code,{children:"match_based_id"})," and ",(0,s.jsx)(n.code,{children:"syntactic_id"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"The calculations used to determine whether findings are new are subject to change at any time as Semgrep improves its deduplication logic."})}),"\n",(0,s.jsx)(n.h3,{id:"match_based_id",children:(0,s.jsx)(n.code,{children:"match_based_id"})}),"\n",(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.code,{children:"match_based_id"}),", Semgrep can determine if a given finding in a file is the same as a finding identified during a different scan, even if the code snippet that the rule matched had been moved to a different location in the file. This allows Semgrep to avoid generating a new finding and to deduplicate its records accordingly, even across multiple branches associated with the project. It also means that Semgrep can cross-correlate findings, so a finding that has been triaged in one branch will be flagged as triaged if it's identified in another branch."]}),"\n",(0,s.jsxs)(n.p,{children:["Semgrep generates the ",(0,s.jsx)(n.code,{children:"match_based_id"})," for a finding using the following information:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The file path"}),"\n",(0,s.jsx)(n.li,{children:"The name of the rule that generated the finding"}),"\n",(0,s.jsx)(n.li,{children:"The rule pattern with the metavariables' values substituted in"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This information is combined and then hashed. At this point, Semgrep appends the ",(0,s.jsx)(n.strong,{children:"index"}),", a value generated by determining the number of times the rule involved matched code in the file. Note that the index is appended to the hash, not combined with the other finding information before hashing. This is done to preserve information on how findings are related. For example, ",(0,s.jsx)(n.code,{children:"finding0"})," with ",(0,s.jsx)(n.code,{children:"match_based_id = 123_0"})," and ",(0,s.jsx)(n.code,{children:"finding1"})," with ",(0,s.jsx)(n.code,{children:"match_based_id = 123_1"})," indicate that both were generated from the same rule matching the same code pattern in the same file."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Semgrep AppSec Platform groups together findings on different branches",src:i(97598).A+"",width:"1307",height:"502"}),"\n",(0,s.jsxs)(n.em,{children:[(0,s.jsx)(n.strong,{children:"Figure"}),". Semgrep AppSec Platform groups together the same finding identified as present on multiple branches."]})]}),"\n",(0,s.jsx)(n.p,{children:"Semgrep uses the rule pattern with the metavariables' values, which originate from the code itself, substituted in to generate match_based_id. Therefore, code changes that result in the same rule pattern when abstracted to the level of the rule pattern match, with the appropriate values substituted, in don't hinder Semgrep's ability to recognize that the finding isn't a duplicate of an existing finding."}),"\n",(0,s.jsx)(n.p,{children:"For example, if the original file scanned is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'a = 1\nb = 2\nspcd.get("foo")\nc = 3\nd = 4\nsink("foo")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The rule pattern identified and used in generating the ",(0,s.jsx)(n.code,{children:"match_based_id"})," is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"spcd.get($X)\n...\nsink($X)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Which, with metavariables substituted in, becomes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'spcd.get("foo")\n...\nsink("foo")\n'})}),"\n",(0,s.jsx)(n.p,{children:"If the following change is made to the original file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'a = 1\nb = 2\nspcd.get("foo")\nc = 3\nc_1 = 5\nd = 4\nsink("foo")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The rule pattern identified and used in generating the ",(0,s.jsx)(n.code,{children:"match_based_id"})," doesn't change:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'spcd.get("foo")\n...\nsink("foo")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This means that the ",(0,s.jsx)(n.code,{children:"match_based_id"})," itself doesn't change, allowing Semgrep to identify that the two findings are the same and to deduplicate them. Furthermore, this process enables Semgrep to ignore lines that do not impact code function."]}),"\n",(0,s.jsx)(n.h3,{id:"syntactic_id",children:(0,s.jsx)(n.code,{children:"syntactic_id"})}),"\n",(0,s.jsxs)(n.p,{children:["Semgrep generates the ",(0,s.jsx)(n.code,{children:"syntactic_id"})," for a finding using the following information:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The file path"}),"\n",(0,s.jsx)(n.li,{children:"The name of the rule that generated the finding"}),"\n",(0,s.jsx)(n.li,{children:"The code syntax, or the literal piece of code that matched the rule"}),"\n",(0,s.jsx)(n.li,{children:"The index, a value generated by determining the number of times the rule involved matched code in the file"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This information is combined and then hashed for privacy before being stored."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"syntactic_id"})," is primarily used by Semgrep for internal debugging purposes, since no code is stored except in cases where you have provided code access permissions to Semgrep."]})}),"\n",(0,s.jsx)(n.h2,{id:"update-findings-by-rescanning-the-project",children:"Update findings by rescanning the project"}),"\n",(0,s.jsx)(n.p,{children:"Semgrep's correlation of findings across branches based on their unique fingerprint allows for automatic consolidation of findings and makes it simpler to triage findings."}),"\n",(0,s.jsxs)(n.p,{children:["If a finding is fixed in one branch (such as ",(0,s.jsx)(n.code,{children:"main"}),"), possibly because there hasn't been a follow-up scan on the branch, but open in another (such as ",(0,s.jsx)(n.code,{children:"production"}),"), and the code fixes are present in both branches, initiate scans through your CI job or SCM tool on the branches with open findings. Semgrep will reconcile the findings and mark them as fixed."]}),"\n",(0,s.jsx)(n.h2,{id:"remove-duplicate-findings-using-semgrep-api",children:"Remove duplicate findings using Semgrep API"}),"\n",(0,s.jsxs)(n.p,{children:["Semgrep API does not automatically group findings with the same match-based ID across branches. If you use Semgrep API to receive or pull findings data, set the ",(0,s.jsx)(n.code,{children:"dedup"})," flag to ",(0,s.jsx)(n.code,{children:"true"})," to deduplicate findings across refs or branches. Refer to ",(0,s.jsx)(n.a,{href:"https://semgrep.dev/api/v1/docs/#tag/Finding/operation/semgrep_app.saas.handlers.issue.openapi_list_recent_issues",children:"List all findings"})," in the Semgrep API docs for more information."]})]})}function l(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const s={},d=t.createContext(s);function r(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(d.Provider,{value:n},e.children)}},97598:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/matched-findings-f6c633be5d7bdd6d69ec3395bc1278e5.png"}}]);