"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[50661],{21364:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"kb/semgrep-code/finding_all_taints","title":"Why isn\u2019t Semgrep reporting all my tainted data flows?","description":"One of the reasons behind seeing fewer than expected tainted data flows could be the principle of reporting on shortest paths only.","source":"@site/docs/kb/semgrep-code/finding_all_taints.md","sourceDirName":"kb/semgrep-code","slug":"/kb/semgrep-code/finding_all_taints","permalink":"/semgrep-docs/kb/semgrep-code/finding_all_taints","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/kb/semgrep-code/finding_all_taints.md","tags":[],"version":"current","lastUpdatedAt":1752254305000,"frontMatter":{},"sidebar":"kbSidebar","previous":{"title":"How to collect logs when running Semgrep in CLI","permalink":"/semgrep-docs/kb/semgrep-code/collect-cli-logs"},"next":{"title":"My GitLab pipeline says that the token is invalid, but it is valid","permalink":"/semgrep-docs/kb/semgrep-code/gitlab-group-variables"}}');var i=n(74848),s=n(28453);const o={},r="Why isn\u2019t Semgrep reporting all my tainted data flows?",l={},d=[{value:"Analysis of two tainted data flows",id:"analysis-of-two-tainted-data-flows",level:2},{value:"Interfile analysis",id:"interfile-analysis",level:3},{value:"Intrafile analysis",id:"intrafile-analysis",level:3},{value:"Best practices for testing tainted data flows",id:"best-practices-for-testing-tainted-data-flows",level:2},{value:"Dry runs",id:"dry-runs",level:3},{value:"Sample taint data-flow reporting",id:"sample-taint-data-flow-reporting",level:4},{value:"Changing Pro analysis options",id:"changing-pro-analysis-options",level:3},{value:"Altering the paths",id:"altering-the-paths",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"why-isnt-semgrep-reporting-all-my-tainted-data-flows",children:"Why isn\u2019t Semgrep reporting all my tainted data flows?"})}),"\n",(0,i.jsx)(t.p,{children:"One of the reasons behind seeing fewer than expected tainted data flows could be the principle of reporting on shortest paths only."}),"\n",(0,i.jsx)(t.p,{children:"By default, Semgrep reports a tainted source-sink permutation only once and reports the data flow that traverses the shortest path. Any longer paths with the same source-sink combination are not shown."}),"\n",(0,i.jsx)(t.h2,{id:"analysis-of-two-tainted-data-flows",children:"Analysis of two tainted data flows"}),"\n",(0,i.jsx)(t.p,{children:"Take a look at these two examples:"}),"\n",(0,i.jsx)(t.p,{children:"Call stack 1:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"File2 function2(sourceA) \n      >> File1 function1(sourceA/sinkB)\n"})}),"\n",(0,i.jsx)(t.p,{children:"Call stack 2:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"File 1 function4(sourceA) \n       >> function3(sourceA) \n          >> function2(sourceA) \n             >> function1(sourceA/sinkB)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"interfile-analysis",children:"Interfile analysis"}),"\n",(0,i.jsxs)(t.p,{children:["If both tainted data flows are identified in the same scan, and the scan has interfile analysis enabled (",(0,i.jsx)(t.code,{children:"--pro"}),", or Pro Engine enabled in the Cloud Platform), only Call stack 1 is reported as a finding. It has a shorter path, and has the same sourceA -> sinkB taint."]}),"\n",(0,i.jsx)(t.p,{children:"This speeds up triage by ensuring you are only reviewing unique findings. It's especially useful for languages with polymorphic classes that can add noise for a singleton taint."}),"\n",(0,i.jsx)(t.h3,{id:"intrafile-analysis",children:"Intrafile analysis"}),"\n",(0,i.jsxs)(t.p,{children:["If only intrafile / interprocedural analysis is performed (",(0,i.jsx)(t.code,{children:"--pro-intrafile"}),"), Semgrep only reports a finding for call stack 2. Call stack 1 would not be identified, because it crosses file boundaries."]}),"\n",(0,i.jsx)(t.h2,{id:"best-practices-for-testing-tainted-data-flows",children:"Best practices for testing tainted data flows"}),"\n",(0,i.jsx)(t.p,{children:"To understand in greater detail how Semgrep detects tainted data flows, you can use your own test cases to review different paths."}),"\n",(0,i.jsx)(t.h3,{id:"dry-runs",children:"Dry runs"}),"\n",(0,i.jsxs)(t.p,{children:["To avoid sending test data to Semgrep AppSec Platform and potentially confounding existing findings, use ",(0,i.jsx)(t.code,{children:"semgrep scan"})," or ",(0,i.jsx)(t.code,{children:"semgrep ci --dry-run"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["When testing locally, adding ",(0,i.jsx)(t.code,{children:"--dataflow-traces"})," allows you to see the taint traces as you would in the Semgrep AppSec Platform UI."]}),"\n",(0,i.jsx)(t.h4,{id:"sample-taint-data-flow-reporting",children:"Sample taint data-flow reporting"}),"\n",(0,i.jsx)(t.p,{children:"The following is an example that shows dataflow traces traversing multiple files, demonstrating interfile taint tracking:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"test2.java\n\xa0\xa0\xa0\xa0test-spring-insecure-bean-validation\n\xa0\xa0\xa0\xa0\xa0Passing user input to context.buildConstraintViolationWithTemplate() function may lead to\n\xa0\xa0\xa0\xa0\xa0execution of arbitary commands.\n\n\xa0\xa0\xa0\xa0\xa0\xa08\u2506\xa0context.buildConstraintViolationWithTemplate(template).addConstraintViolation();\n\n\xa0\xa0\xa0\xa0\xa0\xa0Taint comes from:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0test1.java\n\xa0\xa0\xa0\xa0\xa0\xa0128\u2506\xa0 @Override\n\xa0\xa0\xa0\xa0\xa0\xa0129\u2506\n\xa0\xa0\xa0\xa0\xa0\xa0130\u2506\xa0\xa0 public boolean isValid1234(MessageParticipantsDto messageParticipantsDto,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\nConstraintValidatorContext context)\xa0{\n\n\xa0\xa0\xa0\xa0\xa0\xa0Taint flows through these intermediate variables:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0test1.java\n\xa0\xa0\xa0\xa0\xa0\xa0130\u2506\xa0 public boolean isValid1234(MessageParticipantsDto messageParticipantsDto,\n\xa0ConstraintValidatorContext context)\xa0{\n\n\xa0\xa0\xa0\xa0\xa0\xa0This is how taint reaches the sink:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0test1.java\n\xa0\xa0\xa0\xa0\xa0\xa0156\u2506\xa0\xa0\xa0\xa0\xa0 return ValidationUtil.buildTemplate(context, templateList);\n\xa0\xa0\xa0\xa0\xa0\xa0Taint flows through these intermediate variables:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa05\u2506 public boolean buildTemplate(ConstraintValidatorContext\xa0context, List<String> templateList) {\n\xa0\xa0\xa0\xa0\xa0\xa0then reaches:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa08\u2506\xa0context.buildConstraintViolationWithTemplate(template).addConstraintViolation();\n"})}),"\n",(0,i.jsx)(t.h3,{id:"changing-pro-analysis-options",children:"Changing Pro analysis options"}),"\n",(0,i.jsxs)(t.p,{children:["You can change whether you are using the ",(0,i.jsx)(t.code,{children:"--pro"})," or ",(0,i.jsx)(t.code,{children:"--pro-intrafile"})," option depending on the exact flow you're testing, as described in the preceding section, ",(0,i.jsx)(t.a,{href:"#analysis-of-two-tainted-data-flows",children:"Analysis of two tainted data flows"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"altering-the-paths",children:"Altering the paths"}),"\n",(0,i.jsx)(t.p,{children:"To ensure you see all the flow options, start by testing the shortest path and then change the code so that the shortest path is no longer tainted. Repeat this until you have achieved the longest taint flow path you want to test."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(96540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);