"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[44805],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},36995:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"writing-rules/generic-pattern-matching","title":"Generic pattern matching","description":"Semgrep can match generic patterns in languages that it doesn\u2019t support yet. You can use generic pattern matching for languages that do **not** have a parser, configuration files, or other structured data such as XML.","source":"@site/docs/writing-rules/generic-pattern-matching.md","sourceDirName":"writing-rules","slug":"/writing-rules/generic-pattern-matching","permalink":"/semgrep-docs/writing-rules/generic-pattern-matching","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/generic-pattern-matching.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1753214405000,"frontMatter":{"append_help_link":true,"description":"Semgrep can match generic patterns in languages that it doesn\u2019t support yet. You can use generic pattern matching for languages that do **not** have a parser, configuration files, or other structured data such as XML.","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Autofix","permalink":"/semgrep-docs/writing-rules/autofix"},"next":{"title":"Metavariable analysis","permalink":"/semgrep-docs/writing-rules/metavariable-analysis"}}');var i=s(74848),r=s(28453);const a={append_help_link:!0,description:"Semgrep can match generic patterns in languages that it doesn\u2019t support yet. You can use generic pattern matching for languages that do **not** have a parser, configuration files, or other structured data such as XML.",tags:["Rule writing"]},o="Generic pattern matching",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Caveats and limitations of generic mode",id:"caveats-and-limitations-of-generic-mode",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common pitfall #1: not enough <code>...</code>",id:"common-pitfall-1-not-enough-",level:3},{value:"Common pitfall #2: not enough indentation",id:"common-pitfall-2-not-enough-indentation",level:3},{value:"Handling line-based input",id:"handling-line-based-input",level:3},{value:"Ignoring comments",id:"ignoring-comments",level:3},{value:"Command line example",id:"command-line-example",level:2},{value:"Semgrep Registry rules for generic pattern matching",id:"semgrep-registry-rules-for-generic-pattern-matching",level:2},{value:"Cheat sheet",id:"cheat-sheet",level:2},{value:"Hidden bonus",id:"hidden-bonus",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"generic-pattern-matching",children:"Generic pattern matching"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep can match generic patterns in languages that it does ",(0,i.jsx)(n.strong,{children:"not"})," yet support. Use generic pattern matching for languages that do not have a parser, configuration files, or other structured data such as XML. Generic pattern matching can also be useful in files containing multiple languages even if the languages are otherwise supported, such as HTML with embedded JavaScript or PHP code. In those cases you can also consider ",(0,i.jsx)(n.a,{href:"/writing-rules/experiments/deprecated-experiments#extract-mode",children:"Extract mode (experimental)"}),", but generic patterns may be simpler and still effective."]}),"\n",(0,i.jsx)(n.p,{children:"As an example of generic matching, consider this rule:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: dynamic-proxy-scheme\n    pattern: proxy_pass $$SCHEME:// ...;\n    paths:\n      include:\n        - "*.conf"\n        - "*.vhost"\n        - sites-available/*\n        - sites-enabled/*\n    languages:\n      - generic\n    severity: WARNING\n    message: >-\n      The protocol scheme for this proxy is dynamically determined.\n      This can be dangerous if the scheme is injected by an\n      attacker because it may forcibly alter the connection scheme.\n      Consider hardcoding a scheme for this proxy.\n    metadata:\n      references:\n        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md\n      category: security\n      technology:\n        - nginx\n      confidence: MEDIUM\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above rule ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/playground/r/generic.nginx.security.dynamic-proxy-scheme.dynamic-proxy-scheme",children:"matches"})," this code snippet:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"server {\n  listen              443 ssl;\n  server_name         www.example.com;\n  keepalive_timeout   70;\n\n  ssl_certificate     www.example.com.crt;\n  ssl_certificate_key www.example.com.key;\n\n  location ~ /proxy/(.*)/(.*)/(.*)$ {\n    # ruleid: dynamic-proxy-scheme\n    proxy_pass $1://$2/$3;\n  }\n\n  location ~* ^/internal-proxy/(?<proxy_proto>https?)/(?<proxy_host>.*?)/(?<proxy_path>.*)$ {\n    internal;\n\n    # ruleid: dynamic-proxy-scheme\n    proxy_pass $proxy_proto://$proxy_host/$proxy_path ;\n    proxy_set_header Host $proxy_host;\n}\n\n  location ~ /proxy/(.*)/(.*)/(.*)$ {\n    # ok: dynamic-proxy-scheme\n    proxy_pass http://$1/$2/$3;\n  }\n\n  location ~ /proxy/(.*)/(.*)/(.*)$ {\n    # ok: dynamic-proxy-scheme\n    proxy_pass https://$1/$2/$3;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Generic pattern matching has the following properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A document is interpreted as a nested sequence of ASCII words, ASCII punctuation, and other bytes."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"..."})," (ellipsis operator) allows skipping non-matching elements, up to 10 lines down the last match."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$X"})," (metavariable) matches any word."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$...X"})," (ellipsis metavariable) matches a sequence of words, up to 10 lines down the last match."]}),"\n",(0,i.jsx)(n.li,{children:"Indentation determines primary nesting in the document."}),"\n",(0,i.jsxs)(n.li,{children:["Common ASCII braces ",(0,i.jsx)(n.code,{children:"()"}),", ",(0,i.jsx)(n.code,{children:"[]"}),", and ",(0,i.jsx)(n.code,{children:"{}"})," introduce secondary nesting but only within single lines. Therefore, misinterpreted or mismatched braces don't disturb the structure of the rest of document."]}),"\n",(0,i.jsx)(n.li,{children:"The document must be at least as indented as the pattern: any indentation specified in the pattern must be honored in the document."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"caveats-and-limitations-of-generic-mode",children:"Caveats and limitations of generic mode"}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep can reliably understand the syntax of natively ",(0,i.jsx)(n.a,{href:"/supported-languages",children:"supported languages"}),". The generic mode is useful for unsupported languages, and consequently brings specific limitations."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"The quality of results in the generic mode can vary depending on the language you use it for."})}),"\n",(0,i.jsx)(n.p,{children:"The generic mode works fine with any human-readable text, as long as it is primarily based on ASCII symbols. Since the generic mode does not understand the syntax of the language you are scanning, the quality of the result may differ from language to language or even depend on specific code. As a consequence, the generic mode works well for some languages, but it does not always give consistent results. Generally, it's possible or even easy to write code in weird ways that prevent generic mode from matching."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": In XML, one can write ",(0,i.jsx)(n.code,{children:"&#x48;&#x65;&#x6C;&#x6C;&#x6F"})," instead of ",(0,i.jsx)(n.code,{children:"Hello"}),". If a rule pattern in generic mode is ",(0,i.jsx)(n.code,{children:"Hello"}),", Semgrep is unable to match the ",(0,i.jsx)(n.code,{children:"&#x48;&#x65;&#x6C;&#x6C;&#x6F"}),", unlike if it had full XML support."]}),"\n",(0,i.jsx)(n.p,{children:"With respect to Semgrep operators and features:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["metavariable support is limited to capturing a single \u201cword\u201d, which is a token of the form [A-Za-z0-9_]+. They can\u2019t capture sequences of tokens such as hello, world (in this case there are 3 tokens: ",(0,i.jsx)(n.code,{children:"hello"}),", ",(0,i.jsx)(n.code,{children:","}),", and ",(0,i.jsx)(n.code,{children:"world"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"the ellipsis operator is supported and spans at most 10 lines"}),"\n",(0,i.jsx)(n.li,{children:"pattern operators like either/not/inside are supported"}),"\n",(0,i.jsxs)(n.li,{children:["inline regular expressions for strings (",(0,i.jsx)(n.code,{children:'"=~/word.*/"'}),") are not supported"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsxs)(n.h3,{id:"common-pitfall-1-not-enough-",children:["Common pitfall #1: not enough ",(0,i.jsx)(n.code,{children:"..."})]}),"\n",(0,i.jsx)(n.p,{children:"Rule of thumb:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["If the pattern commonly matches many lines, use ",(0,i.jsx)(n.code,{children:"... ..."})," (20 lines), or ",(0,i.jsx)(n.code,{children:"... ... ..."})," (30 lines) etc. to make sure to match all the lines."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Here's an innocuous pattern that should match the call to a function ",(0,i.jsx)(n.code,{children:"f()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"f(...)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It matches the following code ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/9v9R",children:"just fine"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"f(\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But it will ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/1z6Q",children:"fail"})," here because the function arguments span more than 10 lines:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"f(\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/9v9R",children:"solution"})," is to use multiple ",(0,i.jsx)(n.code,{children:"..."})," in the pattern:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"f(... ...)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"common-pitfall-2-not-enough-indentation",children:"Common pitfall #2: not enough indentation"}),"\n",(0,i.jsx)(n.p,{children:"Rule of thumb:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"If the target code is always indented, use indentation in the pattern."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we want to match the ",(0,i.jsx)(n.code,{children:"system"})," sections containing a ",(0,i.jsx)(n.code,{children:"name"})," field:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# match here\n[system]\n  name = "Debian"\n\n# DON\'T match here\n[system]\n  max_threads = 2\n[user]\n  name = "Admin Overlord"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u274c This pattern will ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/ry1A",children:"incorrectly"})," catch the ",(0,i.jsx)(n.code,{children:"name"})," field in the ",(0,i.jsx)(n.code,{children:"user"})," section:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[system]\n...\nname = ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 This pattern will catch ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/bXAr",children:"only"})," the ",(0,i.jsx)(n.code,{children:"name"})," field in the ",(0,i.jsx)(n.code,{children:"system"})," section:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[system]\n  ...\n  name = ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-line-based-input",children:"Handling line-based input"}),"\n",(0,i.jsxs)(n.p,{children:["This section explains how to use Semgrep's generic mode to match\nsingle lines of code using an ellipsis metavariable. Many simple\nconfiguration formats are collections of key and value pairs delimited\nby newlines. For example, to extract the ",(0,i.jsx)(n.code,{children:"password"})," value from the\nfollowing made-up input:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"username = bob\npassword = p@$$w0rd\nserver = example.com\n"})}),"\n",(0,i.jsx)(n.p,{children:"Unfortunately, the following pattern does not match the whole line. In generic mode, metavariables only capture a single word (alphanumeric sequence):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"password = $PASSWORD\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This pattern matches the input file but does not assign the value ",(0,i.jsx)(n.code,{children:"p"})," to ",(0,i.jsx)(n.code,{children:"$PASSWORD"})," instead of the full value ",(0,i.jsx)(n.code,{children:"p@$$w0rd"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"To match an arbitrary sequence of items and capture their value in the example:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Use a named ellipsis, by changing the pattern to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"password = $...PASSWORD\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This still leads Semgrep to capture too much information. The value assigned to ",(0,i.jsx)(n.code,{children:"$...PASSWORD"})," are now ",(0,i.jsx)(n.code,{children:"p@$$w0rd"})," and",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.code,{children:"server = example.com"}),". In generic mode, an ellipsis extends until the end of the current block or up to 10 lines below, whichever comes first. To prevent this behavior, continue with the next step."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"In the Semgrep rule, specify the following key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"generic_ellipsis_max_span: 0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This option forces the ellipsis operator to match patterns within a single line.\nExample of the ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/playground/s/KPzn",children:"resulting rule"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"id: password-in-config-file\npattern: |\n  password = $...PASSWORD\noptions:\n  # prevent ellipses from matching multiple lines\n  generic_ellipsis_max_span: 0\nmessage: |\n  password found in config file: $...PASSWORD\nlanguages:\n  - generic\nseverity: WARNING\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"ignoring-comments",children:"Ignoring comments"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the generic mode does ",(0,i.jsx)(n.strong,{children:"not"})," know about comments or code\nthat can be ignored. In the following example, we are\nscanning for CSS code that sets the text color to blue. The target code\nis the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"color: /* my fave color */ blue;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#options",children:(0,i.jsx)(n.code,{children:"options.generic_comment_style"})}),"\nto ignore C-style comments as it is the case in our example.\nOur simple Semgrep rule is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"id: css-blue-is-ugly\npattern: |\n  color: blue\noptions:\n  # ignore comments of the form /* ... */\n  generic_comment_style: c\nmessage: |\n  Blue is ugly.\nlanguages:\n  - generic\nseverity: WARNING\n"})}),"\n",(0,i.jsx)(n.h2,{id:"command-line-example",children:"Command line example"}),"\n",(0,i.jsxs)(n.p,{children:["Sample pattern: ",(0,i.jsx)(n.code,{children:"exec(...)"})]}),"\n",(0,i.jsxs)(n.p,{children:["Sample target file ",(0,i.jsx)(n.code,{children:"exec.txt"})," contains:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'import exec as safe_function\nsafe_function(user_input)\n\nexec("ls")\n\nexec(some_var)\n\nsome_exec(foo)\n\nexec (foo)\n\nexec (\n    bar\n)\n\n# exec(foo)\n\nprint("exec(bar)")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ semgrep -l generic -e \'exec(...)` exec.text\n7:exec("ls")\n--------------------------------------------------------------------------------\n11:exec(some_var)\n--------------------------------------------------------------------------------\n19:exec (foo)\n--------------------------------------------------------------------------------\n23:exec (\n24:128\n25: \xa0 \xa0bar\n26:129\n27:)\n--------------------------------------------------------------------------------\n31:# exec(foo)\n--------------------------------------------------------------------------------\n35:print("exec(bar)")\nran 1 rules on 1 files: 6 findings\n'})}),"\n",(0,i.jsx)(n.h2,{id:"semgrep-registry-rules-for-generic-pattern-matching",children:"Semgrep Registry rules for generic pattern matching"}),"\n",(0,i.jsxs)(n.p,{children:["You can peruse ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/r?lang=generic&sev=ERROR,WARNING,INFO&tag=dgryski.semgrep-go,hazanasec.semgrep-rules,ajinabraham.njsscan,best-practice,security,java-spring,go-stdlib,ruby-stdlib,java-stdlib,js-node,nodejsscan,owasp,dlint,react,performance,compatibility,portability,correctness,maintainability,secuirty,mongodb,experimental,caching,robots-denied,missing-noreferrer,missing-noopener",children:"existing generic rules"})," in the Semgrep registry. In general, short patterns on structured data will perform the best."]}),"\n",(0,i.jsx)(n.h2,{id:"cheat-sheet",children:"Cheat sheet"}),"\n",(0,i.jsxs)(n.p,{children:["Some examples of what will and will not match on the ",(0,i.jsx)(n.code,{children:"generic"})," tab of the Semgrep cheat sheet below:"]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/cheatsheet",scrolling:"0",width:"100%",height:"800",frameBorder:"0"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"hidden-bonus",children:"Hidden bonus"}),"\n",(0,i.jsxs)(n.p,{children:["In the Semgrep code the generic pattern matching implementation is called ",(0,i.jsx)(n.strong,{children:"spacegrep"})," because it tokenizes based on whitespace (and because it sounds cool \ud83d\ude0e)."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);