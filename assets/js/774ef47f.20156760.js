"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[73969],{7490:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"writing-rules/testing-rules","title":"Testing rules","description":"Semgrep provides a convenient testing mechanism for your rules. You can simply write code and provide a few annotations to let Semgrep know where you are or aren\'t expecting findings.","source":"@site/docs/writing-rules/testing-rules.md","sourceDirName":"writing-rules","slug":"/writing-rules/testing-rules","permalink":"/semgrep-docs/writing-rules/testing-rules","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/testing-rules.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1753214405000,"frontMatter":{"append_help_link":true,"slug":"testing-rules","description":"Semgrep provides a convenient testing mechanism for your rules. You can simply write code and provide a few annotations to let Semgrep know where you are or aren\'t expecting findings.","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Rule syntax","permalink":"/semgrep-docs/writing-rules/rule-syntax"},"next":{"title":"Private rules","permalink":"/semgrep-docs/writing-rules/private-rules"}}');var i=t(74848),r=t(28453),l=t(68021);const o={append_help_link:!0,slug:"testing-rules",description:"Semgrep provides a convenient testing mechanism for your rules. You can simply write code and provide a few annotations to let Semgrep know where you are or aren't expecting findings.",tags:["Rule writing"]},a="Testing rules",d={},c=[{value:"Testing autofix",id:"testing-autofix",level:2},{value:"Example",id:"example",level:2},{value:"Storing rules and test targets in different directories",id:"storing-rules-and-test-targets-in-different-directories",level:2},{value:"Validating rules",id:"validating-rules",level:2},{value:"Enabling autofix in Semgrep Code",id:"enabling-autofix-in-semgrep-code",level:2},...l.RM];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"testing-rules",children:"Testing rules"})}),"\n",(0,i.jsx)(n.p,{children:"Semgrep provides a convenient testing mechanism for your rules. You can simply write code and provide a few annotations to let Semgrep know where you are or aren't expecting findings. Semgrep provides the following annotations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ruleid: <rule-id>"}),", for protecting against false negatives"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ok: <rule-id>"})," for protecting against false positives"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"todoruleid: <rule-id>"}),' for future "positive" rule improvements']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"todook: <rule-id>"}),' for future "negative" rule improvements']}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Other than annotations there are three things to remember when creating tests:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"--test"})," flag tells Semgrep to run tests in the specified directory."]}),"\n",(0,i.jsx)(n.li,{children:"Annotations are specified as a comment above the offending line."}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep looks for tests based on the rule filename and the languages\nspecified in the rule. In other words, ",(0,i.jsx)(n.code,{children:"path/to/rule.yaml"})," searches for\n",(0,i.jsx)(n.code,{children:"path/to/rule.py"}),", ",(0,i.jsx)(n.code,{children:"path/to/rule.js"})," and similar, based on the languages specified in the rule."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:".test.yaml"})," file extension can also be used for test files. This is necessary when testing YAML language rules."]})}),"\n",(0,i.jsx)(n.h2,{id:"testing-autofix",children:"Testing autofix"}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep's testing mechanism also provides a way to test the behavior of any ",(0,i.jsx)(n.code,{children:"fix"})," values defined in the rules."]}),"\n",(0,i.jsx)(n.p,{children:"To define a test for autofix behavior:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a new ",(0,i.jsx)(n.strong,{children:"autofix test file"})," with the ",(0,i.jsx)(n.code,{children:".fixed"})," suffix before the file type extension.\nFor example, name the autofix test file of a rule with test code in ",(0,i.jsx)(n.code,{children:"path/to/rule.py"})," as ",(0,i.jsx)(n.code,{children:"path/to/rule.fixed.py"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Within the autofix test file, enter the expected result of applied autofix rule to the test code."}),"\n",(0,i.jsxs)(n.li,{children:["Run ",(0,i.jsx)(n.code,{children:"semgrep --test"})," to verify that your autofix test file is correctly detected."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When you use ",(0,i.jsx)(n.code,{children:"semgrep --test"}),", Semgrep applies the autofix rule to the original test code (",(0,i.jsx)(n.code,{children:"path/to/rule.py"}),"), and then verifies whether this matches the expected outcome defined in the autofix test file (",(0,i.jsx)(n.code,{children:"path/to/rule.fixed.py)"}),". If there is a mismatch, the line diffs are printed."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Hint"}),": Creating an autofix test for a rule with autofix can take less than a minute with the following flow of commands:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"cp rule.py rule.fixed.py\nsemgrep --config rule.yaml rule.fixed.py --autofix\n"})}),(0,i.jsxs)(n.p,{children:["These commands apply the autofix of the rule to the test code. After Semgrep delivers a fix, inspect whether the outcome of this fix looks as expected (for example using ",(0,i.jsx)(n.code,{children:"vimdiff rule.py rule.fixed.py"}),")."]})]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:"Consider the following rule:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: insecure-eval-use\n  patterns:\n  - pattern: eval($VAR)\n  - pattern-not: eval(\"...\")\n  fix: secure_eval($VAR)\n  message: Calling 'eval' with user input\n  languages: [python]\n  severity: WARNING\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Given the above is named ",(0,i.jsx)(n.code,{children:"rules/detect-eval.yaml"}),", you can create ",(0,i.jsx)(n.code,{children:"rules/detect-eval.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from lib import get_user_input, safe_get_user_input, secure_eval\n\nuser_input = get_user_input()\n# ruleid: insecure-eval-use\neval(user_input)\n\n# ok: insecure-eval-use\neval('print(\"Hardcoded eval\")')\n\ntotally_safe_eval = eval\n# todoruleid: insecure-eval-use\ntotally_safe_eval(user_input)\n\n# todook: insecure-eval-use\neval(safe_get_user_input())\n"})}),"\n",(0,i.jsx)(n.p,{children:"Run the tests with the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"semgrep --test rules/\n"})}),"\n",(0,i.jsx)(n.p,{children:"Which will produce the following output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"1/1: \u2713 All tests passed\nNo tests for fixes found.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep tests automatically avoid failing on lines marked with ",(0,i.jsx)(n.code,{children:"# todoruleid"})," or ",(0,i.jsx)(n.code,{children:"# todook"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"storing-rules-and-test-targets-in-different-directories",children:"Storing rules and test targets in different directories"}),"\n",(0,i.jsxs)(n.p,{children:["Creating different directories for rules and tests helps users manage a growing library of custom rules. To store rules and test targets in different directories use the ",(0,i.jsx)(n.code,{children:"--config"})," option."]}),"\n",(0,i.jsx)(n.p,{children:"For example, in the directory with the following structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"$ tree tests\n\ntests\n\u251c\u2500\u2500 rules\n\u2502\xa0\xa0 \u2514\u2500\u2500 python\n\u2502\xa0\xa0     \u2514\u2500\u2500 insecure-eval-use.yaml\n\u2514\u2500\u2500 targets\n    \u2514\u2500\u2500 python\n        \u2514\u2500\u2500 insecure-eval-use.py\n\n4 directories, 2 files\n"})}),"\n",(0,i.jsx)(n.p,{children:"Use of the following command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"semgrep --test --config tests/rules/ tests/targets/\n"})}),"\n",(0,i.jsx)(n.p,{children:"Produces the same output as in the previous example."}),"\n",(0,i.jsx)(n.p,{children:"The subdirectory structure of these two directories must be the same for Semgrep to correctly find the associated files."}),"\n",(0,i.jsxs)(n.p,{children:["To test the autofix behavior, add the autofix test file ",(0,i.jsx)(n.code,{children:"rules/detect-eval.fixed.py"})," to represent the expected outcome of applying the fix to the test code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from lib import get_user_input, safe_get_user_input, secure_eval\n\nuser_input = get_user_input()\n# ruleid: insecure-eval-use\nsecure_eval(user_input)\n\n# ok: insecure-eval-use\neval('print(\"Hardcoded eval\")')\n\ntotally_safe_eval = eval\n# todoruleid: insecure-eval-use\ntotally_safe_eval(user_input)\n\n# todook: insecure-eval-use\nsecure_eval(safe_get_user_input())\n"})}),"\n",(0,i.jsx)(n.p,{children:"So that the directory structure is printed as the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"$ tree tests\n\ntests\n\u251c\u2500\u2500 rules\n\u2502\xa0\xa0 \u2514\u2500\u2500 python\n\u2502\xa0\xa0     \u2514\u2500\u2500 insecure-eval-use.yaml\n\u2514\u2500\u2500 targets\n    \u2514\u2500\u2500 python\n        \u2514\u2500\u2500 insecure-eval-use.py\n        \u2514\u2500\u2500 insecure-eval-use.fixed.py\n\n4 directories, 2 files\n"})}),"\n",(0,i.jsx)(n.p,{children:"Use of the following command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"semgrep --test --config tests/rules/ tests/targets/\n"})}),"\n",(0,i.jsx)(n.p,{children:"Results in the following outcome:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"1/1: \u2713 All tests passed\n1/1: \u2713 All fix tests passed\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the fix does not behave as expected, the output prints a line diff.\nFor example, if we replace ",(0,i.jsx)(n.code,{children:"secure_eval"})," with ",(0,i.jsx)(n.code,{children:"safe_eval"}),", we can see that lines 5 and 15 are not rendered as expected."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"1/1: \u2713 All tests passed\n0/1: 1 fix tests did not pass:\n--------------------------------------------------------------------------------\n\t\u2716 targets/python/detect-eval.fixed.py <> autofix applied to targets/python/detect-eval.py\n\n\t---\n\t+++\n\t@@ -5 +5 @@\n\t-safe_eval(user_input)\n\t+secure_eval(user_input)\n\t@@ -15 +15 @@\n\t-safe_eval(safe_get_user_input())\n\t+secure_eval(safe_get_user_input())\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"validating-rules",children:"Validating rules"}),"\n",(0,i.jsx)(n.p,{children:"At Semgrep, Inc., we believe in checking the code we write, and that includes rules."}),"\n",(0,i.jsxs)(n.p,{children:["You can run ",(0,i.jsx)(n.code,{children:"semgrep --validate --config [filename]"})," to check the configuration. This command runs a combination of Semgrep rules and OCaml checks against your rules to search for issues such as duplicate patterns and missing fields. All rules submitted to the Semgrep Registry are validated."]}),"\n",(0,i.jsxs)(n.p,{children:["The semgrep rules are pulled from ",(0,i.jsx)(n.code,{children:"p/semgrep-rule-lints"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This feature is still experimental and under active development. Your feedback is welcomed!"}),"\n",(0,i.jsx)(n.h2,{id:"enabling-autofix-in-semgrep-code",children:"Enabling autofix in Semgrep Code"}),"\n",(0,i.jsx)(l.Ay,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(96540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},68021:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>r});var s=t(74848),i=t(28453);const r=[];function l(e){const n={a:"a",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"To enable autofix for all projects in your Semgrep AppSec Platform organization, follow these steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["In Semgrep AppSec Platform, go to ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://semgrep.dev/orgs/-/settings/general/code",children:"Settings > General > Code"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Click the ",(0,s.jsx)(n.strong,{children:"Autofix"})," ",(0,s.jsx)("i",{class:"fa-solid fa-toggle-large-on"})," toggle to enable this feature."]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);