"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[42469],{12310:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"writing-rules/experiments/pattern-syntax","title":"Pattern syntax (Experimental)","description":"Learn how to use Semgrep\'s experimental pattern syntax to search code for a specific code pattern.","source":"@site/docs/writing-rules/experiments/pattern-syntax.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/pattern-syntax","permalink":"/semgrep-docs/writing-rules/experiments/pattern-syntax","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/experiments/pattern-syntax.md","tags":[{"inline":true,"label":"Rules","permalink":"/semgrep-docs/tags/rules"},{"inline":true,"label":"Semgrep Code","permalink":"/semgrep-docs/tags/semgrep-code"}],"version":"current","lastUpdatedAt":1752260268000,"frontMatter":{"slug":"pattern-syntax","title":"Pattern syntax (Experimental)","hide_title":true,"description":"Learn how to use Semgrep\'s experimental pattern syntax to search code for a specific code pattern.","tags":["Rules","Semgrep Code"]},"sidebar":"rulewritingSidebar","previous":{"title":"Introduction","permalink":"/semgrep-docs/writing-rules/experiments/introduction"},"next":{"title":"Aliengrep","permalink":"/semgrep-docs/writing-rules/experiments/aliengrep"}}');var i=a(74848),r=a(28453);const t={slug:"pattern-syntax",title:"Pattern syntax (Experimental)",hide_title:!0,description:"Learn how to use Semgrep's experimental pattern syntax to search code for a specific code pattern.",tags:["Rules","Semgrep Code"]},l=void 0,d={},c=[{value:"Pattern syntax (experimental)",id:"pattern-syntax-experimental",level:2},{value:'<i class="fa-solid fa-exclamation"></i> <code>pattern</code>',id:"-pattern",level:2},{value:'<i class="fa-solid fa-diamond"></i> <code>any</code>',id:"-any",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>all</code>',id:"-all",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>inside</code>',id:"-inside",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>not</code>',id:"-not",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>regex</code>',id:"-regex",level:3},{value:"Metavariables",id:"metavariables",level:2},{value:'<i class="fa-solid fa-exclamation"></i> <code>where</code>',id:"-where",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>metavariable</code>',id:"-metavariable",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>comparison</code>',id:"-comparison",level:3},{value:'<i class="fa-solid fa-diamond"></i> <code>focus</code>',id:"-focus",level:3},{value:'<i class="fa-solid fa-exclamation"></i> <code>as-metavariable</code>',id:"-as-metavariable",level:2},{value:'<i class="fa-solid fa-exclamation"></i> Syntax search mode',id:"-syntax-search-mode",level:2},{value:'<i class="fa-solid fa-exclamation"></i> Taint mode',id:"-taint-mode",level:2},{value:'<i class="fa-solid fa-diamond"></i> Taint mode key names',id:"-taint-mode-key-names",level:3}];function o(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"pattern-syntax-experimental",children:"Pattern syntax (experimental)"}),"\n",(0,i.jsxs)(n.p,{children:["Patterns are the expressions Semgrep uses to match code when it scans for vulnerabilities. This article describes the new syntax for Semgrep pattern operators. See ",(0,i.jsx)(n.a,{href:"/writing-rules/pattern-syntax",children:"Pattern syntax"})," for information on the existing pattern syntax."]}),"\n",(0,i.jsxs)(n.p,{children:["There is often a one-to-one translation from the existing syntax to the experimental syntax. These changes are marked with ",(0,i.jsx)("i",{class:"fa-solid fa-diamond"}),". However, some changes are quite different. These changes are marked with ",(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["These patterns are ",(0,i.jsx)(n.strong,{children:"experimental"})," and subject to change."]}),"\n",(0,i.jsx)(n.li,{children:"You can't mix and match existing pattern syntax with the experimental syntax."}),"\n"]})}),"\n",(0,i.jsxs)(n.h2,{id:"-pattern",children:[(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})," ",(0,i.jsx)(n.code,{children:"pattern"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern"})," operator looks for code matching its expression in the existing syntax. However, ",(0,i.jsx)(n.code,{children:"pattern"})," is no longer required when using the experimental syntax. For example, you can use ",(0,i.jsx)(n.code,{children:"..."})," wherever ",(0,i.jsx)(n.code,{children:'pattern: "...``` appears. For example, you can omit '}),"pattern` and write the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'any:\n  - "badthing1"\n  - "badthing2"\n  - "badthing3"\n'})}),"\n",(0,i.jsx)(n.p,{children:"or, for multi-line patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"any:\n  - |\n      manylines(\n        badthinghere($A)\n      )\n  - |\n      orshort()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You don't need double quotes for a single-line pattern when omitting the ",(0,i.jsx)(n.code,{children:"pattern"})," key, but note that this can cause YAML parsing issues."]}),"\n",(0,i.jsx)(n.p,{children:"As an example, the following YAML parses:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'any:\n  - "def foo(): ..."\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This, however, causes problems since ",(0,i.jsx)(n.code,{children:":"})," is also used to denote a YAML dictionary:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"any:\n  - def foo(): ...\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-any",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"any"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#pattern-either",children:"pattern-either"}),". Matches any of the patterns specified."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"any:\n  - <pat1>\n  - <pat2>\n    ...\n  - <patn>\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-all",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"all"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#patterns",children:"patterns"}),". Matches all of the patterns specified."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"all:\n  - <pat1>\n  - <pat2>\n    ...\n  - <patn>\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-inside",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"inside"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#pattern-inside",children:"pattern-inside"}),". Match any of the sub-patterns inside of the primary pattern."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"inside:\n  any:\n    - <pat1>\n    - <pat2>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"any:\n  - inside: <pat1>\n  - inside: <pat2>\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-not",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"not"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#pattern-not",children:"pattern-not"}),". Accepts any pattern and does ",(0,i.jsx)(n.strong,{children:"not"})," match on those patterns."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"not:\n  any:\n    - <pat1>\n    - <pat2>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"all:\n  - not: <pat1>\n  - not: <pat2>\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-regex",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"regex"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#pattern-regex",children:"pattern-regex"})," Matches based on the regex provided."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'regex: "(.*)"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"metavariables",children:"Metavariables"}),"\n",(0,i.jsxs)(n.p,{children:["Metavariables are an abstraction to match code when you don't know the value or contents beforehand. They're similar to ",(0,i.jsx)(n.a,{href:"https://regexone.com/lesson/capturing_groups",children:"capture groups"})," in regular expressions and can track values across a specific code scope. This\nincludes variables, functions, arguments, classes, object methods, imports,\nexceptions, and more."]}),"\n",(0,i.jsxs)(n.p,{children:["Metavariables begin with a ",(0,i.jsx)(n.code,{children:"$"})," and can only contain uppercase characters, ",(0,i.jsx)(n.code,{children:"_"}),", or digits. Names like ",(0,i.jsx)(n.code,{children:"$x"})," or ",(0,i.jsx)(n.code,{children:"$some_value"})," are invalid. Examples of valid metavariables include ",(0,i.jsx)(n.code,{children:"$X"}),", ",(0,i.jsx)(n.code,{children:"$WIDGET"}),", or ",(0,i.jsx)(n.code,{children:"$USERS_2"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"-where",children:[(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})," ",(0,i.jsx)(n.code,{children:"where"})]}),"\n",(0,i.jsxs)(n.p,{children:["Unlike Semgrep's existing pattern syntax, the following operators no longer occur under ",(0,i.jsx)(n.code,{children:"pattern"})," or ",(0,i.jsx)(n.code,{children:"all"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"metavariable-pattern"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"metavariable-regex"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"metavariable-analysis"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"focus-metavariable"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["These operators must occur within a ",(0,i.jsx)(n.code,{children:"where"})," clause."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"where"})," clause is required in a pattern where you're using metavariable operators. It indicates that Semgrep should match based on the pattern if all the conditions are true."]}),"\n",(0,i.jsx)(n.p,{children:"As an example, take a look at the following example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"all:\n  - inside: |\n      def $FUNC(...):\n        ...\n  - |\n      eval($X)\nwhere:\n  - <condition>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Because the ",(0,i.jsx)(n.code,{children:"where"})," clause is on the same indentation level as ",(0,i.jsx)(n.code,{children:"all"}),", Semgrep understands that everything under ",(0,i.jsx)(n.code,{children:"where"})," must be paired with the entire ",(0,i.jsx)(n.code,{children:"all"})," pattern. As such, the results of the ranges matched by the ",(0,i.jsx)(n.code,{children:"all"})," pattern are modified by the ",(0,i.jsx)(n.code,{children:"where"})," pattern, and the output includes some final set of ranges that are matched."]}),"\n",(0,i.jsxs)(n.h3,{id:"-metavariable",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"metavariable"})]}),"\n",(0,i.jsx)(n.p,{children:"Replaces:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-regex",children:"metavariable-regex"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-pattern",children:"metavariable-pattern"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/writing-rules/metavariable-analysis",children:"metavariable-analysis"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This operator looks inside the metavariable for a match."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'...\nwhere:\n  - metavariable: $A\n    regex: "(.*)\n  - metavariable: $B\n    patterns: |\n      - "foo($C)"\n  - metavariable: $D\n    analyzer: entropy\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"-comparison",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"comparison"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-comparison",children:"metavariable-comparison"}),". Compares metavariables against a basic ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/reference/expressions.html#comparisons",children:"Python comparison"})," expression."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"...\nwhere:\n  - comparison: $A == $B\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-focus",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," ",(0,i.jsx)(n.code,{children:"focus"})]}),"\n",(0,i.jsxs)(n.p,{children:["Replaces ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#focus-metavariable",children:"focus-metavariable"}),". Puts focus on the code region matched by a single metavariable or a list of metavariables."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"...\nwhere:\n  - focus: $A\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"-as-metavariable",children:[(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})," ",(0,i.jsx)(n.code,{children:"as-metavariable"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"as-metavariable"})," is only available in the new syntax."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"as-metavariable"})," is a rule-writing feature that bridges the gap between metavariables and matches. Metavariables get access to things like ",(0,i.jsx)(n.code,{children:"metavariable-comparison"}),", ",(0,i.jsx)(n.code,{children:"metavariable-regex"}),", and ",(0,i.jsx)(n.code,{children:"metavariable-pattern"}),", but you can\u2019t use them on arbitrary matches. However, the ",(0,i.jsx)(n.code,{children:"as"})," operator lets you embed arbitrary matches into metavariables, or bind arbitrary matches to a name."]}),"\n",(0,i.jsx)(n.p,{children:"The syntax is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"all:\n  - pattern: |\n    @decorator\n    def $FUNC(...):\n      ...\n  as: $DECORATED_FUNC\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"as"})," appears in the same indentation as the ",(0,i.jsx)(n.code,{children:"pattern"}),", Semgrep couples the two. This augmented ",(0,i.jsx)(n.code,{children:"pattern"})," operator matches the enclosed pattern, but produces an environment where ",(0,i.jsx)(n.code,{children:"$DECORATED_FUNC"})," is bound to the match it corresponds to. So for instance, the following rule:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"match:\n  pattern: |\n    @decorator\n    def $FUNC(...):\n      ...\n  as: $DECORATED_FUNC\nfix: |\n  @another_decorator\n  $DECORATED_FUNC\n"})}),"\n",(0,i.jsx)(n.p,{children:'Allows you to capture the decorated function. You can then use it in, for example, autofix\'s metavariable or metavariable ellipses interpolation, where you express something like "rewrite X, but with Y."'}),"\n",(0,i.jsxs)(n.h2,{id:"-syntax-search-mode",children:[(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})," Syntax search mode"]}),"\n",(0,i.jsxs)(n.p,{children:["New syntax search mode rules must be nested underneath a top-level ",(0,i.jsx)(n.code,{children:"match"})," key. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: find-bad-stuff\n    severity: ERROR\n    languages: [python]\n    message: |\n      Don't put bad stuff!\n    match:\n      any:\n        - |\n            eval(input())\n        - all:\n            - inside: |\n                def $FUNC(..., $X, ...):\n                  ...\n            - |\n                eval($X)\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"-taint-mode",children:[(0,i.jsx)("i",{class:"fa-solid fa-exclamation"})," Taint mode"]}),"\n",(0,i.jsxs)(n.p,{children:["The new syntax supports taint mode, and such roles no longer require ",(0,i.jsx)(n.code,{children:"mode: taint"})," in the rule. Instead, everything must be nested under a top-level ",(0,i.jsx)(n.code,{children:"taint"})," key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: find-bad-stuff\n    severity: ERROR\n    languages: [python]\n    message: |\n      Don't put bad stuff!\n    taint:\n      sources:\n        - input()\n      sinks:\n        - eval(...)\n      propagators:\n        - pattern: |\n            $X = $Y\n          from: $Y\n          to: $X\n      sanitizers:\n        - magiccleanfunction(...)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"-taint-mode-key-names",children:[(0,i.jsx)("i",{class:"fa-solid fa-diamond"})," Taint mode key names"]}),"\n",(0,i.jsx)(n.p,{children:"The key names for the new syntax taint rules are as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pattern-sources"})," --\x3e sources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pattern-sinks"})," --\x3e sinks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pattern-propagators"})," --\x3e propagators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pattern-sanitizers"})," --\x3e sanitizers"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>l});var s=a(96540);const i={},r=s.createContext(i);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);