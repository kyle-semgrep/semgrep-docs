"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[92194],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}},86784:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"writing-rules/data-flow/constant-propagation","title":"Constant propagation","description":"Semgrep performs flow-sensitive constant folding and this information is used by the matching engine.","source":"@site/docs/writing-rules/data-flow/constant-propagation.md","sourceDirName":"writing-rules/data-flow","slug":"/writing-rules/data-flow/constant-propagation","permalink":"/semgrep-docs/writing-rules/data-flow/constant-propagation","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/data-flow/constant-propagation.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752260268000,"frontMatter":{"slug":"constant-propagation","append_help_link":true,"description":"Semgrep performs flow-sensitive constant folding and this information is used by the matching engine.","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Engine overview","permalink":"/semgrep-docs/writing-rules/data-flow/data-flow-overview"},"next":{"title":"Taint analysis","permalink":"/semgrep-docs/writing-rules/data-flow/taint-mode"}}');var i=t(74848),s=t(28453);const r={slug:"constant-propagation",append_help_link:!0,description:"Semgrep performs flow-sensitive constant folding and this information is used by the matching engine.",tags:["Rule writing"]},o="Constant propagation",l={},c=[{value:"<code>metavariable-comparison</code>",id:"metavariable-comparison",level:2},{value:"Mutable objects",id:"mutable-objects",level:2},{value:"Disable constant propagation",id:"disable-constant-propagation",level:2}];function p(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"constant-propagation",children:"Constant propagation"})}),"\n",(0,i.jsxs)(n.p,{children:["This analysis tracks whether a variable ",(0,i.jsx)(n.em,{children:"must"})," carry a constant value at a given point in the program. Semgrep then performs constant folding when matching literal patterns. Semgrep can track Boolean, numeric, and string constants."]}),"\n",(0,i.jsx)(n.p,{children:"Semgrep AppSec Platform supports interprocedural (cross function), interfile (cross file) constant propagation. Semgrep Community Edition (CE) supports intrafile (single file) constant propagation."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=Gw7z",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(n.h2,{id:"metavariable-comparison",children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})}),"\n",(0,i.jsxs)(n.p,{children:["Using constant propagation, the ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-comparison",children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})})," operator works with any constant variable, instead of just literals."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=Dyzd",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsx)(n.h2,{id:"mutable-objects",children:"Mutable objects"}),"\n",(0,i.jsx)(n.p,{children:"In general, Semgrep assumes that constant objects are immutable and won't be modified by function calls. This may lead to false positives, especially in languages where strings are mutable such as C and Ruby."}),"\n",(0,i.jsx)(n.p,{children:"The only exceptions are method calls whose returning value is ignored. In these cases, Semgrep assumes that the method call may be mutating the callee object. This helps reducing false positives in Ruby. For example:"}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=08yB",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,i.jsxs)(n.p,{children:["If constant propagation doesn't seem to work, consider whether the constant may be unexpectedly mutable. For example, given the following rule designed to taint the ",(0,i.jsx)(n.code,{children:"REGEX"})," class variable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: redos-detection\n    message: Potential ReDoS vulnerability detected with $REGEX\n    severity: ERROR\n    languages:\n      - java\n    mode: taint\n    options:\n      symbolic_propagation: true\n    pattern-sources:\n      - patterns:\n          - pattern: $REDOS\n          - metavariable-analysis:\n              analyzer: redos\n              metavariable: $REDOS\n    pattern-sinks:\n      - pattern: Pattern.compile(...)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep fails to match its use in ",(0,i.jsx)(n.code,{children:"Test2"})," when presented with the following code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.regex.Pattern;\n\npublic String REGEX = "(a+)+$";\n\npublic class Test2 {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(REGEX);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["However, if you change the variable from ",(0,i.jsx)(n.code,{children:"public"})," to ",(0,i.jsx)(n.code,{children:"private"}),", Semgrep does return a match:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.regex.Pattern;\n\nprivate String REGEX = "(a+)+$";\n\npublic class Test2 {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(REGEX);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Because ",(0,i.jsx)(n.code,{children:"REGEX"})," is public in the first code snippet, Semgrep doesn't propagate its value to other classes on the assumption that it could have mutated. However, in the second example, Semgrep understands that ",(0,i.jsx)(n.code,{children:"REGEX"})," is private and is only assigned to once. Therefore, Semgrep assumes it to be immutable."]}),"\n",(0,i.jsx)(n.p,{children:"The rule would also work with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'...\npublic final String REGEX = "(a+)+$";\n...\n'})}),"\n",(0,i.jsx)(n.h2,{id:"disable-constant-propagation",children:"Disable constant propagation"}),"\n",(0,i.jsxs)(n.p,{children:["You can disable constant propagation in a per-rule basis using rule ",(0,i.jsx)(n.a,{href:"/writing-rules/rule-syntax/#options",children:(0,i.jsx)(n.code,{children:"options:"})})," by setting ",(0,i.jsx)(n.code,{children:"constant_propagation: false"}),"."]}),"\n",(0,i.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=jwvn",border:"0",frameBorder:"0",width:"100%",height:"432"})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);