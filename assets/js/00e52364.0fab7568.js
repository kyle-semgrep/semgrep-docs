"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[65986],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var s=t(96540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},81114:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"writing-rules/experiments/project-depends-on","title":"r2c-internal-project-depends-on","description":"r2c-internal-project-depends-on lets Semgrep rules only return results if the project depends on a specific version of a third-party package.","source":"@site/docs/writing-rules/experiments/project-depends-on.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/r2c-internal-project-depends-on","permalink":"/semgrep-docs/writing-rules/experiments/r2c-internal-project-depends-on","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/writing-rules/experiments/project-depends-on.md","tags":[],"version":"current","lastUpdatedAt":1752254305000,"frontMatter":{"slug":"r2c-internal-project-depends-on","append_help_link":true,"description":"r2c-internal-project-depends-on lets Semgrep rules only return results if the project depends on a specific version of a third-party package."},"sidebar":"rulewritingSidebar","previous":{"title":"Including multiple focus metavariables using set union semantics","permalink":"/semgrep-docs/writing-rules/experiments/multiple-focus-metavariables"},"next":{"title":"Symbolic propagation","permalink":"/semgrep-docs/writing-rules/experiments/symbolic-propagation"}}');var i=t(74848),r=t(28453);const l={slug:"r2c-internal-project-depends-on",append_help_link:!0,description:"r2c-internal-project-depends-on lets Semgrep rules only return results if the project depends on a specific version of a third-party package."},c="r2c-internal-project-depends-on",d={},o=[{value:"Example",id:"example",level:2},{value:"Findings of r2c-internal-project-depends-on",id:"findings-of-r2c-internal-project-depends-on",level:2},{value:"r2c-internal-project-depends-on language support",id:"r2c-internal-project-depends-on-language-support",level:2},{value:"Limitations",id:"limitations",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"r2c-internal-project-depends-on",children:"r2c-internal-project-depends-on"})}),"\n",(0,i.jsxs)(n.p,{children:["This Semgrep rules key allows specifying third-party dependencies along with the semver (semantic version) range that should trigger the rule. The ",(0,i.jsx)(n.code,{children:"r2c-internal-project-depends-on"})," filters the rule unless one of the children is matched by a manifest file or lockfile."]}),"\n",(0,i.jsxs)(n.p,{children:["We welcome external contributors to try out the key, but keep in mind there's no expectation of stability across releases yet. ",(0,i.jsx)(n.strong,{children:"The API and behavior of this feature is subject to change"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In the rules.yaml, specify ",(0,i.jsx)(n.code,{children:"r2c-internal-project-depends-on"})," key either as a dependency, or a sequence of dependencies with ",(0,i.jsx)(n.code,{children:"depends-on-either"})," key (see the example below)."]}),"\n",(0,i.jsx)(n.p,{children:"A dependency consists of three keys:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"namespace"}),": The package registry where the third-party dependency is found."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"package"}),": The name of the third-party dependency as it appears in the manifest file or lockfile."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"version"}),": A semantic version range. Uses ",(0,i.jsx)(n.a,{href:"https://packaging.pypa.io/en/latest/specifiers.html",children:"Python packaging specifiers"})," which support almost all NPM operators, except for ",(0,i.jsx)(n.code,{children:"^"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["So a ",(0,i.jsx)(n.code,{children:"r2c-internal-project-depends-on"})," key will either look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"r2c-internal-project-depends-on:\n  namespace: ...\n  package: ...\n  version: ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Or it can have the following layout with ",(0,i.jsx)(n.code,{children:"depends-on-either"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"r2c-internal-project-depends-on:\n  depends-on-either:\n    - namespace: ...\n      package: ...\n      version: ...\n    - namespace: ...\n      package: ...\n      version: ...\n    ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Here is an example ",(0,i.jsx)(n.code,{children:"r2c-internal-project-depends-on"})," rule that searches for a known vulnerable version of the AWS CLI from April 2017, but only reports the vulnerability if the ",(0,i.jsx)(n.code,{children:"s3"})," module (where the vulnerability is located) is actually used:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n- id: vulnerable-awscli-apr-2017\n  severity: WARNING\n  pattern-either:\n  - pattern: boto3.resource('s3', ...)\n  - pattern: boto3.client('s3', ...)\n  r2c-internal-project-depends-on:\n    namespace: pypi\n    package: awscli\n    version: \"<= 1.11.82\"\n  message: this version of awscli is subject to a directory traversal vulnerability in the s3 module\n  languages: [python]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"findings-of-r2c-internal-project-depends-on",children:"Findings of r2c-internal-project-depends-on"}),"\n",(0,i.jsxs)(n.p,{children:["Findings produced by rules with the ",(0,i.jsx)(n.code,{children:"r2c-internal-project-depends-on"})," can be of two types: ",(0,i.jsx)(n.em,{children:"reachable"})," and ",(0,i.jsx)(n.em,{children:"nonreachable"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.em,{children:"reachable"})," finding is one with both a dependency match and a pattern match: a vulnerable dependency was found and the vulnerable part of the dependency (according to the patterns in the rule) is used somewhere in the code."]}),"\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.em,{children:"unreachable"})," finding is one with only a dependency match. Reachable findings are reported as coming from the code that was pattern matched. Unreachable findings are reported as coming from the manifest file or lockfile that was dependency matched. For both types of findings, Semgrep specifies whether they are unreachable or reachable along with all matched dependencies, in the ",(0,i.jsx)(n.code,{children:"extra"})," field of Semgrep's JSON output, using the ",(0,i.jsx)(n.code,{children:"dependency_match_only"})," and ",(0,i.jsx)(n.code,{children:"dependency_matches"})," fields, respectively."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A finding is only considered reachable if the file containing the pattern match actually depends on the dependencies in the manifest file or lockfile containing the dependency match. A file depends on a manifest file or lockfile if it is the nearest manifest file or lockfile going up the directory tree."}),"\n",(0,i.jsx)(n.h2,{id:"r2c-internal-project-depends-on-language-support",children:"r2c-internal-project-depends-on language support"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Language"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Namespace"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Scans dependencies from"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"C#"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"nuget"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"packages.lock.json"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Dart"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"pub"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"pubspec.lock"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Elixir"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"hex"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"mix.lock"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Go"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"gomod"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"go.mod"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Java"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"maven"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"pom.xml"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"JavaScript"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"npm"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"yarn.lock"}),", ",(0,i.jsx)(n.code,{children:"package-lock.json"}),", ",(0,i.jsx)(n.code,{children:"pnpm-lock.yaml"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"PHP"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"composer"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"composer.lock"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Python"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"pypi"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"*requirement*.txt"}),", ",(0,i.jsx)(n.code,{children:"Pipfile.lock"}),", ",(0,i.jsx)(n.code,{children:"poetry.lock"}),", ",(0,i.jsx)(n.code,{children:"uv.lock"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Ruby"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"gem"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"Gemfile.lock"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Rust"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"cargo"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"Cargo.lock"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Swift"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"swiftpm"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"package.swift"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(n.p,{children:["Dependency resolution uses the source of dependency information with the ",(0,i.jsx)(n.em,{children:"least amount of ambiguity"})," available. For all supported languages except Java, the ",(0,i.jsx)(n.em,{children:"least amount of ambiguity"})," provides a manifest file or lockfile, which lists exact version information for each dependency that a project uses. Dependency resolution does not scan, for example, ",(0,i.jsx)(n.code,{children:"package.json"})," files, because they can contain version ranges. In the case of Java, Maven does not support the creation of manifest files, so ",(0,i.jsx)(n.code,{children:"pom.xml"})," is the least ambiguous source of information we have, and we consider only dependencies listed with exact versions."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);