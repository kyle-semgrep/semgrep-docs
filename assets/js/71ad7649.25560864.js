"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[61702],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},84633:(e,n,t)=>{t.d(n,{Ay:()=>a,RM:()=>r});var s=t(74848),i=t(28453);const r=[];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["All required fields must be present at the top-level of a rule, immediately under the ",(0,s.jsx)(n.code,{children:"rules"})," key."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Field"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"id"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Unique, descriptive identifier, for example: ",(0,s.jsx)(n.code,{children:"no-unused-variable"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"message"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Message that includes why Semgrep matched this pattern and how to remediate it. See also ",(0,s.jsx)(n.a,{href:"/contributing/contributing-to-semgrep-rules-repository/#rule-messages",children:"Rule messages"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"severity"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["One of the following values: ",(0,s.jsx)(n.code,{children:"Low"}),", ",(0,s.jsx)(n.code,{children:"Medium"}),", ",(0,s.jsx)(n.code,{children:"High"}),", ",(0,s.jsx)(n.code,{children:"Critical"}),". The ",(0,s.jsx)(n.code,{children:"severity"})," key specifies how critical are the issues that a rule potentially detects. Note: Semgrep Supply Chain differs, as its rules use CVE assignments for severity. For more information, see ",(0,s.jsx)(n.a,{href:"/semgrep-supply-chain/view-export/#filter-findings",children:"Filters"})," section in Semgrep Supply Chain documentation."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"languages"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"array"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["See ",(0,s.jsx)(n.a,{href:"/writing-rules/rule-syntax/#language-extensions-and-languages-key-values",children:"language extensions and tags"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.code,{children:"pattern"}),(0,s.jsx)(n.em,{children:"*"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Find code matching this expression"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.code,{children:"patterns"}),(0,s.jsx)(n.em,{children:"*"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"array"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Logical AND of multiple patterns"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.code,{children:"pattern-either"}),(0,s.jsx)(n.em,{children:"*"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"array"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Logical OR of multiple patterns"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.code,{children:"pattern-regex"}),(0,s.jsx)(n.em,{children:"*"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Find code matching this ",(0,s.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html",children:"PCRE2"}),"-compatible pattern in multiline mode"]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Only one of the following is required: ",(0,s.jsx)(n.code,{children:"pattern"}),", ",(0,s.jsx)(n.code,{children:"patterns"}),", ",(0,s.jsx)(n.code,{children:"pattern-either"}),", ",(0,s.jsx)(n.code,{children:"pattern-regex"})]})})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},96721:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>j,frontMatter:()=>c,metadata:()=>s,toc:()=>x});const s=JSON.parse('{"id":"writing-rules/rule-syntax","title":"Rule syntax","description":"This document describes the YAML rule syntax of Semgrep including required and optional fields. Just getting started with Semgrep rule writing? Check out the Semgrep Tutorial at https://semgrep.dev/learn","source":"@site/docs/writing-rules/rule-syntax.md","sourceDirName":"writing-rules","slug":"/writing-rules/rule-syntax","permalink":"/semgrep-docs/writing-rules/rule-syntax","draft":false,"unlisted":false,"editUrl":"https://github.com/semgrep/semgrep-docs/edit/main/docs/writing-rules/rule-syntax.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1744403518000,"frontMatter":{"append_help_link":true,"slug":"rule-syntax","description":"This document describes the YAML rule syntax of Semgrep including required and optional fields. Just getting started with Semgrep rule writing? Check out the Semgrep Tutorial at https://semgrep.dev/learn","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Custom rule examples","permalink":"/semgrep-docs/writing-rules/rule-ideas"},"next":{"title":"Testing rules","permalink":"/semgrep-docs/writing-rules/testing-rules"}}');var i=t(74848),r=t(28453);function l(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The following table includes languages supported by Semgrep, accepted file extensions for test files that accompany rules, and valid values that Semgrep rules require in the ",(0,i.jsx)(n.code,{children:"languages"})," key."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Language"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Extensions"}),(0,i.jsxs)(n.th,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"languages"})," key values"]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Apex (only in Semgrep Pro Engine)"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".cls"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"apex"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Bash"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".bash"}),", ",(0,i.jsx)(n.code,{children:".sh"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"bash"}),", ",(0,i.jsx)(n.code,{children:"sh"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"C"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".c"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"c"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Cairo"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".cairo"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"cairo"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Clojure"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".clj"}),", ",(0,i.jsx)(n.code,{children:".cljs"}),", ",(0,i.jsx)(n.code,{children:".cljc"}),", ",(0,i.jsx)(n.code,{children:".edn"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"clojure"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"C++"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".cc"}),", ",(0,i.jsx)(n.code,{children:".cpp"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"cpp"}),", ",(0,i.jsx)(n.code,{children:"c++"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"C#"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".cs"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"csharp"}),", ",(0,i.jsx)(n.code,{children:"c#"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Dart"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".dart"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"dart"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Dockerfile"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".dockerfile"}),", ",(0,i.jsx)(n.code,{children:".Dockerfile"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"dockerfile"}),", ",(0,i.jsx)(n.code,{children:"docker"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Elixir"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".ex"}),", ",(0,i.jsx)(n.code,{children:".exs"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"ex"}),", ",(0,i.jsx)(n.code,{children:"elixir"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Generic"}),(0,i.jsx)(n.td,{style:{textAlign:"left"}}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"generic"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Go"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".go"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"go"}),", ",(0,i.jsx)(n.code,{children:"golang"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"HTML"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".htm"}),", ",(0,i.jsx)(n.code,{children:".html"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"html"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Java"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".java"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"java"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"JavaScript"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".js"}),", ",(0,i.jsx)(n.code,{children:".jsx"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"js"}),", ",(0,i.jsx)(n.code,{children:"javascript"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"JSON"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".json"}),", ",(0,i.jsx)(n.code,{children:".ipynb"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"json"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Jsonnet"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".jsonnet"}),", ",(0,i.jsx)(n.code,{children:".libsonnet"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"jsonnet"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"JSX"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".js"}),", ",(0,i.jsx)(n.code,{children:".jsx"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"js"}),", ",(0,i.jsx)(n.code,{children:"javascript"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Julia"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".jl"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"julia"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Kotlin"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".kt"}),", ",(0,i.jsx)(n.code,{children:".kts"}),", ",(0,i.jsx)(n.code,{children:".ktm"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"kt"}),", ",(0,i.jsx)(n.code,{children:"kotlin"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Lisp"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".lisp"}),", ",(0,i.jsx)(n.code,{children:".cl"}),", ",(0,i.jsx)(n.code,{children:".el"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lisp"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Lua"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".lua"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lua"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"OCaml"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".ml"}),", ",(0,i.jsx)(n.code,{children:".mli"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"ocaml"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"PHP"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".php"}),", ",(0,i.jsx)(n.code,{children:".tpl"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"php"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Python"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".py"}),", ",(0,i.jsx)(n.code,{children:".pyi"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"python"}),", ",(0,i.jsx)(n.code,{children:"python2"}),", ",(0,i.jsx)(n.code,{children:"python3"}),", ",(0,i.jsx)(n.code,{children:"py"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"R"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".r"}),", ",(0,i.jsx)(n.code,{children:".R"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"r"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Ruby"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".rb"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"ruby"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Rust"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".rs"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"rust"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Scala"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".scala"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"scala"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Scheme"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".scm"}),", ",(0,i.jsx)(n.code,{children:".ss"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"scheme"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Solidity"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".sol"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"solidity"}),", ",(0,i.jsx)(n.code,{children:"sol"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Swift"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".swift"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"swift"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Terraform"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".tf"}),", ",(0,i.jsx)(n.code,{children:".hcl"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"tf"}),", ",(0,i.jsx)(n.code,{children:"hcl"}),", ",(0,i.jsx)(n.code,{children:"terraform"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"TypeScript"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".ts"}),", ",(0,i.jsx)(n.code,{children:".tsx"})]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"ts"}),", ",(0,i.jsx)(n.code,{children:"typescript"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"YAML"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:".yml"}),", ",(0,i.jsx)(n.code,{children:".yaml"})]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"yaml"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"XML"}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:".xml"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"xml"})})]})]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"To see the maturity level of each supported language, see the following references:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/semgrep-ce-languages",children:"Semgrep CE"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/supported-languages#language-maturity-summary",children:"Semgrep Code"})}),"\n"]})]})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}var d=t(84633);const c={append_help_link:!0,slug:"rule-syntax",description:"This document describes the YAML rule syntax of Semgrep including required and optional fields. Just getting started with Semgrep rule writing? Check out the Semgrep Tutorial at https://semgrep.dev/learn",tags:["Rule writing"]},o="Rule syntax",h={},x=[{value:"Schema",id:"schema",level:2},{value:"Required",id:"required",level:3},...d.RM,{value:"Language extensions and languages key values",id:"language-extensions-and-languages-key-values",level:4},{value:"Optional",id:"optional",level:3},{value:"Operators",id:"operators",level:2},{value:"<code>pattern</code>",id:"pattern",level:3},{value:"<code>patterns</code>",id:"patterns",level:3},{value:"<code>patterns</code> operator evaluation strategy",id:"patterns-operator-evaluation-strategy",level:4},{value:"<code>pattern-either</code>",id:"pattern-either",level:3},{value:"<code>pattern-regex</code>",id:"pattern-regex",level:3},{value:"Example: <code>pattern-regex</code> combined with other pattern operators",id:"example-pattern-regex-combined-with-other-pattern-operators",level:4},{value:"Example: <code>pattern-regex</code> used as a standalone, top-level operator",id:"example-pattern-regex-used-as-a-standalone-top-level-operator",level:4},{value:"<code>pattern-not-regex</code>",id:"pattern-not-regex",level:3},{value:"<code>focus-metavariable</code>",id:"focus-metavariable",level:3},{value:"Including multiple focus metavariables using set intersection semantics",id:"including-multiple-focus-metavariables-using-set-intersection-semantics",level:4},{value:"<code>metavariable-regex</code>",id:"metavariable-regex",level:3},{value:"<code>metavariable-pattern</code>",id:"metavariable-pattern",level:3},{value:"<code>metavariable-pattern</code> with nested language",id:"metavariable-pattern-with-nested-language",level:4},{value:"Example: Match JavaScript code inside HTML",id:"example-match-javascript-code-inside-html",level:4},{value:"Example: Filter regex matches",id:"example-filter-regex-matches",level:4},{value:"<code>metavariable-comparison</code>",id:"metavariable-comparison",level:3},{value:"Legacy <code>metavariable-comparison</code> keys",id:"legacy-metavariable-comparison-keys",level:4},{value:"<code>metavariable-name</code>",id:"metavariable-name",level:3},{value:"<code>pattern-not</code>",id:"pattern-not",level:3},{value:"<code>pattern-inside</code>",id:"pattern-inside",level:3},{value:"<code>pattern-not-inside</code>",id:"pattern-not-inside",level:3},{value:"Metavariable matching",id:"metavariable-matching",level:2},{value:"Metavariables in logical ANDs",id:"metavariables-in-logical-ands",level:3},{value:"Metavariables in logical ORs",id:"metavariables-in-logical-ors",level:3},{value:"Metavariables in complex logic",id:"metavariables-in-complex-logic",level:3},{value:"<code>options</code>",id:"options",level:2},{value:"<code>fix</code>",id:"fix",level:2},{value:"<code>metadata</code>",id:"metadata",level:2},{value:"<code>min-version</code> and <code>max-version</code>",id:"min-version-and-max-version",level:2},{value:"<code>category</code>",id:"category",level:2},{value:"<code>paths</code>",id:"paths",level:2},{value:"Excluding a rule in paths",id:"excluding-a-rule-in-paths",level:3},{value:"Limiting a rule to paths",id:"limiting-a-rule-to-paths",level:3},{value:"Other examples",id:"other-examples",level:2},{value:"Complete useless comparison",id:"complete-useless-comparison",level:3},{value:"Full specification",id:"full-specification",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rule-syntax",children:"Rule syntax"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Getting started with rule writing? Try the ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/learn",children:"Semgrep Tutorial"})," \ud83c\udf93"]})}),"\n",(0,i.jsx)(n.p,{children:"This document describes the YAML rule syntax of Semgrep."}),"\n",(0,i.jsx)(n.h2,{id:"schema",children:"Schema"}),"\n",(0,i.jsx)(n.h3,{id:"required",children:"Required"}),"\n",(0,i.jsx)(d.Ay,{}),"\n",(0,i.jsx)(n.h4,{id:"language-extensions-and-languages-key-values",children:"Language extensions and languages key values"}),"\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(n.h3,{id:"optional",children:"Optional"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Field"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#options",children:(0,i.jsx)(n.code,{children:"options"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Options object to enable/disable certain matching features"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#fix",children:(0,i.jsx)(n.code,{children:"fix"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Simple search-and-replace autofix functionality"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#metadata",children:(0,i.jsx)(n.code,{children:"metadata"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Arbitrary user-provided data; attach data to rules without affecting Semgrep behavior"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#min-version-and-max-version",children:(0,i.jsx)(n.code,{children:"min-version"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Minimum Semgrep version compatible with this rule"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#min-version-and-max-version",children:(0,i.jsx)(n.code,{children:"max-version"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Maximum Semgrep version compatible with this rule"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#paths",children:(0,i.jsx)(n.code,{children:"paths"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Paths to include or exclude when running this rule"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The below optional fields must reside underneath a ",(0,i.jsx)(n.code,{children:"patterns"})," or ",(0,i.jsx)(n.code,{children:"pattern-either"})," field."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Field"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#pattern-inside",children:(0,i.jsx)(n.code,{children:"pattern-inside"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Keep findings that lie inside this pattern"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["The below optional fields must reside underneath a ",(0,i.jsx)(n.code,{children:"patterns"})," field."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Field"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#metavariable-regex",children:(0,i.jsx)(n.code,{children:"metavariable-regex"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"map"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Search metavariables for ",(0,i.jsxs)(n.a,{href:"https://docs.python.org/3/library/re.html#re.match",children:["Python ",(0,i.jsx)(n.code,{children:"re"})]})," compatible expressions; regex matching is ",(0,i.jsx)(n.strong,{children:"left anchored"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#metavariable-pattern",children:(0,i.jsx)(n.code,{children:"metavariable-pattern"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"map"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Matches metavariables with a pattern formula"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#metavariable-comparison",children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"map"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Compare metavariables against basic ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/reference/expressions.html#comparisons",children:"Python expressions"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#metavariable-name",children:(0,i.jsx)(n.code,{children:"metavariable-name"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"map"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Matches metavariables against constraints on what they name"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#pattern-not",children:(0,i.jsx)(n.code,{children:"pattern-not"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Logical NOT - remove findings matching this expression"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#pattern-not-inside",children:(0,i.jsx)(n.code,{children:"pattern-not-inside"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Keep findings that do not lie inside this pattern"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.a,{href:"#pattern-not-regex",children:(0,i.jsx)(n.code,{children:"pattern-not-regex"})})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Filter results using a ",(0,i.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html",children:"PCRE2"}),"-compatible pattern in multiline mode"]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,i.jsx)(n.h3,{id:"pattern",children:(0,i.jsx)(n.code,{children:"pattern"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern"})," operator looks for code matching its expression. This can be basic expressions like ",(0,i.jsx)(n.code,{children:"$X == $X"})," or unwanted function calls like ",(0,i.jsx)(n.code,{children:"hashlib.md5(...)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: md5-usage\n    languages:\n      - python\n    message: Found md5 usage\n    pattern: hashlib.md5(...)\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import hashlib\n# ruleid: md5-usage\n# highlight-next-line\ndigest = hashlib.md5(b"test")\n# ok: md5-usage\ndigest = hashlib.sha256(b"test")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"patterns",children:(0,i.jsx)(n.code,{children:"patterns"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"patterns"})," operator performs a logical AND operation on one or more child patterns. This is useful for chaining multiple patterns together that all must be true."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: unverified-db-query\n    patterns:\n      - pattern: db_query(...)\n      - pattern-not: db_query(..., verify=True, ...)\n    message: Found unverified db query\n    severity: ERROR\n    languages:\n      - python\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# ruleid: unverified-db-query\n# highlight-next-line\ndb_query("SELECT * FROM ...")\n# ok: unverified-db-query\ndb_query("SELECT * FROM ...", verify=True, env="prod")\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"patterns-operator-evaluation-strategy",children:[(0,i.jsx)(n.code,{children:"patterns"})," operator evaluation strategy"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that the order in which the child patterns are declared in a ",(0,i.jsx)(n.code,{children:"patterns"})," operator has no effect on the final result. A ",(0,i.jsx)(n.code,{children:"patterns"})," operator is always evaluated in the same way:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Semgrep evaluates all ",(0,i.jsx)(n.em,{children:"positive"})," patterns, that is ",(0,i.jsx)(n.a,{href:"#pattern-inside",children:(0,i.jsx)(n.code,{children:"pattern-inside"})}),"s, ",(0,i.jsx)(n.a,{href:"#pattern",children:(0,i.jsx)(n.code,{children:"pattern"})}),"s, ",(0,i.jsx)(n.a,{href:"#pattern-regex",children:(0,i.jsx)(n.code,{children:"pattern-regex"})}),"es, and ",(0,i.jsx)(n.a,{href:"#pattern-either",children:(0,i.jsx)(n.code,{children:"pattern-either"})}),"s. Each range matched by each one of these patterns is intersected with the ranges matched by the other operators. The result is a set of ",(0,i.jsx)(n.em,{children:"positive"})," ranges. The positive ranges carry ",(0,i.jsx)(n.em,{children:"metavariable bindings"}),". For example, in one range ",(0,i.jsx)(n.code,{children:"$X"})," can be bound to the function call ",(0,i.jsx)(n.code,{children:"foo()"}),", and in another range ",(0,i.jsx)(n.code,{children:"$X"})," can be bound to the expression ",(0,i.jsx)(n.code,{children:"a + b"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep evaluates all ",(0,i.jsx)(n.em,{children:"negative"})," patterns, that is ",(0,i.jsx)(n.a,{href:"#pattern-not-inside",children:(0,i.jsx)(n.code,{children:"pattern-not-inside"})}),"s, ",(0,i.jsx)(n.a,{href:"#pattern-not",children:(0,i.jsx)(n.code,{children:"pattern-not"})}),"s, and ",(0,i.jsx)(n.a,{href:"#pattern-not-regex",children:(0,i.jsx)(n.code,{children:"pattern-not-regex"})}),"es. This gives a set of ",(0,i.jsx)(n.em,{children:"negative ranges"})," which are used to filter the positive ranges. This results in a strict subset of the positive ranges computed in the previous step."]}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep evaluates all ",(0,i.jsx)(n.em,{children:"conditionals"}),", that is ",(0,i.jsx)(n.a,{href:"#metavariable-regex",children:(0,i.jsx)(n.code,{children:"metavariable-regex"})}),"es, ",(0,i.jsx)(n.a,{href:"#metavariable-pattern",children:(0,i.jsx)(n.code,{children:"metavariable-pattern"})}),"s and ",(0,i.jsx)(n.a,{href:"#metavariable-comparison",children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})}),"s. These conditional operators can only examine the metavariables bound in the positive ranges in step 1, that passed through the filter of negative patterns in step 2. Note that metavariables bound by negative patterns are ",(0,i.jsx)(n.em,{children:"not"})," available here."]}),"\n",(0,i.jsxs)(n.li,{children:["Semgrep applies all ",(0,i.jsx)(n.a,{href:"#focus-metavariable",children:(0,i.jsx)(n.code,{children:"focus-metavariable"})}),"s, by computing the intersection of each positive range with the range of the metavariable on which we want to focus. Again, the only metavariables available to focus on are those bound by positive patterns."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-either",children:(0,i.jsx)(n.code,{children:"pattern-either"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-either"})," operator performs a logical OR operation on one or more child patterns. This is useful for chaining multiple patterns together where any may be true."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: insecure-crypto-usage\n    pattern-either:\n      - pattern: hashlib.sha1(...)\n      - pattern: hashlib.md5(...)\n    message: Found insecure crypto usage\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import hashlib\n# ruleid: insecure-crypto-usage\n# highlight-next-line\ndigest = hashlib.md5(b"test")\n# ruleid: insecure-crypto-usage\n# highlight-next-line\ndigest = hashlib.sha1(b"test")\n# ok: insecure-crypto-usage\ndigest = hashlib.sha256(b"test")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This rule looks for usage of the Python standard library functions ",(0,i.jsx)(n.code,{children:"hashlib.md5"})," or ",(0,i.jsx)(n.code,{children:"hashlib.sha1"}),". Depending on their usage, these hashing functions are ",(0,i.jsx)(n.a,{href:"https://shattered.io/",children:"considered insecure"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-regex",children:(0,i.jsx)(n.code,{children:"pattern-regex"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-regex"})," operator searches files for substrings matching the given ",(0,i.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html",children:"PCRE2"})," pattern. This is useful for migrating existing regular expression code search functionality to Semgrep. Perl-Compatible Regular Expressions (PCRE) is a full-featured regex library that is widely compatible with Perl, but also with the respective regex libraries of Python, JavaScript, Go, Ruby, and Java. Patterns are compiled in multiline mode, for example ",(0,i.jsx)(n.code,{children:"^"})," and ",(0,i.jsx)(n.code,{children:"$"})," matches at the beginning and end of lines respectively in addition to the beginning and end of input."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["PCRE2 supports ",(0,i.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html#uniextseq",children:"some Unicode character properties, but not some Perl properties"}),". For example, ",(0,i.jsx)(n.code,{children:"\\p{Egyptian_Hieroglyphs}"})," is supported but ",(0,i.jsx)(n.code,{children:"\\p{InMusicalSymbols}"})," isn't."]})}),"\n",(0,i.jsxs)(n.h4,{id:"example-pattern-regex-combined-with-other-pattern-operators",children:["Example: ",(0,i.jsx)(n.code,{children:"pattern-regex"})," combined with other pattern operators"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: boto-client-ip\n    patterns:\n      - pattern-inside: boto3.client(host="...")\n      - pattern-regex: \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\n    message: boto client using IP address\n    languages:\n      - python\n    severity: ERROR\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import boto3\n# ruleid: boto-client-ip\n# highlight-next-line\nclient = boto3.client(host="192.168.1.200")\n# ok: boto-client-ip\nclient = boto3.client(host="dev.internal.example.com")\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"example-pattern-regex-used-as-a-standalone-top-level-operator",children:["Example: ",(0,i.jsx)(n.code,{children:"pattern-regex"})," used as a standalone, top-level operator"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: legacy-eval-search\n    pattern-regex: eval\\(\n    message: Insecure code execution\n    languages:\n      - javascript\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ruleid: legacy-eval-search\n# highlight-next-line\neval('var a = 5')\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Single (",(0,i.jsx)(n.code,{children:"'"}),") and double (",(0,i.jsx)(n.code,{children:'"'}),") quotes ",(0,i.jsx)(n.a,{href:"https://docs.octoprint.org/en/master/configuration/yaml.html#scalars",children:"behave differently"})," in YAML syntax. Single quotes are typically preferred when using backslashes (",(0,i.jsx)(n.code,{children:"\\"}),") with ",(0,i.jsx)(n.code,{children:"pattern-regex"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Note that you may bind a section of a regular expression to a metavariable, by using ",(0,i.jsx)(n.a,{href:"https://www.regular-expressions.info/named.html",children:"named capturing groups"}),". In\nthis case, the name of the capturing group must be a valid metavariable name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: my_pattern_id-copy\n    patterns:\n      - pattern-regex: a(?P<FIRST>.*)b(?P<SECOND>.*)\n    message: Semgrep found a match, with $FIRST and $SECOND\n    languages:\n      - regex\n    severity: WARNING\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# highlight-next-line\nacbd\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-not-regex",children:(0,i.jsx)(n.code,{children:"pattern-not-regex"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-not-regex"})," operator filters results using a ",(0,i.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html",children:"PCRE2"})," regular expression in multiline mode. This is most useful when combined with regular-expression only rules, providing an easy way to filter findings without having to use negative lookaheads. ",(0,i.jsx)(n.code,{children:"pattern-not-regex"})," works with regular ",(0,i.jsx)(n.code,{children:"pattern"})," clauses, too."]}),"\n",(0,i.jsxs)(n.p,{children:["The syntax for this operator is the same as ",(0,i.jsx)(n.code,{children:"pattern-regex"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This operator filters findings that have ",(0,i.jsx)(n.em,{children:"any overlap"})," with the supplied regular expression. For example, if you use ",(0,i.jsx)(n.code,{children:"pattern-regex"})," to detect ",(0,i.jsx)(n.code,{children:"Foo==1.1.1"})," and it also detects ",(0,i.jsx)(n.code,{children:"Foo-Bar==3.0.8"})," and ",(0,i.jsx)(n.code,{children:"Bar-Foo==3.0.8"}),", you can use ",(0,i.jsx)(n.code,{children:"pattern-not-regex"})," to filter the unwanted findings."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: detect-only-foo-package\n    languages:\n      - regex\n    message: Found foo package\n    patterns:\n      - pattern-regex: foo\n      - pattern-not-regex: foo-\n      - pattern-not-regex: -foo\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ruleid: detect-only-foo-package\n# highlight-next-line\nfoo==1.1.1\n# ok: detect-only-foo-package\nfoo-bar==3.0.8\n# ok: detect-only-foo-package\nbar-foo==3.0.8\n"})}),"\n",(0,i.jsx)(n.h3,{id:"focus-metavariable",children:(0,i.jsx)(n.code,{children:"focus-metavariable"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"focus-metavariable"})," operator puts the focus, or ",(0,i.jsx)(n.em,{children:"zooms in"}),", on the code region matched by a single metavariable or a list of metavariables. For example, to find all functions arguments annotated with the type ",(0,i.jsx)(n.code,{children:"bad"})," you may write the following pattern:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"pattern: |\n  def $FUNC(..., $ARG : bad, ...):\n    ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This works but it matches the entire function definition. Sometimes, this is not desirable. If the definition spans hundreds of lines they are all matched. In particular, if you are using ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/login",children:"Semgrep AppSec Platform"})," and you have triaged a finding generated by this pattern, the same finding shows up again as new if you make any change to the definition of the function!"]}),"\n",(0,i.jsxs)(n.p,{children:["To specify that you are only interested in the code matched by a particular metavariable, in our example ",(0,i.jsx)(n.code,{children:"$ARG"}),", use ",(0,i.jsx)(n.code,{children:"focus-metavariable"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: find-bad-args\n    patterns:\n      - pattern: |\n          def $FUNC(..., $ARG : bad, ...):\n            ...\n      - focus-metavariable: $ARG\n    message: |\n      `$ARG\' has a "bad" type!\n    languages:\n      - python\n    severity: WARNING\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# highlight-next-line\ndef f(x : bad):\n    return x\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"focus-metavariable: $ARG"})," is not the same as ",(0,i.jsx)(n.code,{children:"pattern: $ARG"}),"! Using ",(0,i.jsx)(n.code,{children:"pattern: $ARG"})," finds all the uses of the parameter ",(0,i.jsx)(n.code,{children:"x"})," which is not what we want! (Note that ",(0,i.jsx)(n.code,{children:"pattern: $ARG"})," does not match the formal parameter declaration, because in this context ",(0,i.jsx)(n.code,{children:"$ARG"})," only matches expressions.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: find-bad-args\n    patterns:\n      - pattern: |\n          def $FUNC(..., $ARG : bad, ...):\n            ...\n      - pattern: $ARG\n    message: |\n      `$ARG\' has a "bad" type!\n    languages:\n      - python\n    severity: WARNING\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def f(x : bad):\n# highlight-next-line\n    return x\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In short, ",(0,i.jsx)(n.code,{children:"focus-metavariable: $X"})," is not a pattern in itself, it does not perform any matching, it only focuses the matching on the code already bound to ",(0,i.jsx)(n.code,{children:"$X"})," by other patterns. Whereas ",(0,i.jsx)(n.code,{children:"pattern: $X"})," matches ",(0,i.jsx)(n.code,{children:"$X"})," against your code (and in this context, ",(0,i.jsx)(n.code,{children:"$X"})," only matches expressions)!"]}),"\n",(0,i.jsx)(n.h4,{id:"including-multiple-focus-metavariables-using-set-intersection-semantics",children:"Including multiple focus metavariables using set intersection semantics"}),"\n",(0,i.jsxs)(n.p,{children:["Include more ",(0,i.jsx)(n.code,{children:"focus-metavariable"})," keys with different metavariables under the ",(0,i.jsx)(n.code,{children:"pattern"})," to match results ",(0,i.jsx)(n.strong,{children:"only"})," for the overlapping region of all the focused code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"    patterns:\n      - pattern: foo($X, ..., $Y)\n      - focus-metavariable:\n        - $X\n        - $Y\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: intersect-focus-metavariable\n    patterns:\n      - pattern-inside: foo($X, ...)\n      - focus-metavariable: $X\n      - pattern: $Y + ...\n      - focus-metavariable: $Y\n      - pattern: "1"\n    message: Like set intersection, only the overlapping region is highilighted\n    languages:\n      - python\n    severity: ERROR\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ruleid: intersect-focus-metavariable\nfoo (\n# highlight-next-line\n    1\n    +\n    2,\n    1\n)\n\n# OK: test\nfoo (2+ 1, 1)\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["To make a list of multiple focus metavariables using set union semantics that matches the metavariables regardless of their position in code, see ",(0,i.jsx)(n.a,{href:"/writing-rules/experiments/multiple-focus-metavariables",children:"Including multiple focus metavariables using set union semantics"})," documentation."]})}),"\n",(0,i.jsx)(n.h3,{id:"metavariable-regex",children:(0,i.jsx)(n.code,{children:"metavariable-regex"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-regex"})," operator searches metavariables for a ",(0,i.jsx)(n.a,{href:"https://www.pcre.org/current/doc/html/pcre2pattern.html",children:"PCRE2"})," regular expression. This is useful for filtering results based on a ",(0,i.jsx)(n.a,{href:"/semgrep-docs/writing-rules/pattern-syntax#metavariables",children:"metavariable\u2019s"})," value. It requires the ",(0,i.jsx)(n.code,{children:"metavariable"})," and ",(0,i.jsx)(n.code,{children:"regex"})," keys and can be combined with other pattern operators."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: insecure-methods\n    patterns:\n      - pattern: module.$METHOD(...)\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: (insecure)\n    message: module using insecure method call\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# ruleid: insecure-methods\n# highlight-next-line\nmodule.insecure1("test")\n# ruleid: insecure-methods\n# highlight-next-line\nmodule.insecure2("test")\n# ruleid: insecure-methods\n# highlight-next-line\nmodule.insecure3("test")\n# ok: insecure-methods\nmodule.secure("test")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Regex matching is ",(0,i.jsx)(n.strong,{children:"left anchored"}),". To allow prefixes, use ",(0,i.jsx)(n.code,{children:".*"})," at the beginning of the regex. To match the end of a string, use ",(0,i.jsx)(n.code,{children:"$"}),". The next example, using the same expression as above but anchored on the right, finds no matches:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: insecure-methods\n    patterns:\n      - pattern: module.$METHOD(...)\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: (insecure$)\n    message: module using insecure method call\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The following example matches all of the function calls in the same code sample, returning a false positive on the ",(0,i.jsx)(n.code,{children:"module.secure"})," call:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: insecure-methods\n    patterns:\n      - pattern: module.$METHOD(...)\n      - metavariable-regex:\n          metavariable: $METHOD\n          regex: (.*secure)\n    message: module using insecure method call\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Include quotes in your regular expression when using ",(0,i.jsx)(n.code,{children:"metavariable-regex"})," to search string literals. For more details, see ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/playground/s/EbDB",children:"include-quotes"})," code snippet."]})}),"\n",(0,i.jsx)(n.h3,{id:"metavariable-pattern",children:(0,i.jsx)(n.code,{children:"metavariable-pattern"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})," operator matches metavariables with a pattern formula. This is useful for filtering results based on a ",(0,i.jsx)(n.a,{href:"/semgrep-docs/writing-rules/pattern-syntax#metavariables",children:"metavariable\u2019s"})," value. It requires the ",(0,i.jsx)(n.code,{children:"metavariable"})," key, and exactly one key of ",(0,i.jsx)(n.code,{children:"pattern"}),", ",(0,i.jsx)(n.code,{children:"patterns"}),", ",(0,i.jsx)(n.code,{children:"pattern-either"}),", or ",(0,i.jsx)(n.code,{children:"pattern-regex"}),". This operator can be nested as well as combined with other operators."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, the ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})," can be used to filter out matches that do ",(0,i.jsx)(n.strong,{children:"not"})," match certain criteria:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: disallow-old-tls-versions2\n    languages:\n      - javascript\n    message: Match found\n    patterns:\n      - pattern: |\n          $CONST = require('crypto');\n          ...\n          $OPTIONS = $OPTS;\n          ...\n          https.createServer($OPTIONS, ...);\n      - metavariable-pattern:\n          metavariable: $OPTS\n          patterns:\n            - pattern-not: >\n                {secureOptions: $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3\n                | $CONST.SSL_OP_NO_TLSv1}\n    severity: WARNING\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"function bad() {\n    // ruleid:disallow-old-tls-versions2\n    # highlight-next-line\n    var constants = require('crypto');\n    # highlight-next-line\n    var sslOptions = {\n    # highlight-next-line\n    key: fs.readFileSync('/etc/ssl/private/private.key'),\n    # highlight-next-line\n    secureProtocol: 'SSLv23_server_method',\n    # highlight-next-line\n    secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3\n    # highlight-next-line\n    };\n    # highlight-next-line\n    https.createServer(sslOptions);\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["In this case it is possible to start a ",(0,i.jsx)(n.code,{children:"patterns"})," AND operation with a ",(0,i.jsx)(n.code,{children:"pattern-not"}),", because there is an implicit ",(0,i.jsx)(n.code,{children:"pattern: ..."})," that matches the content of the metavariable."]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})," is also useful in combination with ",(0,i.jsx)(n.code,{children:"pattern-either"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: open-redirect\n    languages:\n      - python\n    message: Match found\n    patterns:\n      - pattern-inside: |\n          def $FUNC(...):\n            ...\n            return django.http.HttpResponseRedirect(..., $DATA, ...)\n      - metavariable-pattern:\n          metavariable: $DATA\n          patterns:\n            - pattern-either:\n                - pattern: $REQUEST\n                - pattern: $STR.format(..., $REQUEST, ...)\n                - pattern: $STR % $REQUEST\n                - pattern: $STR + $REQUEST\n                - pattern: f"...{$REQUEST}..."\n            - metavariable-pattern:\n                metavariable: $REQUEST\n                patterns:\n                  - pattern-either:\n                      - pattern: request.$W\n                      - pattern: request.$W.get(...)\n                      - pattern: request.$W(...)\n                      - pattern: request.$W[...]\n                  - metavariable-regex:\n                      metavariable: $W\n                      regex: (?!get_full_path)\n    severity: WARNING\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from django.http import HttpResponseRedirect\n# highlight-next-line\ndef unsafe(request):\n    # ruleid:open-redirect\n    # highlight-next-line\n    return HttpResponseRedirect(request.POST.get("url"))\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["It is possible to nest ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})," inside ",(0,i.jsx)(n.code,{children:"metavariable-pattern"}),"!"]})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The metavariable should be bound to an expression, a statement, or a list of statements, for this test to be meaningful. A metavariable bound to a list of function arguments, a type, or a pattern, always evaluate to false."})}),"\n",(0,i.jsxs)(n.h4,{id:"metavariable-pattern-with-nested-language",children:[(0,i.jsx)(n.code,{children:"metavariable-pattern"})," with nested language"]}),"\n",(0,i.jsxs)(n.p,{children:["If the metavariable's content is a string, then it is possible to use ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})," to match this string as code by specifying the target language via the ",(0,i.jsx)(n.code,{children:"language"})," key. See the following examples of ",(0,i.jsx)(n.code,{children:"metavariable-pattern"}),":"]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Examples of ",(0,i.jsx)(n.code,{children:"metavariable-pattern"})]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Match JavaScript code inside HTML in the following ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/z95k",children:"Semgrep Playground"})," example."]}),"\n",(0,i.jsxs)(n.li,{children:["Filter regex matches in the following ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/pkNk",children:"Semgrep Playground"})," example."]}),"\n"]})]}),"\n",(0,i.jsx)(n.h4,{id:"example-match-javascript-code-inside-html",children:"Example: Match JavaScript code inside HTML"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: test\n    languages:\n      - generic\n    message: javascript inside html working!\n    patterns:\n      - pattern: |\n          <script ...>$...JS<\/script>\n      - metavariable-pattern:\n          language: javascript\n          metavariable: $...JS\n          patterns:\n            - pattern: |\n                console.log(...)\n    severity: WARNING\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'\x3c!-- ruleid:test --\x3e\n# highlight-next-line\n<script>\n# highlight-next-line\nconsole.log("hello")\n# highlight-next-line\n<\/script>\n'})}),"\n",(0,i.jsx)(n.h4,{id:"example-filter-regex-matches",children:"Example: Filter regex matches"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: test\n    languages:\n      - generic\n    message: "Google dependency: $1 $2"\n    patterns:\n      - pattern-regex: gem "(.*)", "(.*)"\n      - metavariable-pattern:\n          metavariable: $1\n          language: generic\n          patterns:\n            - pattern: google\n    severity: INFO\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# highlight-next-line\nsource "https://rubygems.org"\n\n#OK:test\ngem "functions_framework", "~> 0.7"\n#ruleid:test\n# highlight-next-line\ngem "google-cloud-storage", "~> 1.29"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"metavariable-comparison",children:(0,i.jsx)(n.code,{children:"metavariable-comparison"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-comparison"})," operator compares metavariables against a basic ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/reference/expressions.html#comparisons",children:"Python comparison"})," expression. This is useful for filtering results based on a ",(0,i.jsx)(n.a,{href:"/writing-rules/pattern-syntax/#metavariables",children:"metavariable's"})," numeric value."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-comparison"})," operator is a mapping which requires the ",(0,i.jsx)(n.code,{children:"metavariable"})," and ",(0,i.jsx)(n.code,{children:"comparison"})," keys. It can be combined with other pattern operators in the following ",(0,i.jsx)(n.a,{href:"https://semgrep.dev/s/GWv6",children:"Semgrep Playground"})," example."]}),"\n",(0,i.jsxs)(n.p,{children:["This matches code such as ",(0,i.jsx)(n.code,{children:"set_port(80)"})," or ",(0,i.jsx)(n.code,{children:"set_port(443)"}),", but not ",(0,i.jsx)(n.code,{children:"set_port(8080)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Comparison expressions support simple arithmetic as well as composition with ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/reference/expressions.html#boolean-operations",children:"Boolean operators"})," to allow for more complex matching. This is particularly useful for checking that metavariables are divisible by particular values, such as enforcing that a particular value is even or odd."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: superuser-port\n    languages:\n      - python\n    message: module setting superuser port\n    patterns:\n      - pattern: set_port($ARG)\n      - metavariable-comparison:\n          comparison: $ARG < 1024 and $ARG % 2 == 0\n          metavariable: $ARG\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ok: superuser-port\nset_port(443)\n# ruleid: superuser-port\n# highlight-next-line\nset_port(80)\n# ok: superuser-port\nset_port(8080)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Building on the previous example, this still matches code such as ",(0,i.jsx)(n.code,{children:"set_port(80)"})," but it no longer matches ",(0,i.jsx)(n.code,{children:"set_port(443)"})," or ",(0,i.jsx)(n.code,{children:"set_port(8080)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"comparison"})," key accepts Python expression using:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Boolean, string, integer, and float literals."}),"\n",(0,i.jsxs)(n.li,{children:["Boolean operators ",(0,i.jsx)(n.code,{children:"not"}),", ",(0,i.jsx)(n.code,{children:"or"}),", and ",(0,i.jsx)(n.code,{children:"and"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Arithmetic operators ",(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"-"}),", ",(0,i.jsx)(n.code,{children:"*"}),", ",(0,i.jsx)(n.code,{children:"/"}),", and ",(0,i.jsx)(n.code,{children:"%"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Comparison operators ",(0,i.jsx)(n.code,{children:"=="}),", ",(0,i.jsx)(n.code,{children:"!="}),", ",(0,i.jsx)(n.code,{children:"<"}),", ",(0,i.jsx)(n.code,{children:"<="}),", ",(0,i.jsx)(n.code,{children:">"}),", and ",(0,i.jsx)(n.code,{children:">="}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Function ",(0,i.jsx)(n.code,{children:"int()"})," to convert strings into integers."]}),"\n",(0,i.jsxs)(n.li,{children:["Function ",(0,i.jsx)(n.code,{children:"str()"})," to convert numbers into strings."]}),"\n",(0,i.jsxs)(n.li,{children:["Function ",(0,i.jsx)(n.code,{children:"today()"})," that gets today's date as a float representing epoch time."]}),"\n",(0,i.jsxs)(n.li,{children:["Function ",(0,i.jsx)(n.code,{children:"strptime()"})," that converts strings in the format ",(0,i.jsx)(n.code,{children:'"yyyy-mm-dd"'})," to a float representing the date in epoch time."]}),"\n",(0,i.jsxs)(n.li,{children:["Lists, together with the ",(0,i.jsx)(n.code,{children:"in"}),", and ",(0,i.jsx)(n.code,{children:"not in"})," infix operators."]}),"\n",(0,i.jsxs)(n.li,{children:["Strings, together with the ",(0,i.jsx)(n.code,{children:"in"})," and ",(0,i.jsx)(n.code,{children:"not in"})," infix operators, for substring containment."]}),"\n",(0,i.jsxs)(n.li,{children:["Function ",(0,i.jsx)(n.code,{children:"re.match()"})," to match a regular expression (without the optional ",(0,i.jsx)(n.code,{children:"flags"})," argument)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can use Semgrep metavariables such as ",(0,i.jsx)(n.code,{children:"$MVAR"}),", which Semgrep evaluates as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"$MVAR"})," binds to a literal, then that literal is the value assigned to ",(0,i.jsx)(n.code,{children:"$MVAR"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"$MVAR"})," binds to a code variable that is a constant, and constant propagation is enabled (as it is by default), then that constant is the value assigned to ",(0,i.jsx)(n.code,{children:"$MVAR"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Otherwise the code bound to the ",(0,i.jsx)(n.code,{children:"$MVAR"})," is kept unevaluated, and its string representation can be obtained using the ",(0,i.jsx)(n.code,{children:"str()"})," function, as in ",(0,i.jsx)(n.code,{children:"str($MVAR)"}),". For example, if ",(0,i.jsx)(n.code,{children:"$MVAR"})," binds to the code variable ",(0,i.jsx)(n.code,{children:"x"}),", ",(0,i.jsx)(n.code,{children:"str($MVAR)"})," evaluates to the string literal ",(0,i.jsx)(n.code,{children:'"x"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"legacy-metavariable-comparison-keys",children:["Legacy ",(0,i.jsx)(n.code,{children:"metavariable-comparison"})," keys"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["You can avoid the use of the legacy keys described below (",(0,i.jsx)(n.code,{children:"base: int"})," and ",(0,i.jsx)(n.code,{children:"strip: bool"}),") by using the ",(0,i.jsx)(n.code,{children:"int()"})," function, as in ",(0,i.jsx)(n.code,{children:"int($ARG) > 0o600"})," or ",(0,i.jsx)(n.code,{children:"int($ARG) > 2147483647"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-comparison"})," operator also takes optional ",(0,i.jsx)(n.code,{children:"base: int"})," and ",(0,i.jsx)(n.code,{children:"strip: bool"})," keys. These keys set the integer base the metavariable value should be interpreted as and remove quotes from the metavariable value, respectively."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: excessive-permissions\n    languages:\n      - python\n    message: module setting excessive permissions\n    patterns:\n      - pattern: set_permissions($ARG)\n      - metavariable-comparison:\n          comparison: $ARG > 0o600\n          metavariable: $ARG\n          base: 8\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ruleid: excessive-permissions\n# highlight-next-line\nset_permissions(0o700)\n# ok: excessive-permissions\nset_permissions(0o400)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This interprets metavariable values found in code as octal. As a result, Semgrep detects ",(0,i.jsx)(n.code,{children:"0700"}),", but it does ",(0,i.jsx)(n.strong,{children:"not"})," detect ",(0,i.jsx)(n.code,{children:"0400"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: int-overflow\n    languages:\n      - python\n    message: Potential integer overflow\n    patterns:\n      - pattern: int($ARG)\n      - metavariable-comparison:\n          strip: true\n          comparison: $ARG > 2147483647\n          metavariable: $ARG\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# ruleid: int-overflow\n# highlight-next-line\nint("2147483648")\n# ok: int-overflow\nint("2147483646")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This removes quotes (",(0,i.jsx)(n.code,{children:"'"}),", ",(0,i.jsx)(n.code,{children:'"'}),", and ",(0,i.jsx)(n.code,{children:"`"}),") from both ends of the metavariable content. As a result, Semgrep detects ",(0,i.jsx)(n.code,{children:'"2147483648"'}),", but it does ",(0,i.jsx)(n.strong,{children:"not"})," detect ",(0,i.jsx)(n.code,{children:'"2147483646"'}),". This is useful when you expect strings to contain integer or float data."]}),"\n",(0,i.jsx)(n.h3,{id:"metavariable-name",children:(0,i.jsx)(n.code,{children:"metavariable-name"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"metavariable-name"})," requires a Semgrep account and the use of Semgrep's proprietary engine since it requires name resolution information. This means that it does ",(0,i.jsx)(n.strong,{children:"not"})," work with the ",(0,i.jsx)(n.code,{children:"--oss-only"})," flag."]}),"\n",(0,i.jsxs)(n.li,{children:["While optional, you can improve the accuracy of ",(0,i.jsx)(n.code,{children:"metavariable-name"})," by enabling ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/getting-started/cli#enable-cross-file-analysis",children:"cross-file analysis"})}),"."]}),"\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"metavariable-name"})," operator adds a constraint to the types of identifiers a metavariable is able to match. Currently the only constraint supported is on the module or namespace an identifier originates from. This is useful for filtering results in languages which don't have a native syntax for fully qualified names, or languages where module names may contain characters which are not legal in identifiers, such as JavaScript or TypeScript."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: insecure-method\n    patterns:\n      - pattern: $MODULE.insecure(...)\n      - metavariable-name:\n          metavariable: $MODULE\n          module: "@foo-bar"\n    message: Uses insecure method from @foo-bar.\n    languages:\n      - javascript\n    severity: ERROR\n'})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// ECMAScript modules\nimport * as lib from \'@foo-bar\';\nimport * as lib2 from \'myotherlib\';\n\n// CommonJS modules\nconst { insecure } = require(\'@foo-bar\');\nconst lib3 = require(\'myotherlib\');\n\n// ruleid: insecure-method\n// highlight-next-line\nlib.insecure("test");\n// ruleid: insecure-method\n// highlight-next-line\ninsecure("test");\n\n// ok: insecure-method\nlib.secure("test");\n// ok: insecure-method\nlib2.insecure("test");\n// ok: insecure-method\nlib3.insecure("test");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the event that a match should occur if the metavariable matches one of a variety of matches, there is also a shorthand ",(0,i.jsx)(n.code,{children:"modules"})," key, which takes a list of module names."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: insecure-method\n    patterns:\n      - pattern: $MODULE.method(...)\n      - metavariable-regex:\n          metavariable: $MODULE\n          modules:\n           - foo\n           - bar\n    message: Uses insecure method from @foo-bar.\n    languages:\n      - javascript\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"This can be useful in instances where there may be multiple API-compatible packages which share an issue."}),"\n",(0,i.jsx)(n.h3,{id:"pattern-not",children:(0,i.jsx)(n.code,{children:"pattern-not"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-not"})," operator is the opposite of the ",(0,i.jsx)(n.code,{children:"pattern"})," operator. It finds code that does not match its expression. This is useful for eliminating common false positives."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: unverified-db-query\n    patterns:\n      - pattern: db_query(...)\n      - pattern-not: db_query(..., verify=True, ...)\n    message: Found unverified db query\n    severity: ERROR\n    languages:\n      - python\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# ruleid: unverified-db-query\n# highlight-next-line\ndb_query("SELECT * FROM ...")\n# ok: unverified-db-query\ndb_query("SELECT * FROM ...", verify=True, env="prod")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-inside",children:(0,i.jsx)(n.code,{children:"pattern-inside"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-inside"})," operator keeps matched findings that reside within its expression. This is useful for finding code inside other pieces of code like functions or if blocks."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: return-in-init\n    patterns:\n      - pattern: return ...\n      - pattern-inside: |\n          class $CLASS:\n            ...\n      - pattern-inside: |\n          def __init__(...):\n              ...\n    message: return should never appear inside a class __init__ function\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class A:\n    def __init__(self):\n        # ruleid: return-in-init\n        # highlight-next-line\n        return None\n\nclass B:\n    def __init__(self):\n        # ok: return-in-init\n        self.inited = True\n\ndef foo():\n    # ok: return-in-init\n    return 5\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-not-inside",children:(0,i.jsx)(n.code,{children:"pattern-not-inside"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pattern-not-inside"})," operator keeps matched findings that do not reside within its expression. It is the opposite of ",(0,i.jsx)(n.code,{children:"pattern-inside"}),". This is useful for finding code that\u2019s missing a corresponding cleanup action like disconnect, close, or shutdown. It\u2019s also useful for finding problematic code that isn't inside code that mitigates the issue."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: open-never-closed\n    patterns:\n      - pattern: $F = open(...)\n      - pattern-not-inside: |\n          $F = open(...)\n          ...\n          $F.close()\n    message: file object opened without corresponding close\n    languages:\n      - python\n    severity: ERROR\n"})}),"\n",(0,i.jsx)(n.p,{children:"The pattern immediately above matches the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def func1():\n    # ruleid: open-never-closed\n    # highlight-next-line\n    fd = open('test.txt')\n    results = fd.read()\n    return results\n\ndef func2():\n    # ok: open-never-closed\n    fd = open('test.txt')\n    results = fd.read()\n    fd.close()\n    return results\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above rule looks for files that are opened but never closed, possibly leading to resource exhaustion. It looks for the ",(0,i.jsx)(n.code,{children:"open(...)"})," pattern ",(0,i.jsx)(n.em,{children:"and not"})," a following ",(0,i.jsx)(n.code,{children:"close()"})," pattern."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"$F"})," metavariable ensures that the same variable name is used in the ",(0,i.jsx)(n.code,{children:"open"})," and ",(0,i.jsx)(n.code,{children:"close"})," calls. The ellipsis operator allows for any arguments to be passed to ",(0,i.jsx)(n.code,{children:"open"})," and any sequence of code statements in-between the ",(0,i.jsx)(n.code,{children:"open"})," and ",(0,i.jsx)(n.code,{children:"close"})," calls. The rule ignores how ",(0,i.jsx)(n.code,{children:"open"})," is called or what happens up to a ",(0,i.jsx)(n.code,{children:"close"})," call\u2014it only needs to make sure ",(0,i.jsx)(n.code,{children:"close"})," is called."]}),"\n",(0,i.jsx)(n.h2,{id:"metavariable-matching",children:"Metavariable matching"}),"\n",(0,i.jsxs)(n.p,{children:["Metavariable matching operates differently for logical AND (",(0,i.jsx)(n.code,{children:"patterns"}),") and logical OR (",(0,i.jsx)(n.code,{children:"pattern-either"}),") parent operators. Behavior is consistent across all child operators: ",(0,i.jsx)(n.code,{children:"pattern"}),", ",(0,i.jsx)(n.code,{children:"pattern-not"}),", ",(0,i.jsx)(n.code,{children:"pattern-regex"}),", ",(0,i.jsx)(n.code,{children:"pattern-inside"}),", ",(0,i.jsx)(n.code,{children:"pattern-not-inside"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"metavariables-in-logical-ands",children:"Metavariables in logical ANDs"}),"\n",(0,i.jsxs)(n.p,{children:["Metavariable values must be identical across sub-patterns when performing logical AND operations with the ",(0,i.jsx)(n.code,{children:"patterns"})," operator."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: function-args-to-open\n    patterns:\n      - pattern-inside: |\n          def $F($X):\n              ...\n      - pattern: open($X)\n    message: "Function argument passed to open() builtin"\n    languages: [python]\n    severity: ERROR\n'})}),"\n",(0,i.jsx)(n.p,{children:"This rule matches the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def foo(path):\n    open(path)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The example rule doesn\u2019t match this code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def foo(path):\n    open(something_else)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"metavariables-in-logical-ors",children:"Metavariables in logical ORs"}),"\n",(0,i.jsxs)(n.p,{children:["Metavariable matching does not affect the matching of logical OR operations with the ",(0,i.jsx)(n.code,{children:"pattern-either"})," operator."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: insecure-function-call\n    pattern-either:\n      - pattern: insecure_func1($X)\n      - pattern: insecure_func2($X)\n    message: "Insecure function use"\n    languages: [python]\n    severity: ERROR\n'})}),"\n",(0,i.jsx)(n.p,{children:"The above rule matches both examples below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"insecure_func1(something)\ninsecure_func2(something)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"insecure_func1(something)\ninsecure_func2(something_else)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"metavariables-in-complex-logic",children:"Metavariables in complex logic"}),"\n",(0,i.jsx)(n.p,{children:"Metavariable matching still affects subsequent logical ORs if the parent is a logical AND."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"patterns:\n  - pattern-inside: |\n      def $F($X):\n        ...\n  - pattern-either:\n      - pattern: bar($X)\n      - pattern: baz($X)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above rule matches both examples below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def foo(something):\n    bar(something)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def foo(something):\n    baz(something)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The example rule doesn\u2019t match this code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def foo(something):\n    bar(something_else)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"options",children:(0,i.jsx)(n.code,{children:"options"})}),"\n",(0,i.jsx)(n.p,{children:"Enable, disable, or modify the following matching features:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Option"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Default"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"ac_matching"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.a,{href:"/semgrep-docs/writing-rules/pattern-syntax#associative-and-commutative-operators",children:"Matching modulo associativity and commutativity"}),", treat Boolean AND/OR as associative, and bitwise AND/OR/XOR as both associative and commutative."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"attr_expr"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Expression patterns (for example: ",(0,i.jsx)(n.code,{children:"f($X)"}),") matches attributes (for example: ",(0,i.jsx)(n.code,{children:"@f(a)"}),")."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"commutative_boolop"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Treat Boolean AND/OR as commutative even if not semantically accurate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"constant_propagation"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.a,{href:"/writing-rules/pattern-syntax/#constants",children:"Constant propagation"}),", including ",(0,i.jsx)(n.a,{href:"/writing-rules/data-flow/constant-propagation",children:"intra-procedural flow-sensitive constant propagation"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"decorators_order_matters"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Match non-keyword attributes (for example: decorators in Python) in order, instead of the order-agnostic default. Keyword attributes (for example: ",(0,i.jsx)(n.code,{children:"static"}),", ",(0,i.jsx)(n.code,{children:"inline"}),", etc) are not affected."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"generic_comment_style"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"none"}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["In generic mode, assume that comments follow the specified syntax. They are then ignored for matching purposes. Allowed values for comment styles are: ",(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)(n.code,{children:"c"})," for traditional C-style comments (",(0,i.jsx)(n.code,{children:"/* ... */"}),"). "]}),(0,i.jsxs)("li",{children:[" ",(0,i.jsx)(n.code,{children:"cpp"})," for modern C or C++ comments (",(0,i.jsx)(n.code,{children:"// ..."})," or ",(0,i.jsx)(n.code,{children:"/* ... */"}),"). "]}),(0,i.jsxs)("li",{children:[" ",(0,i.jsx)(n.code,{children:"shell"})," for shell-style comments (",(0,i.jsx)(n.code,{children:"# ..."}),"). "]})]})," By default, the generic mode does not recognize any comments. Available since Semgrep version 0.96. For more information about generic mode, see ",(0,i.jsx)(n.a,{href:"/writing-rules/generic-pattern-matching",children:"Generic pattern matching"})," documentation."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"generic_ellipsis_max_span"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"10"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["In generic mode, this is the maximum number of newlines that an ellipsis operator ",(0,i.jsx)(n.code,{children:"..."})," can match or equivalently, the maximum number of lines covered by the match minus one. The default value is ",(0,i.jsx)(n.code,{children:"10"})," (newlines) for performance reasons. Increase it with caution. Note that the same effect as ",(0,i.jsx)(n.code,{children:"20"})," can be achieved without changing this setting and by writing ",(0,i.jsx)(n.code,{children:"... ..."})," in the pattern instead of ",(0,i.jsx)(n.code,{children:"..."}),". Setting it to ",(0,i.jsx)(n.code,{children:"0"})," is useful with line-oriented languages (for example ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/INI_file",children:"INI"})," or key-value pairs in general) to force a match to not extend to the next line of code. Available since Semgrep 0.96. For more information about generic mode, see ",(0,i.jsx)(n.a,{href:"/writing-rules/generic-pattern-matching",children:"Generic pattern matching"})," documentation."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"implicit_return"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Return statement patterns (for example ",(0,i.jsx)(n.code,{children:"return $E"}),") match expressions that may be evaluated last in a function as if there was a return keyword in front of those expressions. Only applies to certain expression-based languages, such as Ruby and Julia."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"interfile"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Set this value to ",(0,i.jsx)(n.code,{children:"true"})," for Semgrep to run this rule with cross-function and cross-file analysis. It is ",(0,i.jsx)(n.strong,{children:"required"})," for rules that use cross-function, cross-file analysis."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"symmetric_eq"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Treat equal operations as symmetric (for example: ",(0,i.jsx)(n.code,{children:"a == b"})," is equal to ",(0,i.jsx)(n.code,{children:"b == a"}),")."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"taint_assume_safe_functions"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Experimental option which will be subject to future changes. Used in taint analysis. Assume that function calls do ",(0,i.jsx)(n.strong,{children:"not"})," propagate taint from their arguments to their output. Otherwise, Semgrep always assumes that functions may propagate taint. Can replace ",(0,i.jsx)(n.strong,{children:"not-conflicting"})," sanitizers added in v0.69.0 in the future."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"taint_assume_safe_indexes"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"false"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Used in taint analysis. Assume that an array-access expression is safe even if the index expression is tainted. Otherwise Semgrep assumes that for example: ",(0,i.jsx)(n.code,{children:"a[i]"})," is tainted if ",(0,i.jsx)(n.code,{children:"i"})," is tainted, even if ",(0,i.jsx)(n.code,{children:"a"})," is not. Enabling this option is recommended for high-signal rules, whereas disabling is preferred for audit rules. Currently, it is disabled by default to attain backwards compatibility, but this can change in the near future after some evaluation."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"vardef_assign"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Assignment patterns (for example ",(0,i.jsx)(n.code,{children:"$X = $E"}),") match variable declarations (for example ",(0,i.jsx)(n.code,{children:"var x = 1;"}),")."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"xml_attrs_implicit_ellipsis"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"true"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Any XML/JSX/HTML element patterns have implicit ellipsis for attributes (for example: ",(0,i.jsx)(n.code,{children:"<div />"})," matches ",(0,i.jsx)(n.code,{children:'<div foo="1">'}),"."]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The full list of available options can be consulted in the ",(0,i.jsx)(n.a,{href:"https://github.com/semgrep/semgrep/blob/develop/interfaces/Rule_options.atd",children:"Semgrep matching engine configuration"})," module. Note that options not included in the table above are considered experimental, and they may change or be removed without notice."]}),"\n",(0,i.jsx)(n.h2,{id:"fix",children:(0,i.jsx)(n.code,{children:"fix"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"fix"})," top-level key allows for simple autofixing of a pattern by suggesting an autofix for each match. Run ",(0,i.jsx)(n.code,{children:"semgrep"})," with ",(0,i.jsx)(n.code,{children:"--autofix"})," to apply the changes to the files."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: use-dict-get\n    patterns:\n      - pattern: $DICT[$KEY]\n    fix: $DICT.get($KEY)\n    message: "Use `.get()` method to avoid a KeyNotFound error"\n    languages: [python]\n    severity: ERROR\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For more information about ",(0,i.jsx)(n.code,{children:"fix"})," and ",(0,i.jsx)(n.code,{children:"--autofix"})," see ",(0,i.jsx)(n.a,{href:"/writing-rules/autofix",children:"Autofix"})," documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"metadata",children:(0,i.jsx)(n.code,{children:"metadata"})}),"\n",(0,i.jsxs)(n.p,{children:["Provide additional information for a rule with the ",(0,i.jsx)(n.code,{children:"metadata:"})," key, such as a related CWE, likelihood, OWASP."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: eqeq-is-bad\n    patterns:\n      - [...]\n    message: "useless comparison operation `$X == $X` or `$X != $X`"\n    metadata:\n      cve: CVE-2077-1234\n      discovered-by: Ikwa L\'equale\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The metadata are also displayed in the output of Semgrep if you\u2019re running it with ",(0,i.jsx)(n.code,{children:"--json"}),".\nRules with ",(0,i.jsx)(n.code,{children:"category: security"})," have additional metadata requirements. See ",(0,i.jsx)(n.a,{href:"/contributing/contributing-to-semgrep-rules-repository/#fields-required-by-the-security-category",children:"Including fields required by security category"})," for more information."]}),"\n",(0,i.jsxs)(n.h2,{id:"min-version-and-max-version",children:[(0,i.jsx)(n.code,{children:"min-version"})," and ",(0,i.jsx)(n.code,{children:"max-version"})]}),"\n",(0,i.jsxs)(n.p,{children:["Each rule supports optional fields ",(0,i.jsx)(n.code,{children:"min-version"})," and ",(0,i.jsx)(n.code,{children:"max-version"})," specifying\nminimum and maximum Semgrep versions. If the Semgrep\nversion being used doesn't satisfy these constraints,\nthe rule is skipped without causing a fatal error."]}),"\n",(0,i.jsx)(n.p,{children:"Example rule:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: bad-goflags\n    # earlier semgrep versions can't parse the pattern\n    min-version: 1.31.0\n    pattern: |\n      ENV ... GOFLAGS='-tags=dynamic -buildvcs=false' ...\n    languages: [dockerfile]\n    message: \"We should not use these flags\"\n    severity: WARNING\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Another use case is when a newer version of a rule works better than\nbefore but relies on a new feature. In this case, we could use\n",(0,i.jsx)(n.code,{children:"min-version"})," and ",(0,i.jsx)(n.code,{children:"max-version"})," to ensure that either the older or the\nnewer rule is used but not both. The rules would look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: something-wrong-v1\n    max-version: 1.72.999\n    ...\n  - id: something-wrong-v2\n    min-version: 1.73.0\n    # 10x faster than v1!\n    ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"min-version"}),"/",(0,i.jsx)(n.code,{children:"max-version"})," feature is available since Semgrep\n1.38.0. It is intended primarily for publishing rules that rely on\nnewly released features without causing errors in older Semgrep\ninstallations."]}),"\n",(0,i.jsx)(n.h2,{id:"category",children:(0,i.jsx)(n.code,{children:"category"})}),"\n",(0,i.jsxs)(n.p,{children:["Provide a category for users of the rule. For example: ",(0,i.jsx)(n.code,{children:"best-practice"}),", ",(0,i.jsx)(n.code,{children:"correctness"}),", ",(0,i.jsx)(n.code,{children:"maintainability"}),". For more information, see ",(0,i.jsx)(n.a,{href:"/contributing/contributing-to-semgrep-rules-repository/#semgrep-registry-rule-requirements",children:"Semgrep registry rule requirements"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"paths",children:(0,i.jsx)(n.code,{children:"paths"})}),"\n",(0,i.jsx)(n.h3,{id:"excluding-a-rule-in-paths",children:"Excluding a rule in paths"}),"\n",(0,i.jsxs)(n.p,{children:["To ignore a specific rule on specific files, set the ",(0,i.jsx)(n.code,{children:"paths:"})," key with\none or more filters. The patterns apply to the full file paths\nrelative to the project root."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: eqeq-is-bad\n    pattern: $X == $X\n    paths:\n      exclude:\n        - "src/**/*.jinja2"\n        - "*_test.go"\n        - "project/tests"\n        - project/static/*.js\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When invoked with ",(0,i.jsx)(n.code,{children:"semgrep -f rule.yaml project/"}),", the above rule runs on files inside ",(0,i.jsx)(n.code,{children:"project/"}),", but no results are returned for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["any file with a ",(0,i.jsx)(n.code,{children:".jinja2"})," file extension"]}),"\n",(0,i.jsxs)(n.li,{children:["any file whose name ends in ",(0,i.jsx)(n.code,{children:"_test.go"}),", such as ",(0,i.jsx)(n.code,{children:"project/backend/server_test.go"})]}),"\n",(0,i.jsxs)(n.li,{children:["any file inside ",(0,i.jsx)(n.code,{children:"project/tests"})," or its subdirectories"]}),"\n",(0,i.jsxs)(n.li,{children:["any file matching the ",(0,i.jsx)(n.code,{children:"project/static/*.js"})," glob pattern"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The glob syntax is from ",(0,i.jsxs)(n.a,{href:"https://pypi.org/project/wcmatch/",children:["Python's ",(0,i.jsx)(n.code,{children:"wcmatch"})]})," and is used to match against the given file and all its parent directories."]})}),"\n",(0,i.jsx)(n.h3,{id:"limiting-a-rule-to-paths",children:"Limiting a rule to paths"}),"\n",(0,i.jsxs)(n.p,{children:["Conversely, to run a rule ",(0,i.jsx)(n.em,{children:"only"})," on specific files, set a ",(0,i.jsx)(n.code,{children:"paths:"})," key with one or more of these filters:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: eqeq-is-bad\n    pattern: $X == $X\n    paths:\n      include:\n        - "*_test.go"\n        - "project/server"\n        - "project/schemata"\n        - "project/static/*.js"\n        - "tests/**/*.js"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When invoked with ",(0,i.jsx)(n.code,{children:"semgrep -f rule.yaml project/"}),", this rule runs on files inside ",(0,i.jsx)(n.code,{children:"project/"}),", but results are returned only for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["files whose name ends in ",(0,i.jsx)(n.code,{children:"_test.go"}),", such as ",(0,i.jsx)(n.code,{children:"project/backend/server_test.go"})]}),"\n",(0,i.jsxs)(n.li,{children:["files inside ",(0,i.jsx)(n.code,{children:"project/server"}),", ",(0,i.jsx)(n.code,{children:"project/schemata"}),", or their subdirectories"]}),"\n",(0,i.jsxs)(n.li,{children:["files matching the ",(0,i.jsx)(n.code,{children:"project/static/*.js"})," glob pattern"]}),"\n",(0,i.jsxs)(n.li,{children:["all files with the ",(0,i.jsx)(n.code,{children:".js"})," extension, arbitrary depth inside the tests folder"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If you are writing tests for your rules, add any test file or directory to the included paths as well."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"When mixing inclusion and exclusion filters, the exclusion ones take precedence."})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'paths:\n  include: "project/schemata"\n  exclude: "*_internal.py"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above rule returns results from ",(0,i.jsx)(n.code,{children:"project/schemata/scan.py"})," but not from ",(0,i.jsx)(n.code,{children:"project/schemata/scan_internal.py"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"other-examples",children:"Other examples"}),"\n",(0,i.jsx)(n.p,{children:"This section contains more complex rules that perform advanced code searching."}),"\n",(0,i.jsx)(n.h3,{id:"complete-useless-comparison",children:"Complete useless comparison"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: eqeq-is-bad\n    patterns:\n      - pattern-not-inside: |\n          def __eq__(...):\n              ...\n      - pattern-not-inside: assert(...)\n      - pattern-not-inside: assertTrue(...)\n      - pattern-not-inside: assertFalse(...)\n      - pattern-either:\n          - pattern: $X == $X\n          - pattern: $X != $X\n          - patterns:\n              - pattern-inside: |\n                  def __init__(...):\n                       ...\n              - pattern: self.$X == self.$X\n      - pattern-not: 1 == 1\n    message: "useless comparison operation `$X == $X` or `$X != $X`"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above rule makes use of many operators. It uses ",(0,i.jsx)(n.code,{children:"pattern-either"}),", ",(0,i.jsx)(n.code,{children:"patterns"}),", ",(0,i.jsx)(n.code,{children:"pattern"}),", and ",(0,i.jsx)(n.code,{children:"pattern-inside"})," to carefully consider different cases, and uses ",(0,i.jsx)(n.code,{children:"pattern-not-inside"})," and ",(0,i.jsx)(n.code,{children:"pattern-not"})," to whitelist certain useless comparisons."]}),"\n",(0,i.jsx)(n.h2,{id:"full-specification",children:"Full specification"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/semgrep/semgrep-interfaces/blob/main/rule_schema_v1.yaml",children:"full configuration-file format"})," is defined as\na ",(0,i.jsx)(n.a,{href:"http://json-schema.org/specification.html",children:"jsonschema"})," object."]})]})}function j(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);