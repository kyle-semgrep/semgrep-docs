"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[62686],{14090:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"writing-rules/glossary","title":"SAST and rule-writing glossary","description":"Definitions of static analysis and Semgrep rule-writing terms.","source":"@site/docs/writing-rules/glossary.md","sourceDirName":"writing-rules","slug":"/writing-rules/glossary","permalink":"/semgrep-docs/writing-rules/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/glossary.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752504841000,"frontMatter":{"slug":"glossary","title":"SAST and rule-writing glossary","hide_title":true,"description":"Definitions of static analysis and Semgrep rule-writing terms.","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Data-flow status","permalink":"/semgrep-docs/writing-rules/data-flow/status"},"next":{"title":"Custom rules","permalink":"/semgrep-docs/semgrep-secrets/rules"}}');var a=s(74848),t=s(28453),r=s(34119),l=s(56481);const o={slug:"glossary",title:"SAST and rule-writing glossary",hide_title:!0,description:"Definitions of static analysis and Semgrep rule-writing terms.",tags:["Rule writing"]},c="Static analysis and rule-writing glossary",d={},u=[{value:"Constant propagation",id:"constant-propagation",level:2},{value:"Cross-file analysis",id:"cross-file-analysis",level:2},...r.RM,{value:"Cross-function analysis",id:"cross-function-analysis",level:2},...l.RM,{value:"Error matrix",id:"error-matrix",level:2},{value:"Finding",id:"finding",level:2},{value:"Fully qualified name",id:"fully-qualified-name",level:2},{value:"l-value (left-, or location-value)",id:"l-value-left--or-location-value",level:2},{value:"Metavariable",id:"metavariable",level:2},{value:"Propagator",id:"propagator",level:2},{value:"Rule (Semgrep rule)",id:"rule-semgrep-rule",level:2},{value:"Sanitizers",id:"sanitizers",level:2},{value:"Per-file analysis",id:"per-file-analysis",level:2},{value:"Per-function analysis",id:"per-function-analysis",level:2},{value:"Sink",id:"sink",level:2},{value:"Source",id:"source",level:2},{value:"Taint analysis",id:"taint-analysis",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"static-analysis-and-rule-writing-glossary",children:"Static analysis and rule-writing glossary"})}),"\n",(0,a.jsx)(n.p,{children:"The definitions provided here are specific to Semgrep."}),"\n",(0,a.jsx)(n.h2,{id:"constant-propagation",children:"Constant propagation"}),"\n",(0,a.jsx)(n.p,{children:"Constant propagation is a type of analysis where values known to be constant are substituted in later uses, allowing the value to be used to detect matches. Semgrep can perform constant propagation across files, unless you are running Semgrep Community Edition (CE), which can only propagate within a file."}),"\n",(0,a.jsxs)(n.p,{children:["Constant propagation is applied to all rules unless ",(0,a.jsx)(n.a,{href:"/writing-rules/data-flow/constant-propagation#disable-constant-propagation",children:"it is disabled"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"For example, given the following pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"...\npatterns:\n- pattern: console.log(2)\n"})}),"\n",(0,a.jsx)(n.p,{children:"And the following code snippet:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:"showLineNumbers",children:"const x = 2;\n//highlight-next-line\nconsole.log(x);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The pattern operator ",(0,a.jsx)(n.code,{children:"pattern: print(2)"})," tells Semgrep to match line 2 because it propagates the value ",(0,a.jsx)(n.code,{children:"2"})," from the assignment in line 1 to the ",(0,a.jsx)(n.code,{children:"console.log()"})," function in line."]}),"\n",(0,a.jsx)(n.p,{children:"Constant propagation is one of the many analyses that differentiate Semgrep from grep."}),"\n",(0,a.jsx)(n.h2,{id:"cross-file-analysis",children:"Cross-file analysis"}),"\n",(0,a.jsx)(r.Ay,{}),"\n",(0,a.jsxs)(n.p,{children:["Within Semgrep, cross-file ",(0,a.jsx)(n.strong,{children:"and"})," cross-function analysis is simply referred to as cross-file analysis."]}),"\n",(0,a.jsx)(n.p,{children:"Semgrep CE is limited to per-file analysis."}),"\n",(0,a.jsx)(n.h2,{id:"cross-function-analysis",children:"Cross-function analysis"}),"\n",(0,a.jsx)(l.Ay,{}),"\n",(0,a.jsx)(n.p,{children:"Within Semgrep documentation, cross-function analysis implies intrafile or per-file analysis. Each file is still analyzed as a standalone block, but within the file it takes into account how information flows between functions."}),"\n",(0,a.jsxs)(n.p,{children:["Also known as ",(0,a.jsx)(n.strong,{children:"interprocedural"})," analysis."]}),"\n",(0,a.jsx)(n.h2,{id:"error-matrix",children:"Error matrix"}),"\n",(0,a.jsx)(n.p,{children:"An error matrix is a 2x2 table that visualizes the findings of a Semgrep rule in relation to the vulnerable lines of code it does or doesn't detect. It has two axes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Positive and negative"}),"\n",(0,a.jsx)(n.li,{children:"True or false"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These yield the following combinations:"}),"\n",(0,a.jsxs)("dl",{children:[(0,a.jsx)("dt",{children:"True positive"}),(0,a.jsx)("dd",{children:"The rule detected a piece of code it was intended to find."}),(0,a.jsx)("dt",{children:"False positive"}),(0,a.jsx)("dd",{children:"The rule detected a piece of code it was not intended to find."}),(0,a.jsx)("dt",{children:"True negative"}),(0,a.jsx)("dd",{children:"The rule correctly skipped over a piece of code it wasn't meant to find."}),(0,a.jsx)("dt",{children:"False negative"}),(0,a.jsx)("dd",{children:"The rule failed to detect a piece of code it should have found."})]}),"\n",(0,a.jsxs)(n.p,{children:["Not to be confused with ",(0,a.jsx)(n.strong,{children:"risk matrices"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"finding",children:"Finding"}),"\n",(0,a.jsx)(n.p,{children:"A finding is the core result of Semgrep's analysis. Findings are generated when a Semgrep rule matches a piece of code. Findings can be security issues, bugs, or code that doesn't follow coding conventions."}),"\n",(0,a.jsx)(n.h2,{id:"fully-qualified-name",children:"Fully qualified name"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"fully qualified name"})," refers to a name which uniquely identifies a class, method, type, or module. Languages such as C# and Ruby use ",(0,a.jsx)(n.code,{children:"::"})," to distinguish between fully qualified names and regular names."]}),"\n",(0,a.jsxs)(n.p,{children:["Not to be confused with ",(0,a.jsx)(n.strong,{children:"tokens"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"l-value-left--or-location-value",children:"l-value (left-, or location-value)"}),"\n",(0,a.jsxs)(n.p,{children:["An expression that denotes an object in memory; a memory location, something that you can use in the left-hand side (LHS) of an assignment. For example, ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"array[2]"})," are l-values, but ",(0,a.jsx)(n.code,{children:"2+2"})," is not."]}),"\n",(0,a.jsx)(n.h2,{id:"metavariable",children:"Metavariable"}),"\n",(0,a.jsxs)(n.p,{children:["A metavariable is an abstraction that lets you match something even when you don't know exactly what it is you want to match. It is similar to capture groups in regular expressions. All metavariables begin with a ",(0,a.jsx)(n.code,{children:"$"})," and can only contain uppercase characters, digits, and underscores."]}),"\n",(0,a.jsx)(n.h2,{id:"propagator",children:"Propagator"}),"\n",(0,a.jsx)(n.p,{children:"A propagator is any code that alters a piece of data as the data moves across the program. This includes functions, reassignments, and so on."}),"\n",(0,a.jsxs)(n.p,{children:["When you write rules that perform taint analysis, propagators are pieces of code that you specify through the ",(0,a.jsx)(n.code,{children:"pattern-propagator"})," key as code that always passes tainted data. This is especially relevant when Semgrep performs intraprocedural taint analysis, as there is no way for Semgrep to infer which function calls propagate taint. Thus, explicitly listing propagators is the only way for Semgrep to know if tainted data could be passed within your function."]}),"\n",(0,a.jsx)(n.h2,{id:"rule-semgrep-rule",children:"Rule (Semgrep rule)"}),"\n",(0,a.jsx)(n.p,{children:"A rule is a specification of the patterns that Semgrep must match to the code to generate a finding. Rules are written in YAML. Without a rule, the engine has no instructions on how to match code."}),"\n",(0,a.jsxs)(n.p,{children:["Rules can be run on either Semgrep or its OSS Engine. Only proprietary Semgrep can perform ",(0,a.jsx)(n.a,{href:"#cross-file-analysis",children:"interfile analysis"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["There are two types of rules: ",(0,a.jsx)(n.strong,{children:"search"})," and ",(0,a.jsx)(n.strong,{children:"taint"}),"."]}),"\n",(0,a.jsxs)("dl",{children:[(0,a.jsx)("dt",{children:"Search rules"}),(0,a.jsxs)("dd",{children:[(0,a.jsx)(n.p,{children:"Rules default to this type. Search rules detect matches based on the patterns described by a rule. There are several semantic analyses that search rules perform, such as:"}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Interpreting syntactically different code as semantically equivalent"}),(0,a.jsx)("li",{children:"Constant propagation"}),(0,a.jsx)("li",{children:"Matching a fully qualified name to its reference in the code, even when not fully qualified"}),(0,a.jsx)("li",{children:"Type inference, particularly when using typed metavariables"})]})]}),(0,a.jsx)("dt",{children:"Taint rules"}),(0,a.jsxs)("dd",{children:["Taint rules make use of Semgrep's taint analysis in addition to default search functionalities. Taint rules are able to specify sources, sinks, and propagators of data as well as sanitizers of that data. For more information, see ",(0,a.jsx)("a",{href:"/writing-rules/data-flow/taint-mode/",children:"Taint analysis documentation"}),"."]})]}),"\n",(0,a.jsx)(n.h2,{id:"sanitizers",children:"Sanitizers"}),"\n",(0,a.jsxs)(n.p,{children:["A sanitizer is any piece of code, such as a function or ",(0,a.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions#explicit-conversions",children:"a cast"}),", that can clean untrusted or tainted data. Data from untrusted sources, such as user inputs, may be tainted with unsafe characters. Sanitizers ensure that unsafe characters are removed or stripped from the input."]}),"\n",(0,a.jsxs)(n.p,{children:["An example of a sanitizer is the ",(0,a.jsxs)(n.a,{href:"https://github.com/cure53/DOMPurify",children:[(0,a.jsx)("i",{class:"fas fa-external-link fa-xs"})," ",(0,a.jsx)(n.code,{children:"DOMPurify.sanitize(dirty);"})]})," function from the  DOMPurify package in JavaScript."]}),"\n",(0,a.jsx)(n.h2,{id:"per-file-analysis",children:"Per-file analysis"}),"\n",(0,a.jsx)(n.p,{children:"Also known as intrafile analysis. In per-file analysis, information can only be traced or tracked within a single file. It cannot be traced if it flows to another file."}),"\n",(0,a.jsx)(n.p,{children:"Per-file analysis can include cross-function analysis, aka tracing the flow of information between functions. When discussing the capabilities of pro analysis, per-file analysis implies cross-function analysis."}),"\n",(0,a.jsx)(n.h2,{id:"per-function-analysis",children:"Per-function analysis"}),"\n",(0,a.jsx)(n.p,{children:"Also known as intraprocedural analysis. In per-function analysis, information can only be traced or tracked within a single function."}),"\n",(0,a.jsx)(n.h2,{id:"sink",children:"Sink"}),"\n",(0,a.jsx)(n.p,{children:"In taint analysis, a sink is any vulnerable function that is called with potentially tainted or unsafe data."}),"\n",(0,a.jsx)(n.h2,{id:"source",children:"Source"}),"\n",(0,a.jsx)(n.p,{children:"In taint analysis, a source is any piece of code that assigns or sets tainted data, typically user input."}),"\n",(0,a.jsx)(n.h2,{id:"taint-analysis",children:"Taint analysis"}),"\n",(0,a.jsx)(n.p,{children:"Taint analysis tracks and traces the flow of untrusted or unsafe data. Data coming from sources such as user inputs could be unsafe and used as an attack vector if these inputs are not sanitized. Taint analysis provides a means of tracing that data as it moves through the program from untrusted sources to vulnerable functions."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(96540);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},34119:(e,n,s)=>{s.d(n,{Ay:()=>l,RM:()=>t});var i=s(74848),a=s(28453);const t=[];function r(e){const n={p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Cross-file analysis (also known as ",(0,i.jsx)(n.strong,{children:"interfile analysis"}),") takes into account how information flows between files. In particular, cross-file analysis includes ",(0,i.jsx)(n.strong,{children:"cross-file taint analysis"}),", which tracks unsanitized variables flowing from a source to a sink through arbitrarily many files. Other analyses performed across files include constant propagation and type inference."]}),"\n",(0,i.jsx)(n.p,{children:"Cross-file analysis is usually used in contrast to intrafile, or per-file analysis, where each file is analyzed as a standalone block of code."})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},56481:(e,n,s)=>{s.d(n,{Ay:()=>l,RM:()=>t});var i=s(74848),a=s(28453);const t=[];function r(e){const n={p:"p",...(0,a.R)(),...e.components};return(0,i.jsx)(n.p,{children:"Cross-function analysis means that interactions between functions are taken into account. This improves taint analysis, which tracks unsanitized variables flowing from a source to a sink through arbitrarily many functions."})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}}}]);