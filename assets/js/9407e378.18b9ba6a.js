"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[86082],{10064:(e,n,i)=>{i.d(n,{Ay:()=>o,RM:()=>r});var t=i(74848),s=i(28453);const r=[];function a(e){const n={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The following command runs an optimized set of rules for your project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"semgrep --config p/default\n"})})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},17699:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>p,frontMatter:()=>d,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"cheat-sheets/go-command-injection","title":"Command injection prevention for Go","description":"Prevent command injection in Go.","source":"@site/docs/cheat-sheets/go-command-injection.mdx","sourceDirName":"cheat-sheets","slug":"/cheat-sheets/go-command-injection","permalink":"/semgrep-docs/cheat-sheets/go-command-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/docs/cheat-sheets/go-command-injection.mdx","tags":[],"version":"current","lastUpdatedAt":1752259747000,"frontMatter":{"slug":"go-command-injection","description":"Prevent command injection in Go."},"sidebar":"cheatsheetSidebar","previous":{"title":"Command injection","permalink":"/semgrep-docs/category/command-injection"},"next":{"title":"Command injection prevention for Java","permalink":"/semgrep-docs/cheat-sheets/java-command-injection"}}');var s=i(74848),r=i(28453),a=i(21250),o=i(19610),c=i(10064);const d={slug:"go-command-injection",description:"Prevent command injection in Go."},l="Command injection prevention for Go",m={},u=[...o.RM,{value:"Check your project using Semgrep",id:"check-your-project-using-semgrep",level:3},...c.RM,{value:"1. Running an OS command",id:"1-running-an-os-command",level:2},{value:"1.A. Running OS commands with exec.Command()",id:"1a-running-os-commands-with-execcommand",level:3},{value:"References",id:"references",level:4},{value:"Mitigation",id:"mitigation",level:4},{value:"Semgrep rule",id:"semgrep-rule",level:4},{value:"1.B. Creating exec.Cmd struct",id:"1b-creating-execcmd-struct",level:3},{value:"References",id:"references-1",level:4},{value:"Mitigation",id:"mitigation-1",level:4},{value:"Semgrep rule",id:"semgrep-rule-1",level:4},{value:"1.C. Writing to a command&#39;s StdinPipe",id:"1c-writing-to-a-commands-stdinpipe",level:3},{value:"References",id:"references-2",level:4},{value:"Mitigation",id:"mitigation-2",level:4},{value:"Semgrep rule",id:"semgrep-rule-2",level:4},{value:"1.D. Running OS commands with syscall.Exec()",id:"1d-running-os-commands-with-syscallexec",level:3},{value:"References",id:"references-3",level:4},{value:"Mitigation",id:"mitigation-3",level:4},{value:"Semgrep rule",id:"semgrep-rule-3",level:4}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"command-injection-prevention-for-go",children:"Command injection prevention for Go"})}),"\n",(0,s.jsx)(o.Ay,{}),"\n",(0,s.jsx)(n.h3,{id:"check-your-project-using-semgrep",children:"Check your project using Semgrep"}),"\n",(0,s.jsx)(c.Ay,{}),"\n",(0,s.jsx)(n.h2,{id:"1-running-an-os-command",children:"1. Running an OS command"}),"\n",(0,s.jsx)(n.h3,{id:"1a-running-os-commands-with-execcommand",children:"1.A. Running OS commands with exec.Command()"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Command"})," and ",(0,s.jsx)(n.code,{children:"CommandContext"})," execute commands provided as arguments. If unverified user data can reach its call site, this may end up in a command injection vulnerability. Both ",(0,s.jsx)(n.code,{children:"Command"})," and ",(0,s.jsx)(n.code,{children:"CommandContext"})," have built-in protections that do not let command arguments cause trouble. But ensure that the command itself is not controlled by the user, also do not use ",(0,s.jsx)(n.code,{children:"sh"}),", because internal protection does not work in this case."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "os/exec"\n\nfunc main() {\n  // Command example\n  cmd := exec.Command("echo", "hello")\n\n  // CommandContext example\n  err := exec.CommandContext(ctx, "sleep", "5").Run()\n\n  // Not vulnerable\n  cmd := exec.Command("echo", "1; cat /etc/passwd")\n\n  // Vunerable\n  userInput :=  "echo 1 | cat /etc/passwd" // value supplied by user input\n  out, _ = exec.Command("sh", "-c", userInput).Output()\n\n  // Vulnerable\n  userInput1 := "cat" // value supplied by user input\n  userInput2 := "/etc/passwd" // value supplied by user input\n  out, _ = exec.Command(userInput1, userInput2)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/os/exec/#Command",children:[(0,s.jsx)(n.code,{children:"Command"})," documentation"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/os/exec/#CommandContext",children:[(0,s.jsx)(n.code,{children:"CommandContext"})," documentation"]})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"mitigation",children:"Mitigation"}),"\n",(0,s.jsxs)(n.p,{children:["Do not let the user input in ",(0,s.jsx)(n.code,{children:"exec.Command"})," and ",(0,s.jsx)(n.code,{children:"exec.CommandContext"})," functions. Alternatively:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always try to use internal Go API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited."}),"\n",(0,s.jsxs)(n.li,{children:["Do not include command arguments in a command string, use parameterization instead. For example:",(0,s.jsx)("br",{}),"\nUse:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'exec.Command("/path/to/myCommand", "myArg1", inputValue)\n'})}),"\n","Instead of:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'exec.Command("bash", "-c", "myCommand myArg1 " + inputValue)\n'})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible, then strip everything except alphanumeric characters from an input provided for the command string and arguments."}),"\n",(0,s.jsx)(n.li,{children:"Try to avoid non-literal values for the command string."}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible, then do not let running arbitrary commands, use an allowlist for inputs."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"semgrep-rule",children:"Semgrep rule"}),"\n",(0,s.jsx)(a.A,{ruleId:"go.lang.security.audit.dangerous-exec-command.dangerous-exec-command"}),"\n",(0,s.jsx)(n.h3,{id:"1b-creating-execcmd-struct",children:"1.B. Creating exec.Cmd struct"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Cmd"})," represents an external command that is prepared or run. If unverified user data reaches its call site it can result in a command injection vulnerability. Make sure that the command path and first argument are not controlled by the user, also do not use ",(0,s.jsx)(n.code,{children:"sh"}),", because internal protection does not work in such a case."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n  "os/exec"\n  "os"\n)\n\nfunc main() {\n  cmd := &exec.Cmd {\n    // Path is the path of the command to run.\n    Path: "/bin/echo",\n    // Args holds command line arguments, including the command itself as Args[0].\n    Args: []string{ "echo", "hello world" },\n    Stdout: os.Stdout,\n    Stderr: os.Stdout,\n  }\n  cmd.Start();\n  cmd.Wait();\n\n  // Args can be also ommited and {Path} will be used by default\n  cmd := &exec.Cmd {\n    Path: "/bin/echo"\n  }\n\n  // Vulnerable\n  userInput := "/pwn/exploit" // value supplied by user input\n  cmd := &exec.Cmd {\n    Path: userInput\n  }\n\n  // Vulnerable\n  userInput1 := "/bin/bash" // value supplied by user input\n  userInput2 := []string{ "bash", "exploit.sh" } // value supplied by user input\n  cmd := &exec.Cmd {\n    Path: userInput1,\n    Args: userInput2\n  }\n\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"references-1",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/os/exec/#Cmd",children:[(0,s.jsx)(n.code,{children:"Cmd"})," struct documentation"]})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"mitigation-1",children:"Mitigation"}),"\n",(0,s.jsxs)(n.p,{children:["Do not let the user input in ",(0,s.jsx)(n.code,{children:"exec.Cmd"})," struct. Alternatively:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always try to use internal Go API (if it exists) instead of running an OS command."}),"\n",(0,s.jsx)(n.li,{children:"Try to avoid non-literal values for the command string."}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible, then do not let running arbitrary commands, use an allowlist for inputs."}),"\n",(0,s.jsxs)(n.li,{children:["Do not include command arguments in a command string, use parameterization instead. For example:",(0,s.jsx)("br",{}),"\nUse:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'cmd := &exec.Cmd {\n  Path: "/path/to/myCommand",\n  Args: []string{ "myCommand", "myArg1", inputValue },\n}\n'})}),"\n","Instead of:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'cmd := &exec.Cmd {\n  Path: "/bin/bash",\n  Args: []string{ "bash", "-c", "myCommand myArg1 " + inputValue },\n}\n'})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible - strip everything except alphanumeric characters from an input provided for the command string and arguments."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"semgrep-rule-1",children:"Semgrep rule"}),"\n",(0,s.jsx)(a.A,{ruleId:"go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"}),"\n",(0,s.jsx)(n.h3,{id:"1c-writing-to-a-commands-stdinpipe",children:"1.C. Writing to a command's StdinPipe"}),"\n",(0,s.jsxs)(n.p,{children:["Command's ",(0,s.jsx)(n.code,{children:"StdinPipe"})," returns a pipe that is connected to the command's standard input when it starts. A command injection vulnerability happens if unverified user data reaches ",(0,s.jsx)(n.code,{children:"StdinPipe"}),". A malicious actor can inject a malicious script to execute arbitrary code."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n  "fmt"\n  "os/exec"\n)\n\nfunc main() {\n  cmd := exec.Command("bash")\n  // StdinPipe initialization\n  cmdWriter, _ := cmd.StdinPipe() \n  cmd.Start()\n  // Vulnerability when `password` controlled by user input\n  cmdInput := fmt.Sprintf("sshpass -p %s", password)\n  // Writing to StdinPipe\n  cmdWriter.Write([]byte(cmdInput + "\\n"))\n  cmd.Wait()\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"references-2",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/os/exec/#Cmd.StdinPipe",children:[(0,s.jsx)(n.code,{children:"Cmd.StdinPipe"})," documentation"]})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"mitigation-2",children:"Mitigation"}),"\n",(0,s.jsxs)(n.p,{children:["Do not let the user input in command's ",(0,s.jsx)(n.code,{children:"StdinPipe"}),". Alternatively:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always try to use internal Go API (if it exists) instead of running an OS command."}),"\n",(0,s.jsxs)(n.li,{children:["Do not use it to run the ",(0,s.jsx)(n.code,{children:"bash"})," command and to avoid non-literal values for the command string."]}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible, then do not let running arbitrary commands, use a white list for inputs."}),"\n",(0,s.jsx)(n.li,{children:"Strip everything except alphanumeric characters from an input provided for the StdinPipe input."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"semgrep-rule-2",children:"Semgrep rule"}),"\n",(0,s.jsx)(a.A,{ruleId:"go.lang.security.audit.dangerous-command-write.dangerous-command-write"}),"\n",(0,s.jsx)(n.h3,{id:"1d-running-os-commands-with-syscallexec",children:"1.D. Running OS commands with syscall.Exec()"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Exec"}),"or ",(0,s.jsx)(n.code,{children:"ForkExec"})," invokes the execve(2) system call. If unverified user data can reach its call site, this is a command injection vulnerability. Make sure that the command is not controlled by the user, also do not run ",(0,s.jsx)(n.code,{children:"sh"})," with any possibility of user input involved in command arguments."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "syscall"\nimport "os"\nimport "os/exec"\n\n// Exec invokes the execve(2) system call.\nsyscall.Exec(binary, args, env)\n// ForkExec - combination of fork and exec, careful to be thread safe.\nsyscall.ForkExec(binary, args, env)\n\nfunc vulnerableCode(userInput string) {\n  //  Vulnerable: Do not let `path` be defined by user input\n  path, _ := exec.LookPath(userInput)\n  args := []string{"ls", "-a", "-l", "-h"}\n  env := os.Environ()\n  execErr := syscall.Exec(path, args, env)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"references-3",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/syscall/#Exec",children:[(0,s.jsx)(n.code,{children:"Exec"})," documentation"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://golang.org/pkg/syscall/#ForkExec",children:[(0,s.jsx)(n.code,{children:"ForkExec"})," documentation"]})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"mitigation-3",children:"Mitigation"}),"\n",(0,s.jsxs)(n.p,{children:["Do not let the user input in ",(0,s.jsx)(n.code,{children:"syscall.Exec"})," and ",(0,s.jsx)(n.code,{children:"syscall.ForkExec"})," functions. Alternatively:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always try to use internal Go API (if it exists) instead of running an OS command."}),"\n",(0,s.jsx)(n.li,{children:"Try to avoid non-literal values for the command string."}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible, then do not let running arbitrary commands, use an allowlist for inputs."}),"\n",(0,s.jsxs)(n.li,{children:["Do not include command arguments in a command string, use parameterization instead. For example:",(0,s.jsx)("br",{}),"\nUse:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'syscall.Exec("/path/to/myCommand", []string{"myCommand", "myArg1", inputValue}, env)\n'})}),"\n","Instead of:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'syscall.Exec("/bin/bash", []string{"bash", "-c", "myCommand myArg1 " + inputValue}, env)\n'})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If it is not possible - strip everything except alphanumeric characters from an input provided for the command string and arguments."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"semgrep-rule-3",children:"Semgrep rule"}),"\n",(0,s.jsx)(a.A,{ruleId:"go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec"})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},19610:(e,n,i)=>{i.d(n,{Ay:()=>o,RM:()=>r});var t=i(74848),s=i(28453);const r=[];function a(e){const n={p:"p",...(0,s.R)(),...e.components};return(0,t.jsx)(n.p,{children:"This is a command injection prevention cheat sheet by Semgrep, Inc. It contains code patterns of potential ways to run an OS command in an application. Instead of scrutinizing code for exploitable vulnerabilities, the recommendations in this cheat sheet pave a safe road for developers that mitigate the possibility of command injection in your code. By following these recommendations, you can be reasonably sure your code is free of command injection."})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},21250:(e,n,i)=>{i.d(n,{A:()=>s});i(96540);var t=i(74848);function s(e){let{ruleId:n}=e;const i=new URL("https://semgrep.dev/r");return i.searchParams.set("q",n),(0,t.jsx)("a",{href:i,target:"_blank",children:n})}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);