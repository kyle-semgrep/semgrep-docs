"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[15826],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var r=s(96540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},35544:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"kb/rules/rule-file-perf-principles","title":"Performance principles for rules and files to abide by when scanning repositories","description":"Learn the rule and file performance principles to abide by when scanning repositories to optimize scan times.","source":"@site/docs/kb/rules/rule-file-perf-principles.md","sourceDirName":"kb/rules","slug":"/kb/rules/rule-file-perf-principles","permalink":"/docs/kb/rules/rule-file-perf-principles","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/kb/rules/rule-file-perf-principles.md","tags":[{"inline":true,"label":"Rules","permalink":"/docs/tags/rules"},{"inline":true,"label":"Semgrep Registry","permalink":"/docs/tags/semgrep-registry"},{"inline":true,"label":"Semgrep Code","permalink":"/docs/tags/semgrep-code"}],"version":"current","lastUpdatedAt":1752252315000,"frontMatter":{"description":"Learn the rule and file performance principles to abide by when scanning repositories to optimize scan times.","tags":["Rules","Semgrep Registry","Semgrep Code"]},"sidebar":"kbSidebar","previous":{"title":"Fix pattern parse errors when running rules","permalink":"/docs/kb/rules/pattern-parse-error"},"next":{"title":"Why do new rules keep appearing in Comment or Block mode?","permalink":"/docs/kb/rules/ruleset-default-mode"}}');var i=s(74848),t=s(28453);const l={description:"Learn the rule and file performance principles to abide by when scanning repositories to optimize scan times.",tags:["Rules","Semgrep Registry","Semgrep Code"]},o="Performance principles for rules and files to abide by when scanning repositories",a={},c=[{value:"Rules",id:"rules",level:2},{value:"Files",id:"files",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"performance-principles-for-rules-and-files-to-abide-by-when-scanning-repositories",children:"Performance principles for rules and files to abide by when scanning repositories"})}),"\n",(0,i.jsx)(n.h2,{id:"rules",children:"Rules"}),"\n",(0,i.jsxs)(n.p,{children:["The amount of time required for rules to run scales better than linearly when\nadding interfile rules, which are those with ",(0,i.jsx)(n.code,{children:"interfile: true"})," in the ",(0,i.jsx)(n.code,{children:"options"})," key.\nThat is, doubling the number of interfile rules increases the runtime, but not\nby double. However, some rules run faster than others, and adding a slow rule\nwhen all the rest are fast can cause a significant slowdown."]}),"\n",(0,i.jsxs)(n.p,{children:["Rules are slower if the sub-patterns, such as ",(0,i.jsx)(n.code,{children:"pattern: <... $X ...>"}),", result in\na greater number of matches. When writing rules, pay special attention to the\nproblems raised by sub-pattern matches. The most important factor for runtime is\nthe time spent adding to various lists or sets."]}),"\n",(0,i.jsxs)(n.p,{children:["You can benchmark your rules by adding the ",(0,i.jsx)(n.code,{children:"--time"})," flag to your ",(0,i.jsx)(n.code,{children:"semgrep scan"}),"\ncommand. When you use this flag, your results return with a timing summary; if\nyour output format is JSON, you'll see times for each rule-target pair."]}),"\n",(0,i.jsx)(n.h2,{id:"files",children:"Files"}),"\n",(0,i.jsxs)(n.p,{children:["Generally, the time required to scan files scales linearly with the number of\nfiles scanned, but file size is still important. Overall, the time taken is\n",(0,i.jsx)(n.strong,{children:"time for setup work + time for matching"}),". For setup work, files aren\u2019t\nanalyzed alone but in groups of mutually dependent files called strongly\nconnected components (SCCs)."]}),"\n",(0,i.jsxs)(n.p,{children:["The time for setup work is ",(0,i.jsx)(n.strong,{children:"number of SCCs * time for each SCC"}),", where the\ntime for each SCC grows, in the worst case, exponentially up to certain limits\nset by Semgrep. This means that making SCCs larger with more mutually dependent\nfiles affects scan time more negatively than adding more SCCs."]}),"\n",(0,i.jsxs)(n.p,{children:["The time for matching is ",(0,i.jsx)(n.strong,{children:"number of files * time to match each file"}),". The time\nto check each file can also grow, in the worst case, exponentially, especially\nwhen a rule has a lot of matches in subpatterns. However, the default settings\nof ",(0,i.jsx)(n.code,{children:"--timeout 5"})," ",(0,i.jsx)(n.code,{children:"--timeout-threshold 3"})," means that a file times out if:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"5 seconds elapse without the match process completing"}),"\n",(0,i.jsx)(n.li,{children:"3 rules time out"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You can configure these flags to skip long files after a shorter timeout period\nor when a smaller number of rules timeout. Usually, Semgrep matches files pretty\nquickly, but minified Javascript files can cause significant performance issues."}),"\n",(0,i.jsxs)(n.p,{children:["Semgrep sets a limit of 1 MB for each file scanned, but you can modify this\nsetting using the ",(0,i.jsx)(n.code,{children:"--max-target-bytes"})," flag. For example, if your flag is\n",(0,i.jsx)(n.code,{children:"--max-target-bytes=1500000"}),", Semgrep ignores any larger file. You can get a\nfull list of files Semgrep skips by including the ",(0,i.jsx)(n.code,{children:"--verbose"})," flag and\ninspecting ",(0,i.jsx)(n.code,{children:"ci.log"}),". This information helps you determine the feasibility of\nincluding those files and whether you should adjust the maximum file size limit\nto scan such files."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);