"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[96849],{26134:(e,t,s)=>{s.d(t,{Ay:()=>o,RM:()=>r});var n=s(74848),a=s(28453);const r=[];function i(e){const t={a:"a",admonition:"admonition",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["In principle, the data-flow analysis engine (which provides taint tracking, constant propagation, and symbolic propagation) can run on any language ",(0,n.jsx)(t.a,{href:"/docs/supported-languages",children:"supported by Semgrep"}),". However, the level of support is lower than for the regular Semgrep matching engine."]}),"\n",(0,n.jsxs)(t.p,{children:["When Semgrep performs an analysis of the code, it creates an ",(0,n.jsx)(t.strong,{children:"abstract syntax tree"})," (AST) which is then translated into an analysis-friendly ",(0,n.jsx)(t.strong,{children:"intermediate language"})," (IL). Subsequently, Semgrep runs mostly language-agnostic analysis on IL. However, this translation is not fully complete."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsx)(t.p,{children:"There can be features of some languages that Semgrep does not analyze correctly while using data-flow analysis. Consequently, Semgrep does not fail even if it finds an unsupported construct. The analysis continues while the construct is ignored. This can result in Semgrep not matching some code that should be matched (false negatives) or matching a code that should not be matched (false positives)."})}),"\n",(0,n.jsxs)(t.p,{children:["Please, help us to improve and report any issues you encounter by creating an issue on Semgrep ",(0,n.jsx)(t.a,{href:"https://github.com/semgrep/semgrep/issues/new/choose",children:"GitHub"})," page."]})]})}function o(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var n=s(96540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}},33486:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"writing-rules/data-flow/status","title":"Data-flow status","description":"The status of the data-flow analysis.","source":"@site/docs/writing-rules/data-flow/status.md","sourceDirName":"writing-rules/data-flow","slug":"/writing-rules/data-flow/status","permalink":"/semgrep-docs/writing-rules/data-flow/status","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/docs/writing-rules/data-flow/status.md","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752259747000,"frontMatter":{"slug":"status","append_help_link":true,"tags":["Rule writing"],"description":"The status of the data-flow analysis."},"sidebar":"rulewritingSidebar","previous":{"title":"Taint analysis","permalink":"/semgrep-docs/writing-rules/data-flow/taint-mode"},"next":{"title":"SAST and rule-writing glossary","permalink":"/semgrep-docs/writing-rules/glossary"}}');var a=s(74848),r=s(28453),i=s(26134);const o={slug:"status",append_help_link:!0,tags:["Rule writing"],description:"The status of the data-flow analysis."},l="Data-flow status",c={},u=[...i.RM];function d(e){const t={h1:"h1",header:"header",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"data-flow-status",children:"Data-flow status"})}),"\n",(0,a.jsx)(i.Ay,{})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);