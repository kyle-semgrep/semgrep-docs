"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[80635],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var r=t(96540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},70543:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"writing-rules/experiments/deprecated-experiments","title":"Deprecated experiments","description":"Equivalences","source":"@site/docs/writing-rules/experiments/deprecated-experiments.md","sourceDirName":"writing-rules/experiments","slug":"/writing-rules/experiments/deprecated-experiments","permalink":"/docs/writing-rules/experiments/deprecated-experiments","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main?base=kyle-semgrep:main/docs/writing-rules/experiments/deprecated-experiments.md","tags":[],"version":"current","lastUpdatedAt":1752253235000,"frontMatter":{},"sidebar":"rulewritingSidebar","previous":{"title":"Match captured metavariables with specific types","permalink":"/docs/writing-rules/experiments/metavariable-type"},"next":{"title":"Engine overview","permalink":"/docs/writing-rules/data-flow/data-flow-overview"}}');var s=t(74848),a=t(28453);const i={},d="Deprecated experiments",c={},l=[{value:"Equivalences",id:"equivalences",level:2},{value:"Extract mode",id:"extract-mode",level:2},{value:"Example of extract mode",id:"example-of-extract-mode",level:3},{value:"Extract mode rule schema",id:"extract-mode-rule-schema",level:3},{value:"<code>extract</code>",id:"extract",level:4},{value:"<code>dest-language</code>",id:"dest-language",level:4},{value:"<code>transform</code>",id:"transform",level:4},{value:"<code>reduce</code>",id:"reduce",level:4},{value:"Limitations of extract mode",id:"limitations-of-extract-mode",level:3},{value:"Turbo Mode",id:"turbo-mode",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"deprecated-experiments",children:"Deprecated experiments"})}),"\n",(0,s.jsx)(n.h2,{id:"equivalences",children:"Equivalences"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This feature was deprecated in Semgrep v0.61.0."})}),"\n",(0,s.jsxs)(n.p,{children:["Equivalences enable defining equivalent code patterns (i.e. a commutative property: ",(0,s.jsx)(n.code,{children:"$X + $Y <==> $Y + $X"}),"). Equivalence rules use the ",(0,s.jsx)(n.code,{children:"equivalences"})," top-level key and one ",(0,s.jsx)(n.code,{children:"equivalence"})," key for each equivalence."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=jNnn",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,s.jsx)(n.h2,{id:"extract-mode",children:"Extract mode"}),"\n",(0,s.jsx)(n.admonition,{title:"Deprecation notice",type:"danger",children:(0,s.jsx)(n.p,{children:"As of Semgrep 1.65.0, extract mode has been deprecated and removed from Semgrep. This feature may return in the future."})}),"\n",(0,s.jsx)(n.p,{children:"Extract mode enables you to run existing rules on subsections of files where the rule language is different than the language of the file. For example, running a JavaScript rule on code contained inside of script tags in an HTML document."}),"\n",(0,s.jsx)(n.h3,{id:"example-of-extract-mode",children:"Example of extract mode"}),"\n",(0,s.jsx)(n.p,{children:"Without extract mode, writing rules to validate template, Markdown or configuration files which contain code in another language can be burdensome and require significant rule duplication."}),"\n",(0,s.jsxs)(n.p,{children:["Let's take the following Bash rule as an example (a simplified version of the ",(0,s.jsx)(n.a,{href:"https://github.com/semgrep/semgrep-rules/blob/release/bash/curl/security/curl-eval.yaml",children:(0,s.jsx)(n.code,{children:"curl-eval"})})," rule from the Semgrep Registry):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"rules:\n  - id: curl-eval\n    severity: WARNING\n    languages:\n      - bash\n    message: Evaluating data from a `curl` command is unsafe.\n    mode: taint\n    pattern-sources:\n      - pattern: |\n          $(curl ...)\n      - pattern: |\n          `curl ...`\n    pattern-sinks:\n      - pattern: eval ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Usually, Semgrep uses this rule only against Bash files. However, a project might contain Dockerfiles or Python scripts that invoke Bash commands\u2014without an extract mode rule, Semgrep does ",(0,s.jsx)(n.strong,{children:"not"})," run any Bash rules against commands contained in files of different languages."]}),"\n",(0,s.jsxs)(n.p,{children:["However, with extract mode, you can provide Semgrep with instructions on how to extract any Bash commands used in a Docker ",(0,s.jsx)(n.code,{children:"RUN"})," instruction or as an argument to Python's ",(0,s.jsx)(n.code,{children:"os.system"})," standard library function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - id: extract-docker-run-to-bash\n    mode: extract\n    languages:\n      - dockerfile\n    pattern: RUN $...CMD\n    extract: $...CMD\n    dest-language: bash\n  - id: extract-python-os-system-to-bash\n    mode: extract\n    languages:\n      - python\n    pattern: os.system("$CMD")\n    extract: $CMD\n    dest-language: bash\n'})}),"\n",(0,s.jsxs)(n.p,{children:["By adding the extract mode rules as shown in the previous code snippet, Semgrep matches Bash code contained in the following Python file and reports the contained Bash as matching against the ",(0,s.jsx)(n.code,{children:"curl-eval"})," rule."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from os import system\n\nif system(\'eval `curl -s "http://www.very-secure-website.net"`\'):\n    print("Command failed!")\nelse:\n    print("Success")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Likewise, if a query included a Dockerfile with an equivalent Bash command, Semgrep reports the contained Bash as matching against the ",(0,s.jsx)(n.code,{children:"curl-eval"})," rule. See the following Dockerfile example that contains a Bash command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dockerfile",children:'FROM fedora\nRUN dnf install -y unzip zip curl which\nRUN eval `curl -s "http://www.very-secure-website.net"`\n'})}),"\n",(0,s.jsx)(n.h3,{id:"extract-mode-rule-schema",children:"Extract mode rule schema"}),"\n",(0,s.jsxs)(n.p,{children:["Extract mode rules ",(0,s.jsx)(n.strong,{children:"require"})," the following ",(0,s.jsx)(n.a,{href:"/writing-rules/rule-syntax/#required",children:"usual Semgrep rule keys"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"id"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"languages"})}),"\n",(0,s.jsxs)(n.li,{children:["One of ",(0,s.jsx)(n.code,{children:"pattern"}),", ",(0,s.jsx)(n.code,{children:"patterns"}),", ",(0,s.jsx)(n.code,{children:"pattern-either"}),", or ",(0,s.jsx)(n.code,{children:"pattern-regex"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Extract mode rules ",(0,s.jsx)(n.strong,{children:"also require"})," two additional fields:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"extract"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"dest-language"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Extract mode has two ",(0,s.jsx)(n.strong,{children:"optional"})," fields:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"reduce"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"json"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The fields specific to extract mode are further explained in the sections below."}),"\n",(0,s.jsx)(n.h4,{id:"extract",children:(0,s.jsx)(n.code,{children:"extract"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"extract"})," key is required in extract mode. The value must be a metavariable appearing in your pattern(s). Semgrep uses the code bound to the metavariable for subsequent queries of non-extract mode rules targeting ",(0,s.jsx)(n.code,{children:"dest-language"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"dest-language",children:(0,s.jsx)(n.code,{children:"dest-language"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"dest-language"})," key is required in extract mode. The value must be a ",(0,s.jsx)(n.a,{href:"/writing-rules/rule-syntax/#language-extensions-and-languages-key-values",children:"language tag"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"transform",children:(0,s.jsx)(n.code,{children:"transform"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"transform"})," is an optional key in the extract mode. The value of this key specifies whether the extracted content is parsed as raw source code or as a JSON array."]}),"\n",(0,s.jsxs)(n.p,{children:["The value of ",(0,s.jsx)(n.code,{children:"transform"})," key must be one of the following:"]}),"\n",(0,s.jsxs)("dl",{children:[(0,s.jsx)("dt",{children:(0,s.jsx)("code",{children:"no_transform"})}),(0,s.jsx)("dd",{children:(0,s.jsxs)("p",{children:["Extract the matched content as raw source code. This is the ",(0,s.jsx)("b",{children:"default"})," value."]})}),(0,s.jsx)("dt",{children:(0,s.jsx)("code",{children:"concat_json_string_array"})}),(0,s.jsx)("dd",{children:(0,s.jsx)("p",{children:"Extract the matched content as a JSON array. Each element of the array correspond to a line the resulting source code. This value is useful in extracting code from JSON formats such as Jupyter Notebooks."})})]}),"\n",(0,s.jsx)(n.h4,{id:"reduce",children:(0,s.jsx)(n.code,{children:"reduce"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"reduce"})," key is optional in extract mode. The value of this key specifies a method to combine the ranges extracted by a single rule within a file."]}),"\n",(0,s.jsxs)(n.p,{children:["The value of ",(0,s.jsx)(n.code,{children:"reduce"})," key must be one of the following:"]}),"\n",(0,s.jsxs)("dl",{children:[(0,s.jsx)("dt",{children:(0,s.jsx)("code",{children:"separate"})}),(0,s.jsx)("dd",{children:(0,s.jsxs)("p",{children:["Treat all matched ranges as separate units for subsequent queries. This is the ",(0,s.jsx)("b",{children:"default"})," value."]})}),(0,s.jsx)("dt",{children:(0,s.jsx)("code",{children:"concat"})}),(0,s.jsx)("dd",{children:(0,s.jsx)("p",{children:"Concatenate all matched ranges together and treat this result as a single unit for subsequent queries."})})]}),"\n",(0,s.jsx)(n.h3,{id:"limitations-of-extract-mode",children:"Limitations of extract mode"}),"\n",(0,s.jsxs)(n.p,{children:["Although extract mode supports JSON array decoding with the ",(0,s.jsx)(n.code,{children:"json"})," key, it does not support other additional processing for the extracted text, such as unescaping strings."]}),"\n",(0,s.jsx)(n.p,{children:"While extract mode can help to enable rules which try and track taint across a language boundary within a file, taint rules cannot have a source and sink split across the original file and extracted text."}),"\n",(0,s.jsx)(n.h2,{id:"turbo-mode",children:"Turbo Mode"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:"As of June 16th, 2025, Turbo Mode has been deprecated and removed from the Semgrep Playground."})]}),"\n",(0,s.jsx)(n.p,{children:"Turbo Mode was a feature in Semgrep Editor that automatically ran your rule against Semgrep CE after every keystroke or change to the rule."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);