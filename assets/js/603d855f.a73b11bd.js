"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[48532],{4863:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>p,contentTitle:()=>c,default:()=>y,frontMatter:()=>d,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"semgrep-supply-chain/glossary","title":"Supply Chain glossary","description":"Definitions of Semgrep Supply Chain and software composition analysis (SCA) terms.","source":"@site/docs/semgrep-supply-chain/glossary.md","sourceDirName":"semgrep-supply-chain","slug":"/semgrep-supply-chain/glossary","permalink":"/semgrep-docs/semgrep-supply-chain/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/semgrep-supply-chain/glossary.md","tags":[{"inline":true,"label":"Semgrep Supply Chain","permalink":"/semgrep-docs/tags/semgrep-supply-chain"}],"version":"current","lastUpdatedAt":1752262761000,"frontMatter":{"slug":"glossary","append_help_link":true,"description":"Definitions of Semgrep Supply Chain and software composition analysis (SCA) terms.","tags":["Semgrep Supply Chain"],"title":"Supply Chain glossary","hide_title":true},"sidebar":"scanSidebar","previous":{"title":"Code glossary","permalink":"/semgrep-docs/semgrep-code/glossary"},"next":{"title":"Experimental features","permalink":"/semgrep-docs/category/experimental-features"}}');var s=n(74848),r=n(28453),t=n(90050),l=n(82305),o=n(57579);const d={slug:"glossary",append_help_link:!0,description:"Definitions of Semgrep Supply Chain and software composition analysis (SCA) terms.",tags:["Semgrep Supply Chain"],title:"Supply Chain glossary",hide_title:!0},c="Semgrep Supply Chain glossary",p={},h=[{value:"Advisory",id:"advisory",level:2},{value:"Dependency",id:"dependency",level:2},{value:"Exploitability",id:"exploitability",level:2},{value:"EPSS probability",id:"epss-probability",level:2},...l.RM,{value:"Lockfile",id:"lockfile",level:2},{value:"Rules without reachability analysis",id:"rules-without-reachability-analysis",level:2},{value:"Manifest file",id:"manifest-file",level:2},{value:"Package manager",id:"package-manager",level:2},{value:"Package registry",id:"package-registry",level:2},{value:"Reachable finding (and reachable vulnerability)",id:"reachable-finding-and-reachable-vulnerability",level:2},{value:"Reachability",id:"reachability",level:2},...o.RM,{value:"Reachability rules",id:"reachability-rules",level:2},{value:"Software bill of materials (SBOM)",id:"software-bill-of-materials-sbom",level:2},{value:"Threat",id:"threat",level:2},{value:"Transitive or indirect dependency",id:"transitive-or-indirect-dependency",level:2},{value:"Transitivity",id:"transitivity",level:2},...t.RM,{value:"Usage",id:"usage",level:2},{value:"Unreachable finding (and unreachable vulnerability)",id:"unreachable-finding-and-unreachable-vulnerability",level:2},{value:"Vulnerability",id:"vulnerability",level:2}];function u(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"semgrep-supply-chain-glossary",children:"Semgrep Supply Chain glossary"})}),"\n",(0,s.jsx)(i.p,{children:"The terms and definitions provided here are specific to Semgrep Supply Chain."}),"\n",(0,s.jsx)(i.h2,{id:"advisory",children:"Advisory"}),"\n",(0,s.jsxs)(i.p,{children:["Announcement of a vulnerability, typically but not always with an associated ",(0,s.jsx)(i.a,{href:"https://www.cve.org/",children:"Common Vulnerabilities and Exposures (CVE)"})," number. All Advisories can be found by Semgrep Supply Chain rules. Advisories can be seen within the ",(0,s.jsx)(i.strong,{children:"Supply Chain > Advisories"})," tab."]}),"\n",(0,s.jsx)(i.h2,{id:"dependency",children:"Dependency"}),"\n",(0,s.jsx)(i.p,{children:"Publicly available code used as a part of your application. Common examples include Flask, React, and Lodash. Each dependency is listed in a registry, such as npm for JavaScript and PyPI for Python."}),"\n",(0,s.jsx)(i.h2,{id:"exploitability",children:"Exploitability"}),"\n",(0,s.jsx)(i.p,{children:"Exploitability is the practical assessment of a vulnerability's threat, typically proved with a real proof of exploit. Proving exploitability is often the last step of triaging a vulnerability."}),"\n",(0,s.jsx)(i.h2,{id:"epss-probability",children:"EPSS probability"}),"\n",(0,s.jsx)(l.Ay,{}),"\n",(0,s.jsx)(i.h2,{id:"lockfile",children:"Lockfile"}),"\n",(0,s.jsxs)(i.p,{children:["A lockfile describes a dependency tree to ensure that deployments and organizations install the same ",(0,s.jsx)(i.strong,{children:"dependencies and exact versions"})," for their codebase. Lockfile information includes versions of the dependency and any transitive (indirect) dependencies. Lockfiles are automatically generated by a package manager such as ",(0,s.jsx)(i.code,{children:"pip"})," or ",(0,s.jsx)(i.code,{children:"npm"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"Semgrep Supply Chain uses lockfiles as part of its analysis to determine the exact version of a dependency that a codebase is using."}),"\n",(0,s.jsx)(i.h2,{id:"rules-without-reachability-analysis",children:"Rules without reachability analysis"}),"\n",(0,s.jsx)(i.p,{children:"Some Semgrep Supply Chain rules do not perform reachability analysis. These rules only check a package's version against versions with known vulnerabilities. These rules produce vulnerabilities similar to GitHub Dependabot's results, and have a higher false positive rate than reachability rules."}),"\n",(0,s.jsxs)(i.p,{children:["Compare its opposite: ",(0,s.jsx)(i.a,{href:"#reachability-rules",children:"Reachability-rules"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"manifest-file",children:"Manifest file"}),"\n",(0,s.jsx)(i.p,{children:"A manifest file describes the dependencies used in your codebase. In a manifest file, a dependency may indicate a range of versions. A package manager reads the manifest file when installing dependencies into a specific implementation of your codebase, then generates a manifest file specifying the exact version of each dependency installed and any transitive dependencies."}),"\n",(0,s.jsxs)(i.p,{children:["Semgrep Supply Chain uses manifest files to resolve transitive dependencies for some languages. For more information, see ",(0,s.jsx)(i.a,{href:"/docs/supported-languages#semgrep-supply-chain",children:"Supported languages"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"package-manager",children:"Package manager"}),"\n",(0,s.jsx)(i.p,{children:"A software tool that interacts with a package registry to download, upload, or search for dependencies. Package managers typically generate manifest files or lockfiles by analyzing manifest files."}),"\n",(0,s.jsx)(i.h2,{id:"package-registry",children:"Package registry"}),"\n",(0,s.jsx)(i.p,{children:"A package registry stores dependencies and provides a means to upload or download dependencies. Each programming language has its own separate registry such as npm for JavaScript and PyPI for Python."}),"\n",(0,s.jsx)(i.h2,{id:"reachable-finding-and-reachable-vulnerability",children:"Reachable finding (and reachable vulnerability)"}),"\n",(0,s.jsxs)(i.p,{children:["A reachable finding means that you are using both a vulnerable code pattern (the ",(0,s.jsx)(i.strong,{children:"usage"}),") and the vulnerable version of a dependency. Within Semgrep Supply Chain, specific findings (usages) are grouped together by their vulnerability."]}),"\n",(0,s.jsx)(i.p,{children:"CI scans with Semgrep Supply Chain rules can block pull requests or merge requests upon detecting any reachable findings."}),"\n",(0,s.jsxs)(i.p,{children:["See also ",(0,s.jsx)(i.a,{href:"#reachability",children:"Reachability"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"reachability",children:"Reachability"}),"\n",(0,s.jsx)(o.Ay,{}),"\n",(0,s.jsx)(i.h2,{id:"reachability-rules",children:"Reachability rules"}),"\n",(0,s.jsx)(i.p,{children:"A type of Semgrep Supply Chain rule that performs reachability analysis. A reachability rule can determine if the vulnerable code pattern from a dependency is used in the codebase that imports it."}),"\n",(0,s.jsxs)(i.p,{children:["Compare its opposite: ",(0,s.jsx)(i.a,{href:"#rules-without-reachability-analysis",children:"rules without reachability analysis"})]}),"\n",(0,s.jsx)(i.h2,{id:"software-bill-of-materials-sbom",children:"Software bill of materials (SBOM)"}),"\n",(0,s.jsx)(i.p,{children:"Software Bill of Materials (also known as 'Cyber Bill of Materials', CBOM) is an artifact produced by many software composition analysis tools. It enumerates the various components of a software artifact such as dependencies, licenses, and security statuses. SBOMs are typically generated for compliance purposes. Regularly, a security engineer or related role signs-off on the SBOM, meaning that they accept the security and legal risk of the associated artifact."}),"\n",(0,s.jsx)(i.p,{children:"Semgrep Supply Chain can export a CycloneDX 1.4 XML/JSON-formatted SBOM."}),"\n",(0,s.jsx)(i.h2,{id:"threat",children:"Threat"}),"\n",(0,s.jsx)(i.p,{children:"A threat is any malicious event that violates the security of an application or network. A threat can result in disrupted business operations and loss or theft of data."}),"\n",(0,s.jsxs)(i.p,{children:["See also ",(0,s.jsx)(i.a,{href:"https://csrc.nist.gov/glossary/term/threat",children:"NIST definition of threat"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"transitive-or-indirect-dependency",children:"Transitive or indirect dependency"}),"\n",(0,s.jsxs)(i.p,{children:["A transitive or indirect dependency is a dependency of a dependency. If your codebase uses a dependency A, and A is dependent on B, then B is a transitive dependency. An example would be a codebase that uses ",(0,s.jsx)(i.a,{href:"https://www.npmjs.com/package/cloudinary",children:"Cloudinary"}),", which is dependent on Lodash. In this example, Lodash is a transitive dependency of the codebase."]}),"\n",(0,s.jsxs)(i.p,{children:["For more information, see ",(0,s.jsx)(i.a,{href:"/docs/supported-languages#semgrep-supply-chain",children:"Supported languages"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"transitivity",children:"Transitivity"}),"\n",(0,s.jsx)(i.p,{children:"Pertains to a dependency's relationship to your codebase or first-party code."}),"\n",(0,s.jsx)(t.Ay,{}),"\n",(0,s.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(i.p,{children:"In Semgrep Supply Chain scans, a **usage **is a specific finding in your codebase where Semgrep has found a vulnerability. A vulnerability may have more than one usage, such as when a library is imported and used in many code files."}),"\n",(0,s.jsx)(i.h2,{id:"unreachable-finding-and-unreachable-vulnerability",children:"Unreachable finding (and unreachable vulnerability)"}),"\n",(0,s.jsx)(i.p,{children:"An unreachable finding means that the dependency's version contains a known vulnerability, but the vulnerable code is not used within your codebase. Within Semgrep Supply Chain, specific findings (usages) are grouped together by their vulnerability."}),"\n",(0,s.jsx)(i.h2,{id:"vulnerability",children:"Vulnerability"}),"\n",(0,s.jsxs)(i.p,{children:["A vulnerability is an unintentional flaw in a dependency that can be exploited. Vulnerabilities are assigned a CVE by the ",(0,s.jsx)(i.a,{href:"https://cve.mitre.org/",children:"MITRE corporation"}),". Semgrep Supply Chain uses GitHub Security Advisory (GHSA) in categorizing the severity of a vulnerability."]})]})}function y(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>l});var a=n(96540);const s={},r=a.createContext(s);function t(e){const i=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(r.Provider,{value:i},e.children)}},57579:(e,i,n)=>{n.d(i,{Ay:()=>l,RM:()=>r});var a=n(74848),s=n(28453);const r=[];function t(e){const i={a:"a",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.p,{children:"Reachability refers to whether or not a vulnerable code pattern from a dependency is used in the codebase that imports it. In Semgrep Supply Chain, both a dependency's vulnerable version and code pattern must match for a vulnerability to be considered reachable."}),"\n",(0,a.jsxs)(i.p,{children:["See ",(0,a.jsx)(i.a,{href:"/semgrep-supply-chain/overview",children:"Overview of Semgrep Supply Chain"})," to learn how Semgrep leverages its code-scanning and rule syntax capabilities to provide high-signal rules that determine a finding's reachability. This assists security engineers in remediation and triage processes."]})]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(t,{...e})}):t(e)}},82305:(e,i,n)=>{n.d(i,{Ay:()=>l,RM:()=>r});var a=n(74848),s=n(28453);const r=[];function t(e){const i={a:"a",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.p,{children:["The ",(0,a.jsx)(i.a,{href:"https://www.first.org/epss/",children:"Exploit prediction scoring system (EPSS) probability"})," represents the likelihood that the vulnerability will be exploited in the wild in the next 30 days. Its values range from 0% to 100%. The higher the score, the greater the probability the vulnerability will be exploited. Semgrep groups probabilities as follows:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)("b",{children:"High"}),": 50 - 100%"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)("b",{children:"Medium"}),": 10 - <50%"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)("b",{children:"Low"}),": <10%"]}),"\n"]})]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(t,{...e})}):t(e)}},90050:(e,i,n)=>{n.d(i,{Ay:()=>l,RM:()=>r});var a=n(74848),s=n(28453);const r=[];function t(e){const i={li:"li",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Direct"}),": Your project depends directly on the dependency."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Transitive"}),": Your project's dependency depends on a vulnerable dependency."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Undetermined"}),": Semgrep had no transitivity information for the dependency as it relates to your project."]}),"\n"]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(t,{...e})}):t(e)}}}]);