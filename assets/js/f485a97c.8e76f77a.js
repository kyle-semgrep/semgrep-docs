"use strict";(self.webpackChunkmegadocs=self.webpackChunkmegadocs||[]).push([[59792],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var a=s(96540);const t={},i=a.createContext(t);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},92975:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"writing-rules/pattern-syntax","title":"Pattern syntax","description":"Learn Semgrep\'s pattern syntax to search code for a given code pattern. If you\'re just getting started writing Semgrep rules, check out the Semgrep Tutorial at https://semgrep.dev/learn","source":"@site/docs/writing-rules/pattern-syntax.mdx","sourceDirName":"writing-rules","slug":"/writing-rules/pattern-syntax","permalink":"/semgrep-docs/writing-rules/pattern-syntax","draft":false,"unlisted":false,"editUrl":"https://github.com/kyle-semgrep/semgrep-docs/edit/main/docs/writing-rules/pattern-syntax.mdx","tags":[{"inline":true,"label":"Rule writing","permalink":"/semgrep-docs/tags/rule-writing"}],"version":"current","lastUpdatedAt":1752504841000,"frontMatter":{"append_help_link":true,"slug":"pattern-syntax","description":"Learn Semgrep\'s pattern syntax to search code for a given code pattern. If you\'re just getting started writing Semgrep rules, check out the Semgrep Tutorial at https://semgrep.dev/learn","tags":["Rule writing"]},"sidebar":"rulewritingSidebar","previous":{"title":"Pattern examples","permalink":"/semgrep-docs/writing-rules/pattern-examples"},"next":{"title":"Custom rule examples","permalink":"/semgrep-docs/writing-rules/rule-ideas"}}');var t=s(74848),i=s(28453);const r={append_help_link:!0,slug:"pattern-syntax",description:"Learn Semgrep's pattern syntax to search code for a given code pattern. If you're just getting started writing Semgrep rules, check out the Semgrep Tutorial at https://semgrep.dev/learn",tags:["Rule writing"]},l="Pattern syntax",o={},c=[{value:"Pattern matching",id:"pattern-matching",level:2},{value:"Ellipsis operator",id:"ellipsis-operator",level:2},{value:"Function calls",id:"function-calls",level:3},{value:"Method calls",id:"method-calls",level:3},{value:"Function definitions",id:"function-definitions",level:3},{value:"Class definitions",id:"class-definitions",level:3},{value:"Ellipsis operator scope",id:"ellipsis-operator-scope",level:4},{value:"Strings",id:"strings",level:3},{value:"Binary operations",id:"binary-operations",level:3},{value:"Containers",id:"containers",level:3},{value:"Conditionals and loops",id:"conditionals-and-loops",level:3},{value:"Matching single items with an ellipsis",id:"matching-single-items-with-an-ellipsis",level:3},{value:"Metavariables",id:"metavariables",level:2},{value:"Expression metavariables",id:"expression-metavariables",level:3},{value:"Import metavariables",id:"import-metavariables",level:3},{value:"Reoccurring metavariables",id:"reoccurring-metavariables",level:3},{value:"Literal Metavariables",id:"literal-metavariables",level:3},{value:"Typed metavariables",id:"typed-metavariables",level:3},{value:"Syntax",id:"syntax",level:4},{value:"Java:",id:"java",level:5},{value:"C:",id:"c",level:5},{value:"Go:",id:"go",level:5},{value:"TypeScript:",id:"typescript",level:5},{value:"Using typed metavariables",id:"using-typed-metavariables",level:4},{value:"Ellipsis metavariables",id:"ellipsis-metavariables",level:3},{value:"Anonymous metavariables",id:"anonymous-metavariables",level:3},{value:"Metavariable unification",id:"metavariable-unification",level:3},{value:"Display matched metavariables in rule messages",id:"display-matched-metavariables-in-rule-messages",level:3},{value:"Equivalences",id:"equivalences",level:2},{value:"Imports",id:"imports",level:3},{value:"Constants",id:"constants",level:3},{value:"Associative and commutative operators",id:"associative-and-commutative-operators",level:3},{value:"Deep expression operator",id:"deep-expression-operator",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Statements types",id:"statements-types",level:3},{value:"Statements as expressions",id:"statements-as-expressions",level:4},{value:"Partial expressions",id:"partial-expressions",level:3},{value:"Ellipses and statement blocks",id:"ellipses-and-statement-blocks",level:3},{value:"Partial statements",id:"partial-statements",level:3},{value:"Other partial constructs",id:"other-partial-constructs",level:3},{value:"Deprecated features",id:"deprecated-features",level:2},{value:"String matching",id:"string-matching",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pattern-syntax",children:"Pattern syntax"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Getting started with rule writing? Try the ",(0,t.jsx)(n.a,{href:"https://semgrep.dev/learn",children:"Semgrep Tutorial"})," \ud83c\udf93"]})}),"\n",(0,t.jsxs)(n.p,{children:["This document describes Semgrep\u2019s pattern syntax. You can also see pattern ",(0,t.jsx)(n.a,{href:"/writing-rules/pattern-examples",children:"examples by language"}),". In the command line, patterns are specified with the flag ",(0,t.jsx)(n.code,{children:"--pattern"})," (or ",(0,t.jsx)(n.code,{children:"-e"}),"). Multiple\ncoordinating patterns may be specified in a configuration file. See\n",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax",children:"rule syntax"})," for more information."]}),"\n",(0,t.jsx)(n.h2,{id:"pattern-matching",children:"Pattern matching"}),"\n",(0,t.jsxs)(n.p,{children:["Pattern matching searches code for a given pattern. For example, the\nexpression pattern ",(0,t.jsx)(n.code,{children:"1 + func(42)"})," can match a full expression or be\npart of a subexpression:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo(1 + func(42)) + bar()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the same way, the statement pattern ",(0,t.jsx)(n.code,{children:"return 42"})," can match a top\nstatement in a function or any nested statement:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def foo(x):\n  if x > 1:\n     if x > 2:\n       return 42\n  return 42\n"})}),"\n",(0,t.jsx)(n.h2,{id:"ellipsis-operator",children:"Ellipsis operator"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"..."})," ellipsis operator abstracts away a sequence of zero or more\nitems such as arguments, statements, parameters, fields, characters."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"..."})," ellipsis can also match any single item that is not part of\na sequence when the context allows it."]}),"\n",(0,t.jsx)(n.p,{children:"See the use cases in the subsections below."}),"\n",(0,t.jsx)(n.h3,{id:"function-calls",children:"Function calls"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ellipsis operator to search for function calls or\nfunction calls with specific arguments. For example, the pattern ",(0,t.jsx)(n.code,{children:"insecure_function(...)"})," finds calls regardless of its arguments."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'insecure_function("MALICIOUS_STRING", arg1, arg2)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Functions and classes can be referenced by their fully qualified name, e.g.,"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"django.utils.safestring.mark_safe(...)"})," or ",(0,t.jsx)(n.code,{children:"mark_safe(...)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"System.out.println(...)"})," or ",(0,t.jsx)(n.code,{children:"println(...)"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can also search for calls with arguments after a match. The pattern ",(0,t.jsx)(n.code,{children:"func(1, ...)"})," will match both:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'func(1, "extra stuff", False)\nfunc(1)  # Matches no arguments as well\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Or find calls with arguments before a match with ",(0,t.jsx)(n.code,{children:"func(..., 1)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'func("extra stuff", False, 1)\nfunc(1)  # Matches no arguments as well\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"requests.get(..., verify=False, ...)"})," finds calls where an argument appears anywhere:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"requests.get(verify=False, url=URL)\nrequests.get(URL, verify=False, timeout=3)\nrequests.get(URL, verify=False)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Match the keyword argument value with the pattern ",(0,t.jsx)(n.code,{children:"$FUNC(..., $KEY=$VALUE, ...)"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"method-calls",children:"Method calls"}),"\n",(0,t.jsxs)(n.p,{children:["The ellipsis operator can also be used to search for method calls.\nFor example, the pattern ",(0,t.jsx)(n.code,{children:"$OBJECT.extractall(...)"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"tarball.extractall('/path/to/directory')  # Oops, potential arbitrary file overwrite\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also use the ellipsis in chains of method calls. For example,\nthe pattern ",(0,t.jsx)(n.code,{children:"$O.foo(). ... .bar()"})," will match:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"obj = MakeObject()\nobj.foo().other_method(1,2).again(3,4).bar()\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"function-definitions",children:"Function definitions"}),"\n",(0,t.jsxs)(n.p,{children:["The ellipsis operator can be used in function parameter lists or in the function\nbody. To find function definitions with ",(0,t.jsx)(n.a,{href:"https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments",children:"mutable default arguments"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n  def $FUNC(..., $ARG={}, ...):\n      ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def parse_data(parser, data={}):  # Oops, mutable default arguments\n    pass\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["The YAML ",(0,t.jsx)(n.code,{children:"|"})," operator allows for ",(0,t.jsx)(n.a,{href:"https://yaml-multiline.info/",children:"multiline strings"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["The ellipsis operator can match the function name.\nMatch any function definition:\nRegular functions, methods, and also anonymous functions (such as lambdas).\nTo match named or anonymous functions use an ellipsis ",(0,t.jsx)(n.code,{children:"..."})," in place of the name of the function.\nFor example, in JavaScript the pattern ",(0,t.jsx)(n.code,{children:"function ...($X) { ... }"})," matches\nany function with one parameter:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function foo(a) {\n  return a;\n}\nvar bar = function (a) {\n  return a;\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"class-definitions",children:"Class definitions"}),"\n",(0,t.jsx)(n.p,{children:"The ellipsis operator can be used in class definitions. To find classes that\ninherit from a certain parent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n  class $CLASS(InsecureBaseClass):\n      ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class DataRetriever(InsecureBaseClass):\n    def __init__(self):\n        pass\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["The YAML ",(0,t.jsx)(n.code,{children:"|"})," operator allows for ",(0,t.jsx)(n.a,{href:"https://yaml-multiline.info/",children:"multiline strings"}),"."]})}),"\n",(0,t.jsx)(n.h4,{id:"ellipsis-operator-scope",children:"Ellipsis operator scope"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"..."})," ellipsis operator matches everything in its current scope. The current scope of this operator is defined by the patterns that precede ",(0,t.jsx)(n.code,{children:"..."})," in a rule. See the following example:"]}),"\n",(0,t.jsx)("iframe",{src:"https://semgrep.dev/embed/editor?snippet=zZx0",border:"0",frameBorder:"0",width:"100%",height:"432"}),"\n",(0,t.jsxs)(n.p,{children:["Semgrep matches the first occurrence of ",(0,t.jsx)(n.code,{children:"bar"})," and ",(0,t.jsx)(n.code,{children:"baz"})," in the test code as these objects fall under the scope of ",(0,t.jsx)(n.code,{children:"foo"})," and ",(0,t.jsx)(n.code,{children:"..."}),". The ellipsis operator does not match the second occurrence of ",(0,t.jsx)(n.code,{children:"bar"})," and ",(0,t.jsx)(n.code,{children:"baz"})," as they are not inside of the function definition, therefore these objects in their second occurrence are not inside the scope of the ellipsis operator."]}),"\n",(0,t.jsx)(n.h3,{id:"strings",children:"Strings"}),"\n",(0,t.jsxs)(n.p,{children:["The ellipsis operator can be used to search for strings containing any data. The pattern ",(0,t.jsx)(n.code,{children:'crypto.set_secret_key("...")'})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'crypto.set_secret_key("HARDCODED SECRET")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This also works with ",(0,t.jsx)(n.a,{href:"#constants",children:"constant propagation"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In languages where regular expressions use a special syntax\n(for example JavaScript), the pattern ",(0,t.jsx)(n.code,{children:"/.../"})," will match\nany regular expression construct:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"re1 = /foo|bar/;\nre2 = /a.*b/;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"binary-operations",children:"Binary operations"}),"\n",(0,t.jsxs)(n.p,{children:["The ellipsis operator can match any number of arguments to binary operations. The pattern ",(0,t.jsx)(n.code,{children:"$X = 1 + 2 + ..."})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo = 1 + 2 + 3 + 4\n"})}),"\n",(0,t.jsx)(n.h3,{id:"containers",children:"Containers"}),"\n",(0,t.jsx)(n.p,{children:"The ellipsis operator can match inside container data structures like lists, arrays, and key-value stores."}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"user_list = [..., 10]"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user_list = [8, 9, 10]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"user_dict = {...}"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user_dict = {'username': 'password'}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"user_dict = {..., $KEY: $VALUE, ...}"})," matches the following and allows for further metavariable queries:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user_dict = {'username': 'password', 'address': 'zipcode'}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also match just a key-value pair in\na container, for example in JSON the pattern ",(0,t.jsx)(n.code,{children:'"foo": $X'})," matches\njust a single line in:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{ "bar": True,\n  "name": "self",\n  "foo": 42\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"conditionals-and-loops",children:"Conditionals and loops"}),"\n",(0,t.jsx)(n.p,{children:"The ellipsis operator can be used inside conditionals or loops. The pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n  if $CONDITION:\n      ...\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["The YAML ",(0,t.jsx)(n.code,{children:"|"})," operator allows for ",(0,t.jsx)(n.a,{href:"https://yaml-multiline.info/",children:"multiline strings"}),"."]})}),"\n",(0,t.jsx)(n.p,{children:"matches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"if can_make_request:\n    check_status()\n    make_request()\n    return\n"})}),"\n",(0,t.jsx)(n.p,{children:"A metavariable can match a conditional or loop body if the body statement information is re-used later. The pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n  if $CONDITION:\n      $BODY\n"})}),"\n",(0,t.jsx)(n.p,{children:"matches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"if can_make_request:\n    single_request_statement()\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Half or partial statements can't be matches; both of the examples above must specify the contents of the condition\u2019s body (e.g., ",(0,t.jsx)(n.code,{children:"$BODY"})," or ",(0,t.jsx)(n.code,{children:"..."}),"), otherwise they are not valid patterns."]})}),"\n",(0,t.jsx)(n.h3,{id:"matching-single-items-with-an-ellipsis",children:"Matching single items with an ellipsis"}),"\n",(0,t.jsxs)(n.p,{children:["Ellipsis ",(0,t.jsx)(n.code,{children:"..."})," is generally used to match sequences of similar elements.\nHowever, you can also match single item using ellipsis ",(0,t.jsx)(n.code,{children:"..."})," operator.\nThe following pattern is valid in languages with a C-like\nsyntax even though ",(0,t.jsx)(n.code,{children:"..."})," matches a single Boolean value rather\nthan a sequence:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"if (...)\n  return 42;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Another example where a single expression is matched by an ellipsis is\nthe right-hand side of assignments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"foo = ...;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, matching a sequence of items remains the default meaning of an\nellipsis. For example, the pattern ",(0,t.jsx)(n.code,{children:"bar(...)"})," matches ",(0,t.jsx)(n.code,{children:"bar(a)"}),",\nbut also ",(0,t.jsx)(n.code,{children:"bar(a, b)"})," and ",(0,t.jsx)(n.code,{children:"bar()"}),". To force a match on a single item,\nuse a metavariable as in ",(0,t.jsx)(n.code,{children:"bar($X)"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"metavariables",children:"Metavariables"}),"\n",(0,t.jsxs)(n.p,{children:["Metavariables are an abstraction to match code when you don\u2019t know the value or contents ahead of time, similar to ",(0,t.jsx)(n.a,{href:"https://regexone.com/lesson/capturing_groups",children:"capture groups"})," in regular expressions."]}),"\n",(0,t.jsx)(n.p,{children:"Metavariables can be used to track values across a specific code scope. This\nincludes variables, functions, arguments, classes, object methods, imports,\nexceptions, and more."}),"\n",(0,t.jsxs)(n.p,{children:["Metavariables look like ",(0,t.jsx)(n.code,{children:"$X"}),", ",(0,t.jsx)(n.code,{children:"$WIDGET"}),", or ",(0,t.jsx)(n.code,{children:"$USERS_2"}),". They begin with a ",(0,t.jsx)(n.code,{children:"$"})," and can only\ncontain uppercase characters, ",(0,t.jsx)(n.code,{children:"_"}),", or digits. Names like ",(0,t.jsx)(n.code,{children:"$x"})," or ",(0,t.jsx)(n.code,{children:"$some_value"})," are invalid."]}),"\n",(0,t.jsx)(n.h3,{id:"expression-metavariables",children:"Expression metavariables"}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"$X + $Y"})," matches the following code examples:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo() + bar()\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"current + total\n"})}),"\n",(0,t.jsx)(n.h3,{id:"import-metavariables",children:"Import metavariables"}),"\n",(0,t.jsxs)(n.p,{children:["Metavariables can also be used to match imports. For example, ",(0,t.jsx)(n.code,{children:"import $X"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import random\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reoccurring-metavariables",children:"Reoccurring metavariables"}),"\n",(0,t.jsx)(n.p,{children:"Re-using metavariables shows their true power. Detect useless assignments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n  $X = $Y\n  $X = $Z\n"})}),"\n",(0,t.jsx)(n.p,{children:"Useless assignment detected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"initial_value = 10  # Oops, useless assignment\ninitial_value = get_initial_value()\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["The YAML ",(0,t.jsx)(n.code,{children:"|"})," operator allows for ",(0,t.jsx)(n.a,{href:"https://yaml-multiline.info/",children:"multiline strings"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"literal-metavariables",children:"Literal Metavariables"}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.code,{children:'"$X"'})," to match any string literal. This is similar\nto using ",(0,t.jsx)(n.code,{children:'"..."'}),", but the content of the string is stored in the\nmetavariable ",(0,t.jsx)(n.code,{children:"$X"}),", which can then be used in a message\nor in a ",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-regex",children:(0,t.jsx)(n.code,{children:"metavariable-regex"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also use ",(0,t.jsx)(n.code,{children:"/$X/"})," and ",(0,t.jsx)(n.code,{children:":$X"})," to respectively match\nany regular expressions or atoms (in languages that support\nthose constructs, e.g., Ruby)."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["Because literal metavariables bind to strings that may not be valid code, if you want to match them in more detail with a ",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax/#metavariable-pattern",children:(0,t.jsx)(n.code,{children:"metavariable-pattern"})}),", you must ",(0,t.jsxs)(n.a,{href:"/writing-rules/rule-syntax#metavariable-pattern-with-nested-language",children:["specify ",(0,t.jsx)(n.code,{children:"generic"})," language"]})," inside the ",(0,t.jsx)(n.code,{children:"metavariable-pattern"}),". For example:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'rules:\n  - id: match-literal-string\n    languages:\n      - python\n    severity: INFO\n    message: Found "$STRING"\n    patterns:\n      - pattern: \'"$STRING"\'\n      - metavariable-pattern:\n          language: generic\n          metavariable: $STRING\n          pattern: "literal string contents"\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"typed-metavariables",children:"Typed metavariables"}),"\n",(0,t.jsx)(n.h4,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.p,{children:"Typed metavariables only match a metavariable if it\u2019s declared as a specific type."}),"\n",(0,t.jsx)(n.h5,{id:"java",children:"Java:"}),"\n",(0,t.jsxs)(n.p,{children:["For example, to look for calls to the ",(0,t.jsx)(n.code,{children:"log"})," method on ",(0,t.jsx)(n.code,{children:"Logger"})," objects.\nA simple pattern for this purpose could use a metavariable for the Logger object."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: $LOGGER.log(...)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["But if we are concerned about finding calls to the ",(0,t.jsx)(n.code,{children:"Math.log()"})," method as well, we can use a typed metavariable to put a type constraint on the ",(0,t.jsx)(n.code,{children:"$LOGGER"})," metavariable."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: (java.util.logging.Logger $LOGGER).log(...)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Alternatively, if we want to capture more logger types, for example custom logger types, we could instead add a constraint to the type of the argument in this method call instead."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: $LOGGER.log(java.util.logging.LogRecord $RECORD)\n"})}),"\n",(0,t.jsx)(n.h5,{id:"c",children:"C:"}),"\n",(0,t.jsx)(n.p,{children:"In this example in C, we want to capture all cases where something is compared to a char array.\nWe start with a simple pattern that looks for comparison between two variables."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: $X == $Y\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can then put a type constraint on one of the metavariables used in this pattern by turning it into a typed metavariable."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: $X == (char *$Y)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'int main() {\n    char *a = "Hello";\n    int b = 1;\n\n    // Matched\n    if (a == "world") {\n        return 1;\n    }\n\n    // Not matched\n    if (b == 2) {\n        return -1;\n    }\n\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"go",children:"Go:"}),"\n",(0,t.jsxs)(n.p,{children:["The syntax for a typed metavariable in Go looks different from the syntax for Java.\nIn this Go example we look for calls to the ",(0,t.jsx)(n.code,{children:"Open"})," function, but only on an object of the ",(0,t.jsx)(n.code,{children:"zip.Reader"})," type."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: |\n    ($READER : *zip.Reader).Open($INPUT)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func read_file(reader *zip.Reader, filename) {\n\n\t// Matched\n\treader.Open(filename)\n\n    dir := http.Dir("/")\n\n\t// Not matched\n\tf, err := dir.Open(c.Param("file"))\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["For Go, Semgrep currently does not recognize the type of all variables that are declared on the same line. That is, the following will not take both ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," as ",(0,t.jsx)(n.code,{children:"int"}),"s: ",(0,t.jsx)(n.code,{children:"var a, b = 1, 2"})]})}),"\n",(0,t.jsx)(n.h5,{id:"typescript",children:"TypeScript:"}),"\n",(0,t.jsx)(n.p,{children:"In this example, we want to look for uses of the DomSanitizer function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: ($X: DomSanitizer).sanitize(...)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"constructor(\n  private _activatedRoute: ActivatedRoute,\n  private sanitizer: DomSanitizer,\n) { }\n\nngOnInit() {\n    // Not matched\n    this.sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(this._activatedRoute.snapshot.queryParams['q']))\n\n    // Matched\n    this.sanitizer.bypassSecurityTrustHtml(this.sanitizer.sanitize(this._activatedRoute.snapshot.queryParams['q']))\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"using-typed-metavariables",children:"Using typed metavariables"}),"\n",(0,t.jsx)(n.p,{children:"Type inference applies to the entire file! One common way to use typed metavariables is to check for a function called on a specific type of object. For example, let's say you're looking for calls to a potentially unsafe logger in a class like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'class Test {\n    static Logger logger;\n\n    public static void run_test(String input, int num) {\n        logger.log("Running a test with " + input);\n\n        test(input, Math.log(num));\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you searched for ",(0,t.jsx)(n.code,{children:"$X.log(...)"}),", you can also match ",(0,t.jsx)(n.code,{children:"Math.log(num)"}),". Instead, you can search for ",(0,t.jsx)(n.code,{children:"(Logger $X).log(...)"})," which gives you the call to ",(0,t.jsx)(n.code,{children:"logger"}),". See the rule ",(0,t.jsx)(n.a,{href:"https://semgrep.dev/playground/s/lgAo",children:(0,t.jsx)(n.code,{children:"logger_search"})}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Since matching happens within a single file, this is only guaranteed to work for local variables and arguments. Additionally, Semgrep currently understands types on a shallow level. For example, if you have ",(0,t.jsx)(n.code,{children:"int[] A"}),", it will not recognize ",(0,t.jsx)(n.code,{children:"A[0]"})," as an integer. If you have a class with fields, you will not be able to use typechecking on field accesses, and it will not recognize the class\u2019s field as the expected type. Literal types are understood to a limited extent. Expanded type support is under active development."]})}),"\n",(0,t.jsx)(n.h3,{id:"ellipsis-metavariables",children:"Ellipsis metavariables"}),"\n",(0,t.jsxs)(n.p,{children:["You can combine ellipses and metavariables to match a sequence\nof arguments and store the matched sequence in a metavariable.\nFor example the pattern ",(0,t.jsx)(n.code,{children:"foo($...ARGS, 3, $...ARGS)"})," will\nmatch:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo(1,2,3,1,2)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When referencing an ellipsis metavariable in a rule message or ",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax#metavariable-pattern",children:"metavariable-pattern"}),", include the ellipsis:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- message: Call to foo($...ARGS)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"anonymous-metavariables",children:"Anonymous metavariables"}),"\n",(0,t.jsx)(n.p,{children:"Anonymous metavariables are used to specify that a metavariable exists in the pattern you want to capture."}),"\n",(0,t.jsxs)(n.p,{children:["An anonymous metavariable always takes the form ",(0,t.jsx)(n.code,{children:"$_"}),". Variables such as ",(0,t.jsx)(n.code,{children:"$_1"})," or ",(0,t.jsx)(n.code,{children:"$_2"})," are ",(0,t.jsx)(n.strong,{children:"not"})," anonymous. You can use more than one anonymous metavariable in a rule definition."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, if you want to specify that a function should ",(0,t.jsx)(n.strong,{children:"always"})," have 3 arguments, then you can use anonymous metavariables:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- pattern: def function($_, $_, $_)\n"})}),"\n",(0,t.jsx)(n.p,{children:"An anonymous metavariable does not produce any binding to the code it matched. This means it does not enforce that it matches the same code at each place it is used. The pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- pattern: def function($A, $B, $C)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["is not equivalent to the former example, as ",(0,t.jsx)(n.code,{children:"$A"}),", ",(0,t.jsx)(n.code,{children:"$B"}),", and ",(0,t.jsx)(n.code,{children:"$C"})," bind to the code that matched the pattern. You can then use ",(0,t.jsx)(n.code,{children:"$A"})," or any other metavariable in your rule definition to specify that specific code. Anonymous metavariables cannot be used this way."]}),"\n",(0,t.jsx)(n.p,{children:"Anonymous metavariables also communicate to the reader that their values are not relevant, but rather their occurrence in the pattern."}),"\n",(0,t.jsx)(n.h3,{id:"metavariable-unification",children:"Metavariable unification"}),"\n",(0,t.jsxs)(n.p,{children:["For search mode rules, metavariables with the same name are treated as the same metavariable within the ",(0,t.jsx)(n.code,{children:"patterns"})," operator. This is called metavariable unification."]}),"\n",(0,t.jsxs)(n.p,{children:["For taint mode rules, patterns defined ",(0,t.jsx)(n.strong,{children:"within"})," ",(0,t.jsx)(n.code,{children:"pattern-sinks"})," and ",(0,t.jsx)(n.code,{children:"pattern-sources"})," still unify. However, metavariable unification ",(0,t.jsx)(n.strong,{children:"between"})," ",(0,t.jsx)(n.code,{children:"pattern-sinks"})," and ",(0,t.jsx)(n.code,{children:"pattern-sources"})," is ",(0,t.jsx)(n.strong,{children:"not"})," enabled by default."]}),"\n",(0,t.jsxs)(n.p,{children:["To enforce unification, set ",(0,t.jsx)(n.code,{children:"taint_unify_mvars: true"})," under the rule ",(0,t.jsx)(n.code,{children:"options"})," key. When ",(0,t.jsx)(n.code,{children:"taint_unify_mvars: true"})," is set, a metavariable defined in ",(0,t.jsx)(n.code,{children:"pattern-sinks"})," and ",(0,t.jsx)(n.code,{children:"pattern-sources"})," with the same name is treated as the same metavariable. See ",(0,t.jsx)(n.a,{href:"/writing-rules/data-flow/taint-mode#metavariables-rule-message-and-unification",children:"Metavariables, rule message, and unification"})," for more information."]}),"\n",(0,t.jsx)(n.h3,{id:"display-matched-metavariables-in-rule-messages",children:"Display matched metavariables in rule messages"}),"\n",(0,t.jsxs)(n.p,{children:["Display values of matched metavariables in rule messages. Add a metavariable to the rule message (for example ",(0,t.jsx)(n.code,{children:"Found $X"}),") and Semgrep replaces it with the value of the detected metavariable."]}),"\n",(0,t.jsx)(n.p,{children:"To display matched metavariable in a rule message, add the same metavariable as you are searching for in your rule to the rule message."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Find the metavariable used in the Semgrep rule. See the following example of a part Semgrep rule (formula):","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- pattern: $MODEL.set_password(\u2026)\n"})}),"\n","This formula uses ",(0,t.jsx)(n.code,{children:"$MODEL"})," as a metavariable."]}),"\n",(0,t.jsxs)(n.li,{children:["Insert the metavariable to rule message:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- message: Setting a password on $MODEL\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Use the formula displayed above against the following code:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"user.set_password(new_password)\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The resulting message is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Setting a password on user\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Run the following example in Semgrep Playground to see the message (click ",(0,t.jsx)(n.strong,{children:"Open in Editor"}),", and then ",(0,t.jsx)(n.strong,{children:"Run"}),", unroll the ",(0,t.jsx)(n.strong,{children:"1 Match"})," to see the message):"]}),"\n",(0,t.jsx)("iframe",{title:"Metavariable value in message example",src:"https://semgrep.dev/embed/editor?snippet=6KpK",width:"100%",height:"432",frameborder:"0"}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["If you're using Semgrep's advanced dataflow features, see documentation of experimental feature ",(0,t.jsx)(n.a,{href:"/writing-rules/experiments/display-propagated-metavariable",children:"Displaying propagated value of metavariable"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"equivalences",children:"Equivalences"}),"\n",(0,t.jsx)(n.p,{children:"Semgrep automatically searches for code that is semantically equivalent."}),"\n",(0,t.jsx)(n.h3,{id:"imports",children:"Imports"}),"\n",(0,t.jsx)(n.p,{children:"Equivalent imports using aliasing or submodules are matched."}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"subprocess.Popen(...)"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import subprocess.Popen as sub_popen\nsub_popen('ls')\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:"foo.bar.baz.qux(...)"})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from foo.bar import baz\nbaz.qux()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,t.jsx)(n.p,{children:"Semgrep performs constant propagation."}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:'set_password("password")'})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'HARDCODED_PASSWORD = "password"\n\ndef update_system():\n    set_password(HARDCODED_PASSWORD)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Basic constant propagation support like in the example above is a stable feature.\nExperimentally, Semgrep also supports ",(0,t.jsx)(n.a,{href:"/writing-rules/data-flow/constant-propagation",children:"intra-procedural flow-sensitive constant propagation"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:'set_password("...")'})," also matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def update_system():\n    if cond():\n        password = "abc"\n    else:\n        password = "123"\n    set_password(password)\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["It is possible to disable constant propagation in a per-rule basis via the ",(0,t.jsxs)(n.a,{href:"/writing-rules/rule-syntax#options",children:[(0,t.jsx)(n.code,{children:"options"})," rule field"]}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"associative-and-commutative-operators",children:"Associative and commutative operators"}),"\n",(0,t.jsxs)(n.p,{children:["Semgrep performs associative-commutative (AC) matching. For example, ",(0,t.jsx)(n.code,{children:"... && B && C"})," will match both ",(0,t.jsx)(n.code,{children:"B && C"})," and ",(0,t.jsx)(n.code,{children:"(A && B) && C"})," (i.e., ",(0,t.jsx)(n.code,{children:"&&"})," is associative). Also, ",(0,t.jsx)(n.code,{children:"A | B | C"})," will match ",(0,t.jsx)(n.code,{children:"A | B | C"}),", and ",(0,t.jsx)(n.code,{children:"B | C | A"}),", and ",(0,t.jsx)(n.code,{children:"C | B | A"}),", and any other permutation (i.e., ",(0,t.jsx)(n.code,{children:"|"})," is associative and commutative)."]}),"\n",(0,t.jsxs)(n.p,{children:["Under AC-matching metavariables behave similarly to ",(0,t.jsx)(n.code,{children:"..."}),". For example, ",(0,t.jsx)(n.code,{children:"A | $X"})," can match ",(0,t.jsx)(n.code,{children:"A | B | C"})," in four different ways (",(0,t.jsx)(n.code,{children:"$X"})," can bind to ",(0,t.jsx)(n.code,{children:"B"}),", or ",(0,t.jsx)(n.code,{children:"C"}),", or ",(0,t.jsx)(n.code,{children:"B | C"}),"). In order to avoid a combinatorial explosion, Semgrep will only perform AC-matching with metavariables if the number of potential matches is ",(0,t.jsx)(n.em,{children:"small"}),", otherwise it will produce just one match (if possible) where each metavariable is bound to a single operand."]}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax#options",children:(0,t.jsx)(n.code,{children:"options"})})," it is possible to entirely disable AC-matching. It is also possible to treat Boolean AND and OR operators (e.g., ",(0,t.jsx)(n.code,{children:"&&"})," in ",(0,t.jsx)(n.code,{children:"||"})," in C-family languages) as commutative, which can be useful despite not being semantically accurate."]}),"\n",(0,t.jsx)(n.h2,{id:"deep-expression-operator",children:"Deep expression operator"}),"\n",(0,t.jsxs)(n.p,{children:["Use the deep expression operator ",(0,t.jsx)(n.code,{children:"<... [your_pattern] ...>"})," to match an expression that could be deeply nested within another expression. An example is looking for a pattern anywhere within an ",(0,t.jsx)(n.code,{children:"if"})," statement. The deep expression operator matches your pattern in the current expression context and recursively in any subexpressions."]}),"\n",(0,t.jsx)(n.p,{children:"For example, this pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"pattern: |\n  if <... $USER.is_admin() ...>:\n    ...\n"})}),"\n",(0,t.jsx)(n.p,{children:"matches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"if user.authenticated() and user.is_admin() and user.has_group(gid):\n  [ CONDITIONAL BODY ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"The deep expression operator works in:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"if"})," statements: ",(0,t.jsx)(n.code,{children:"if <... $X ...>:"})]}),"\n",(0,t.jsxs)(n.li,{children:["nested calls: ",(0,t.jsx)(n.code,{children:"sql.query(<... $X ...>)"})]}),"\n",(0,t.jsxs)(n.li,{children:["operands of a binary expression: ",(0,t.jsx)(n.code,{children:'"..." + <... $X ...>'})]}),"\n",(0,t.jsx)(n.li,{children:"any other expression context"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.h3,{id:"statements-types",children:"Statements types"}),"\n",(0,t.jsxs)(n.p,{children:["Semgrep handles some statement types differently than others, particularly when searching for fragments inside statements. For example, the pattern ",(0,t.jsx)(n.code,{children:"foo"})," will match these statements:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"x += foo()\nreturn bar + foo\nfoo(1, 2)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["But ",(0,t.jsx)(n.code,{children:"foo"})," will not match the following statement (",(0,t.jsx)(n.code,{children:"import foo"})," will match it though):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import foo\n"})}),"\n",(0,t.jsx)(n.h4,{id:"statements-as-expressions",children:"Statements as expressions"}),"\n",(0,t.jsxs)(n.p,{children:["Many programming languages differentiate between expressions and statements. Expressions can appear inside if conditions, in function call arguments, etc. Statements can not appear everywhere; they are sequence of operations (in many languages using ",(0,t.jsx)(n.code,{children:";"})," as a separator/terminator) or special control flow constructs (if, while, etc.)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"foo()"})," is an expression (in most languages)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"foo();"})," is a statement (in most languages)."]}),"\n",(0,t.jsxs)(n.p,{children:["If your search pattern is a statement, Semgrep will automatically try to search for it as ",(0,t.jsx)(n.em,{children:"both"})," an expression and a statement."]}),"\n",(0,t.jsxs)(n.p,{children:["When you write the expression ",(0,t.jsx)(n.code,{children:"foo()"})," in a pattern, Semgrep will visit every expression and sub-expression in your program and try to find a match."]}),"\n",(0,t.jsxs)(n.p,{children:["Many programmers don't really see the difference between ",(0,t.jsx)(n.code,{children:"foo()"})," and ",(0,t.jsx)(n.code,{children:"foo();"}),". This is why when one looks for ",(0,t.jsx)(n.code,{children:"foo()"}),"; Semgrep thinks the user wants to match statements like ",(0,t.jsx)(n.code,{children:"a = foo();"}),", or ",(0,t.jsx)(n.code,{children:"print(foo());"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Note that in some programming languages such as Python, which does not use semicolons as a separator or terminator, the difference between expressions and statements is even more confusing. Indentation in Python matters, and a newline after ",(0,t.jsx)(n.code,{children:"foo()"})," is really the same than ",(0,t.jsx)(n.code,{children:"foo();"})," in other programming languages such as C."]})}),"\n",(0,t.jsx)(n.h3,{id:"partial-expressions",children:"Partial expressions"}),"\n",(0,t.jsx)(n.p,{children:"Partial expressions are not valid patterns. For example, the following is invalid:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"pattern: 1+\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A complete expression is needed (like ",(0,t.jsx)(n.code,{children:"1 + $X"}),")"]}),"\n",(0,t.jsx)(n.h3,{id:"ellipses-and-statement-blocks",children:"Ellipses and statement blocks"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"#ellipsis-operator",children:"ellipsis operator"})," does ",(0,t.jsx)(n.em,{children:"not"})," jump from inner to outer statement blocks."]}),"\n",(0,t.jsx)(n.p,{children:"For example, this pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"foo()\n...\nbar()\n"})}),"\n",(0,t.jsx)(n.p,{children:"matches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo()\nbaz()\nbar()\n"})}),"\n",(0,t.jsx)(n.p,{children:"and also matches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"foo()\nbaz()\nif cond:\n    bar()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["but it does ",(0,t.jsx)(n.em,{children:"not"})," match:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"if cond:\n    foo()\nbaz()\nbar()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["because ",(0,t.jsx)(n.code,{children:"..."})," cannot jump from the inner block where ",(0,t.jsx)(n.code,{children:"foo()"})," is, to the outer block where ",(0,t.jsx)(n.code,{children:"bar()"})," is."]}),"\n",(0,t.jsx)(n.h3,{id:"partial-statements",children:"Partial statements"}),"\n",(0,t.jsxs)(n.p,{children:["Partial statements are partially supported. For example,\nyou can just match the header of a conditional with ",(0,t.jsx)(n.code,{children:"if ($E)"}),",\nor just the try part of an exception statement with ",(0,t.jsx)(n.code,{children:"try { ... }"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This is especially useful when used in a\n",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax#pattern-inside",children:"pattern-inside"})," to restrict the\ncontext in which to search for other things."]}),"\n",(0,t.jsx)(n.h3,{id:"other-partial-constructs",children:"Other partial constructs"}),"\n",(0,t.jsxs)(n.p,{children:["It is possible to just match the header of a function (without its body),\nfor example ",(0,t.jsx)(n.code,{children:"int foo(...)"})," to match just the header part of the\nfunction ",(0,t.jsx)(n.code,{children:"foo"}),". In the same way, you can just match a class header\n(e.g., with ",(0,t.jsx)(n.code,{children:"class $A"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"deprecated-features",children:"Deprecated features"}),"\n",(0,t.jsx)(n.h3,{id:"string-matching",children:"String matching"}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["String matching has been deprecated. You should use ",(0,t.jsx)(n.a,{href:"/writing-rules/rule-syntax#metavariable-regex",children:(0,t.jsx)(n.code,{children:"metavariable-regex"})})," instead."]})}),"\n",(0,t.jsxs)(n.p,{children:["Search string literals within code with ",(0,t.jsx)(n.a,{href:"https://learnxinyminutes.com/docs/pcre/",children:"Perl Compatible Regular Expressions (PCRE)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The pattern ",(0,t.jsx)(n.code,{children:'requests.get("=~/dev\\./i")'})," matches:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'requests.get("api.dev.corp.com")  # Oops, development API left in\n'})}),"\n",(0,t.jsxs)(n.p,{children:["To search for specific strings, use the syntax ",(0,t.jsx)(n.code,{children:'"=~/<regexp>/"'}),". Advanced regexp features are available, such as case-insensitive regexps with ",(0,t.jsx)(n.code,{children:"'/i'"})," (e.g., ",(0,t.jsx)(n.code,{children:'"=~/foo/i"'}),"). Matching occurs anywhere in the string unless the regexp ",(0,t.jsx)(n.code,{children:"^"})," anchor character is used: ",(0,t.jsx)(n.code,{children:'"=~/^foo.*/"'})," checks if a string begins with ",(0,t.jsx)(n.code,{children:"foo"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);